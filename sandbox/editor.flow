import ds/reducer;
import material/material;
import material/material2tropic;
import formats/dom/assign;
import formats/dom/render;

/*
TODO:
- Debug why we get multiple B and C nodes
- Implement arrays formats/dom/assign
- Figure out how to do layout using HTML. Maybe we should not make divs, but other constructs for nesting?
- Implement editing, and incremental updates
*/

REditor(
	// The document is represented as a bunch of assignments. This works for any data structure
	document : Behaviour<[RAssign<?>]>,
	// Where are the cursors?
	cursor : Behaviour<[RLValue]>,
	// What leading path are we focusing on?
	focus : Behaviour<RLValue>,
	// What elements are selected?
	selected : Behaviour<[RLValue]>,
	// What elements are collapsed?
	collapsed : Behaviour<[RLValue]>,
	// How to edit a given value: Convert it to IXmlNode for use in the DOM
	editValue : (e : RAssign<?>, cursor : bool, readonly : bool, selected : bool) -> RAssign<IXmlNode>,
);

makeView(e : REditor<?>) -> Material {
	wh = make(WidthHeight(0.0, 0.0));
	MInspect([IAvailable(wh)], 
		MHTMLStage(wh, \stage -> {
			// TODO: We could use some FRP array construct for the document to allow partial updates
			// instead of full updates
			us = fsubscribe(fselect3(e.document, e.cursor, e.selected, \assigns : [RAssign<?>], cursor, selected -> {
				// We run all the assignments
				iter(assigns,
					\a -> {
						xml = e.editValue(a, contains(cursor, a.lvalue), false, contains(selected, a.lvalue));
						htmlRAssign(stage, xml);
				});
				0;
			}), nop1);
			\ -> callList(us);
		})
	);
}

makeREditor(doc : [RAssign<?>], editFn : (e : RAssign<?>, cursor : bool, readonly : bool, selected : bool) -> RAssign<IXmlNode>) -> REditor {
	REditor(
		// The document
		make(doc),
		// The cursors
		make(if (doc != []) [doc[0].lvalue] else []),
		// Where the focus is
		make(RLeaf()),
		// Selection
		make([]),
		// What parts are collapsed
		make([]),
		// The function which will convert a node to HTML
		editFn
	);
}

jsonAssign2htmlAssign(l : RAssign<Json>, cursor : bool, readonly : bool, selected : bool) -> RAssign<IXmlNode> {
	RAssign(
		l.lvalue,
		viewRAssignHtml(l, cursor, readonly, selected)
	)
}

// This is called for all leafs
viewRAssignHtml(l : RAssign<Json>, cursor : bool, readonly : bool, selected : bool) -> IXmlNode {
	dom2ixml(switch (l.value) {
		JsonObject(members): eP("Object");
		JsonArray(value): eP("Array");
		JsonNull(): eP("null");
		JsonBool(v): eP(b2s(v));
		JsonDouble(v): eP(d2s(v));
		JsonString(s): eP(escapeHtml(s));
	});
}

main() {
	json1 = parseJsonSafe("
		{
			a: 0,
			b: [
				1,
				2,
				3
			],
			c: {
				d: true,
				e: null
			}
		}
	");

	editor = makeREditor(rreduceJson(json1, rarray()), jsonAssign2htmlAssign);
	mrender(
		makeMaterialManager([]), true,
		makeView(editor)
	);
	{}
}


/*

From the JSON, we get this sequence of RAssign<IXmlNode>:

RAssign(RLObject("a", RLeaf()), IXmlElement("p", [], [IXmlText("0")], []))
RAssign(RLObject("b", RLArrayPush(RLeaf())), IXmlElement("p", [], [IXmlText("1")], []))
RAssign(RLObject("b", RLArrayPush(RLeaf())), IXmlElement("p", [], [IXmlText("2")], []))
RAssign(RLObject("b", RLArrayPush(RLeaf())), IXmlElement("p", [], [IXmlText("3")], []))
RAssign(RLObject("c", RLObject("d", RLeaf())), IXmlElement("p", [], [IXmlText("true")], []))
RAssign(RLObject("c", RLObject("e", RLeaf())), IXmlElement("p", [], [IXmlText("null")], []))

That should correspond to

   <div id=".a"><p>0</p></div>
   <div id=".b">
        <div id=".b.0"><p>1</p></div>
        <div id=".b.1"><p>2</p></div>
        <div id=".b.2"><p>3</p></div>
   </div>
   <div id=".c">
       <div id=".c.d"><p>true</p></div>
       <div id=".c.e"><p>null</p></div>
   </div>

I.e. an lvalue object with "id" becomes <div id=path.id>, and RLArrayPush becomes <div id=path.index>.
RLLeaf is just text. The goal is that each id is unique.

Right now, there is a bug so we do not get this structure correctly.

The point is that with this approach, we can imperatively update the DOM tree efficiently, 
and rely on HTML to do a lot of layout for us.

TODO:

See we can maybe provide some kind of nesting structure:

RAssigns(
	assignments : [RAssign]
)

renderComap(p : Topic) -> RAssigns {
	html.body.p = renderTopic(p);
}

renderComap(Reducer<Topic>) -> Reducer<Html>;

Curator:

renderTopic(p : Topic) -> RAssigns {
	RAssigns(
		[
			table.tr[0] = RAssigns([
				td[0] = p.topic;
				rowspan = length(p.children());
				yalign = center;
			]),
			mapi(p.children(), \i, child -> {
				table.tr[i].td[1] = renderTopic(child);
			})
		]
	)
}

*/
