import ds/reducer;
import material/material;
import material/material2tropic;
import formats/dom/assign;
import formats/dom/render;

/*
This is the start of a general editor.

It is intended to be a generalization of comapping, prime, flowschema and other similar editors.

This is possible through the abstraction of RAssign. This allow any data structure
to be de-composed into individual "assignments" of "atomic" values. Similarly, the notion 
of a cursor or place in the document is captured by the notion of RLValues.

Run:

c:\flow9\> flowc1 sandbox/editor.flow html=editor.html

and then open c:\flow9\editor.html in your browser.

TODO:
- Debug why we get multiple B and C nodes
- "Replace" arraypush with explicit indexes into the arrays?
- Implement lvalues for arrays in formats/dom/assign.flow
- Figure out how to do layout using HTML. I.e. figure out a way to nest divs.
- Implement editing, and incremental updates
*/

REditor(
	// The document is represented as a bunch of assignments. This works for any data structure
	document : Behaviour<[RAssign<?>]>,
	// Where are the cursors?
	cursor : Behaviour<[RLValue]>,
	// What leading path are we focusing on?
	focus : Behaviour<RLValue>,
	// What elements are selected?
	selected : Behaviour<[RLValue]>,
	// What elements are collapsed?
	collapsed : Behaviour<[RLValue]>,
	// How to edit a given value: Convert it to IXmlNode for use in the DOM
	editValue : (e : RAssign<?>, cursor : bool, readonly : bool, selected : bool) -> RAssign<IXmlNode>,

	// TODO: Add clipboard, undo/redo
	// TODO: Make sure all actions are events
);

makeView(e : REditor<?>) -> Material {
	wh = make(WidthHeight(0.0, 0.0));

	keyListener = makeTKey(\ke -> {
		contains(["left", "right", "up", "down"], ke.utf)
		|| ke.shift || ke.ctrl || ke.alt
	});

	MInteractive([keyListener], 
		MConstruct([
				makeSubscribe(keyListener.pressed, \ke -> {
					if (ke.utf == "left") {
						// OK, move the cursor
					} else if (ke.utf == "right") {
						
					} else if (ke.utf == "up") {
						
					} else if (ke.utf == "down") {
						
					} else {
						
					}
				})
			],
			MInspect([IAvailable(wh)], 
				MHTMLStage(wh, \stage -> {
					// TODO: We could use some FRP array construct for the document to allow partial updates
					// instead of full updates
					us = fsubscribe(fselect3(e.document, e.cursor, e.selected, \assigns : [RAssign<?>], cursor, selected -> {
						// We run all the assignments
						iter(assigns,
							\a -> {
								xml = e.editValue(a, contains(cursor, a.lvalue), false, contains(selected, a.lvalue));
								htmlRAssign(stage, xml);
						});
						0;
					}), nop1);
					\ -> callList(us);
				})
			)
		)
	);
}

makeREditor(doc : [RAssign<?>], editFn : (e : RAssign<?>, cursor : bool, readonly : bool, selected : bool) -> RAssign<IXmlNode>) -> REditor {
	REditor(
		// The document
		make(doc),
		// The cursors
		make(if (doc != []) [doc[0].lvalue] else []),
		// Where the focus is
		make(RLeaf()),
		// Selection
		make([]),
		// What parts are collapsed
		make([]),
		// The function which will convert a node to HTML
		editFn
	);
}

jsonAssign2htmlAssign(l : RAssign<Json>, cursor : bool, readonly : bool, selected : bool) -> RAssign<IXmlNode> {
	RAssign(
		l.lvalue,
		viewJsonRAssignHtml(l, cursor, readonly, selected)
	)
}

// This is called for all leafs
viewJsonRAssignHtml(l : RAssign<Json>, cursor : bool, readonly : bool, selected : bool) -> IXmlNode {
	key = rlvalueKey(l.lvalue);

	text = (if (key != "") key + ": " else "")
		+ switch (l.value) {
		JsonObject(members): "Object";
		JsonArray(value): "Array";
		JsonNull(): "null";
		JsonBool(v): b2s(v);
		JsonDouble(v): d2s(v);
		JsonString(s): escapeHtml(s);
	};

	leftMargin = i2d(depthRLValue(l.lvalue)) * 8.0;

	if (true) {
		// TODO: Figure out a better way to construct this.
		IXmlElement("p", [
			IXmlAttribute("style", 
				"position: static; margin-left: " + d2s(leftMargin) + "em;" 
				+ (if (cursor) "color: blue;" else "")
				+ (if (selected) "border:1px solid black;" else "")
				+ (if (readonly) "" else "")
			) ], [IXmlText(text)], []);
	} else {
		// OK, these constructs for HTML are shit:
		dom0 = eP(text);
		css0 = dom0.style;
		css1 = CssValues(css0 with box = CssBox(css0.box with margin = CssMargin(css0.box.margin with left = CssLength(leftMargin, CssUnitEm()))));
		css = if (cursor) {
			CssValues(css1 with colors = CssColors(CssColorRgb(0, 180, 200)))
		} else css1;
		dom = EP(dom0 with style = css);
		dom2ixml(dom);
	}
}

//
// We want a bunch of helpers for rlvalues
//

depthRLValue(l : RLValue) -> int {
	switch (l) {
		RLeaf(): 0;
		RLObject(__, lvalue): 1 + depthRLValue(lvalue);
		RLArrayPush(lvalue): 1 + depthRLValue(lvalue);
		RLArrayIndex(index, lvalue): 1 + depthRLValue(lvalue);
	}
}

isRLValueParent(parent : RLValue, child : RLValue) -> bool {
	switch (parent) {
		RLeaf(): child != RLeaf();
		RLObject(pkey, plvalue): {
			switch (child) {
				RLObject(ckey, clvalue): {
					ckey == pkey && isRLValueParent(plvalue, clvalue);
				}
				default: false;
			}
		}
		RLArrayPush(plvalue): {
			switch (child) {
				RLArrayPush(clvalue): {
					isRLValueParent(plvalue, clvalue);
				}
				default: false;
			}
		}
		RLArrayIndex(pindex, plvalue): {
			switch (child) {
				RLArrayIndex(cindex, clvalue): {
					pindex == cindex && isRLValueParent(plvalue, clvalue);
				}
				default: false;
			}
		}
	}
}

parentRLValue(child : RLValue) -> RLValue {
	switch (child) {
		RLeaf(): child;
		RLObject(key, lvalue): {
			if (lvalue == RLeaf()) {
				lvalue;
			} else {
				RLObject(key, parentRLValue(lvalue))
			}
		}
		RLArrayPush(lvalue): {
			if (lvalue == RLeaf()) lvalue
			else RLArrayPush(parentRLValue(lvalue))
		}
		RLArrayIndex(index, lvalue): {
			if (lvalue == RLeaf()) lvalue
			else RLArrayIndex(index, parentRLValue(lvalue));
		}
	}
}

// What is the final key for this element?
rlvalueKey(l : RLValue) -> string {
	switch (l) {
		RLeaf(): "";
		RLObject(key, lvalue): {
			if (lvalue == RLeaf()) key
			else rlvalueKey(lvalue);
		}
		RLArrayPush(lvalue): rlvalueKey(lvalue);
		RLArrayIndex(index, lvalue): rlvalueKey(lvalue);
	}
}

//
// TODO: Next and previous rlvalue. What to do with objects?
//

main() {
	json1 = parseJsonSafe("
		{
			a: 0,
			b: [
				1,
				2,
				3
			],
			c: {
				d: true,
				e: null,
				f: {
					g: 5
				}
			}
		}
	");

	editor = makeREditor(rreduceJson(json1, rarray()), jsonAssign2htmlAssign);
	mrender(
		makeMaterialManager([]), true,
		makeView(editor)
	);
	{}
}


/*

From the JSON, we get this sequence of RAssign<IXmlNode>:

RAssign(RLObject("a", RLeaf()), IXmlElement("p", [], [IXmlText("0")], []))
RAssign(RLObject("b", RLArrayPush(RLeaf())), IXmlElement("p", [], [IXmlText("1")], []))
RAssign(RLObject("b", RLArrayPush(RLeaf())), IXmlElement("p", [], [IXmlText("2")], []))
RAssign(RLObject("b", RLArrayPush(RLeaf())), IXmlElement("p", [], [IXmlText("3")], []))
RAssign(RLObject("c", RLObject("d", RLeaf())), IXmlElement("p", [], [IXmlText("true")], []))
RAssign(RLObject("c", RLObject("e", RLeaf())), IXmlElement("p", [], [IXmlText("null")], []))

That should correspond to

   <div id=".a"><p>0</p></div>
   <div id=".b">
        <div id=".b.0"><p>1</p></div>
        <div id=".b.1"><p>2</p></div>
        <div id=".b.2"><p>3</p></div>
   </div>
   <div id=".c">
       <div id=".c.d"><p>true</p></div>
       <div id=".c.e"><p>null</p></div>
   </div>

I.e. an lvalue object with "id" becomes <div id=path.id>, and RLArrayPush becomes <div id=path.index>.
RLLeaf is just text. The goal is that each id is unique.

Right now, there is a bug so we do not get this structure correctly.

The point is that with this approach, we can imperatively update the DOM tree efficiently, 
and rely on HTML to do a lot of layout for us.

TODO:

See we can maybe provide some kind of nesting structure:

RAssigns(
	assignments : [RAssign]
)

renderComap(p : Topic) -> RAssigns {
	html.body.p = renderTopic(p);
}

renderComap(Reducer<Topic>) -> Reducer<Html>;

Curator:

renderTopic(p : Topic) -> RAssigns {
	RAssigns(
		[
			table.tr[0] = RAssigns([
				td[0] = p.topic;
				rowspan = length(p.children());
				yalign = center;
			]),
			mapi(p.children(), \i, child -> {
				table.tr[i].td[1] = renderTopic(child);
			})
		]
	)
}

*/
