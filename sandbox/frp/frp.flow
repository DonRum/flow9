import ds/dlist;

export {
	// This is roughly the same as Behavior<?>
	Frp1<?> ::= FrpConst1<?>, FrpValue1<?>;

	// This is roughly the same as Behavior<Pair<?, ??>>
	Frp2<?, ??> ::= FrpConst2<?, ??>, FrpValue2<?, ??>;

	fconst1(v : ?) -> FrpConst1<?>;
	fmake1(v : ?) -> FrpValue1<?>;
	fnext1(f : FrpValue1<?>, v : ?) -> void;
	fnextDistinct1(f : FrpValue1<?>, v : ?) -> void;
	fget1(f : Frp1<?>) -> ?;
	// Calls immediately
	fsubscribe1(f : Frp1<?>, fn : (?) -> void) -> () -> void;

	// Does not call immediately - s for silent
	fsubscribe1s(f : Frp1<?>, fn : (?) -> void) -> () -> void;

	// Add a disposer that will be cleaned up when we free
	faddDisposer1(v : FrpValue1<?>, disposer : () -> void) -> void;

	// This frees the behaviour and all disposers inside it
	ffree1(v : Frp1<?>) -> void;

	fconst2(v : ?, w : ??) -> FrpConst2<?, ??>;
	fmake2(v : ?, w : ??) -> FrpValue2<?, ??>;
	fnext2(f : FrpValue2<?, ??>, v : ?, w : ??) -> void;
	fnext2First(f : FrpValue2<?, ??>, v : ?) -> void;
	fnext2Second(f : FrpValue2<?, ??>, w : ??) -> void;
	fget2(f : Frp2<?, ??>) -> Pair<?, ??>;
	fget2First(f : Frp2<?, ??>) -> ?;
	fget2Second(f : Frp2<?, ??>) -> ??;

	// Calls immediately
	fsubscribe2(f : Frp2<?, ??>, fn : (?, ??) -> void) -> () -> void;
	// Does not call immediately - s for silent
	fsubscribe2s(f : Frp2<?, ??>, fn : (?, ??) -> void) -> () -> void;

	faddDisposer2(f : FrpValue2<?, ??>, disposer : () -> void) -> void;
	ffree2(v : Frp2<?, ??>) -> void;
}

FrpConst1(value : ?);
FrpValue1(value : ref ?, subscribers : DList<(?) -> void>, disposers : ref List<() -> void>);

FrpConst2(value1 : ?, value2 : ??);
FrpValue2(value1 : ref ?, value2 : ref ??, subscribers : DList<(?, ??) -> void>, disposers : ref List<() -> void>);


fconst1(v : ?) -> FrpConst1<?> {
	FrpConst1(v);
}

fmake1(v : ?) -> FrpValue1<?> {
	FrpValue1(ref v, makeDList(), ref makeList());
}

fnext1(frp : FrpValue1<?>, value : ?) -> void {
	r = frp.value;
	r := value;
	applyRefDList(frp.subscribers, r);
}

fnextDistinct1(frp : FrpValue1<?>, value : ?) -> void {
	r = frp.value;
	if (^r != value) {
		r := value;
		applyRefDList(frp.subscribers, r);
	}
}


fget1(f : Frp1<?>) -> ? {
	switch (f) {
		FrpConst1(v): v;
		FrpValue1(r, __, __): ^r;
	}
}

fsubscribe1(f : Frp1<?>, fn : (?) -> void) -> () -> void {
	switch (f) {
		FrpConst1(v): {
			fn(v);
			\ -> {};
		}
		FrpValue1(r, sub, __): {
			fn(^r);
			fsubscribe1s(f, fn);
		}
	}
}

fsubscribe1s(f : Frp1<?>, fn : (?) -> void) -> () -> void {
	switch (f) {
		FrpConst1(v): \ -> {};
		FrpValue1(r, subscribers, __): {
			n = pushDList(subscribers, fn);
			\ -> {
				removeDList(subscribers, n);
			}
		}
	}
}

faddDisposer1(f : FrpValue1<?>, disposer : () -> void) -> void {
	f.disposers := Cons(disposer, ^(f.disposers));
}

ffree1(f : Frp1<?>) -> void {
	switch (f) {
		FrpConst1(v): {}
		FrpValue1(r, subs, disposers): {
			callList(^disposers);
			subs.first ::= DEnd();
			subs.last ::= DEnd();
			disposers := makeList();
		}
	}
}


// 2-values FRP values

fconst2(v : ?, w : ??) -> FrpConst2<?, ??> {
	FrpConst2(v, w);
}

fmake2(v : ?, w : ??) -> FrpValue2<?, ??> {
	FrpValue2(ref v, ref w, makeDList(), ref makeList());
}


fnext2(frp : FrpValue2<?, ??>, value1 : ?, value2 : ??) -> void {
	r1 = frp.value1;
	r2 = frp.value2;
	r1 := value1;
	r2 := value2;

	apply2RefDList(frp.subscribers, r1, r2);
}

fnext2First(frp : FrpValue2<?, ??>, v : ?) -> void {
	r1 = frp.value1;
	r1 := v;
	apply2RefDList(frp.subscribers, r1, frp.value2);
}

fnext2Second(frp : FrpValue2<?, ??>, w : ??) -> void {
	r2 = frp.value2;
	r2 := w;
	apply2RefDList(frp.subscribers, frp.value1, r2);
}


fget2(f : Frp2<?, ??>) -> Pair<?, ??> {
	switch (f) {
		FrpConst2(v, w): Pair(v, w);
		FrpValue2(v, w, __, __): Pair(^v, ^w);
	}
}

fget2First(f : Frp2<?, ??>) -> ? {
	switch (f) {
		FrpConst2(v, w): v;
		FrpValue2(v, w, __, __): ^v;
	}
}

fget2Second(f : Frp2<?, ??>) -> ?? {
	switch (f) {
		FrpConst2(v, w): w;
		FrpValue2(v, w, __, __): ^w;
	}
}


fsubscribe2(f : Frp2<?, ??>, fn : (?, ??) -> void) -> () -> void {
	switch (f) {
		FrpConst2(v, w): {
			fn(v, w);
			\ -> {};
		}
		FrpValue2(v, w, sub, __): {
			fn(^v, ^w);
			fsubscribe2s(f, fn);
		}
	}
}

fsubscribe2s(f : Frp2<?, ??>, fn : (?, ??) -> void) -> () -> void {
	switch (f) {
		FrpConst2(v, w): \ -> {};
		FrpValue2(v, w, subscribers, __): {
			n = pushDList(subscribers, fn);
			\ -> {
				removeDList(subscribers, n);
			}
		}
	}
}

faddDisposer2(f : FrpValue2<?, ??>, disposer : () -> void) -> void {
	f.disposers := Cons(disposer, ^(f.disposers));
}

ffree2(f : Frp2<?, ??>) -> void {
	switch (f) {
		FrpConst2(v, w): {}
		FrpValue2(v, w, subs, disposers): {
			callList(^disposers);
			subs.first ::= DEnd();
			subs.last ::= DEnd();
			disposers := makeList();
		}
	}
}




apply2RefDList(list : DList<(?, ??) -> void>, v : ref ?, w : ref ??) -> void {
	apply2RefDNode(list.first, v, w);
}

apply2RefDNode(node : DNode<(?, ??) -> void>, v : ref ?, w : ref ??) -> void {
	switch (node : DNode) {
		DEnd(): {}
		DLink(fn, before, after, attached): {
			// node could be removed from the list in previous call, do nothing in this case.
			if (attached) {
				// Notice that we deference the value by purpose in each iteration, because a previous
				// iteration might have changed the value when used in behaviours.
				fn(^v, ^w);
				// in case if fn(^r) changed the list by removing inself, we have to use saved 'after' node
				nextNode : DNode<(?, ??) -> void> =
					if (node.after == DEnd() && node.before == DEnd() && after != DEnd()) {
						after;
					} else {
						node.after;
					}
				apply2RefDNode(nextNode, v, w)
			}
		}
	}
}
