import ds/dlist;

export {
	Frp1<?> ::= FrpConst1<?>, FrpValue1<?>;
	Frp2<?, ??> ::= FrpConst2<?, ??>, FrpValue2<?, ??>;

	fconst1(v : ?) -> FrpConst1<?>;
	fmake1(v : ?) -> FrpValue1<?>;
	fnext1(f : FrpValue1<?>, v : ?) -> void;
	fget1(f : Frp1<?>) -> ?;
	// Calls immediately
	fsubscribe1(f : Frp1<?>, fn : (?) -> void) -> () -> void;
	// Does not call immediately - s for silent
	fsubscribe1s(f : Frp1<?>, fn : (?) -> void) -> () -> void;

	fconst2(v : ?, w : ??) -> FrpConst2<?, ??>;
	fmake2(v : ?, w : ??) -> FrpValue2<?, ??>;
	fnext2(f : FrpValue2<?, ??>, v : ?, w : ??) -> void;
	fnext2First(f : FrpValue2<?, ??>, v : ?) -> void;
	fnext2Second(f : FrpValue2<?, ??>, w : ??) -> void;
	fget2(f : Frp2<?, ??>) -> Pair<?, ??>;
	fget2First(f : Frp2<?, ??>) -> ?;
	fget2Second(f : Frp2<?, ??>) -> ??;

	fsubscribe2(f : Frp2<?, ??>, fn : (?, ??) -> void) -> () -> void;
	// Does not call immediately - s for silent
	fsubscribe2s(f : Frp2<?, ??>, fn : (?, ??) -> void) -> () -> void;
}

FrpConst1(value : ?);
FrpValue1(value : ref ?, subscribers : DList<(?) -> void>);

FrpConst2(value1 : ?, value2 : ??);
FrpValue2(value1 : ref ?, value2 : ref ??, subscribers : DList<(?, ??) -> void>);


fconst1(v : ?) -> FrpConst1<?> {
	FrpConst1(v);
}

fmake1(v : ?) -> FrpValue1<?> {
	FrpValue1(ref v, makeDList());
}

fnext1(frp : FrpValue1<?>, value : ?) -> void {
	r = frp.value;
	r := value;
	applyRefDList(frp.subscribers, r);
}

fget1(f : Frp1<?>) -> ? {
	switch (f) {
		FrpConst1(v): v;
		FrpValue1(r, __): ^r;
	}
}

fsubscribe1(f : Frp1<?>, fn : (?) -> void) -> () -> void {
	switch (f) {
		FrpConst1(v): {
			fn(v);
			\ -> {};
		}
		FrpValue1(r, sub): {
			fn(^r);
			fsubscribe1s(f, fn);
		}
	}
}

fsubscribe1s(f : Frp1<?>, fn : (?) -> void) -> () -> void {
	switch (f) {
		FrpConst1(v): \ -> {};
		FrpValue1(r, subscribers): {
			n = pushDList(subscribers, fn);
			\ -> {
				removeDList(subscribers, n);
			}
		}
	}
}


fconst2(v : ?, w : ??) -> FrpConst2<?, ??> {
	FrpConst2(v, w);
}

fmake2(v : ?, w : ??) -> FrpValue2<?, ??> {
	FrpValue2(ref v, ref w, makeDList());
}


fnext2(frp : FrpValue2<?, ??>, value1 : ?, value2 : ??) -> void {
	r1 = frp.value1;
	r2 = frp.value2;
	r1 := value1;
	r2 := value2;

	apply2RefDList(frp.subscribers, r1, r2);
}

fnext2First(frp : FrpValue2<?, ??>, v : ?) -> void {
	r1 = frp.value1;
	r1 := v;
	apply2RefDList(frp.subscribers, r1, frp.value2);
}

fnext2Second(frp : FrpValue2<?, ??>, w : ??) -> void {
	r2 = frp.value2;
	r2 := w;
	apply2RefDList(frp.subscribers, frp.value1, r2);
}


fget2(f : Frp2<?, ??>) -> Pair<?, ??> {
	switch (f) {
		FrpConst2(v, w): Pair(v, w);
		FrpValue2(v, w, __): Pair(^v, ^w);
	}
}

fget2First(f : Frp2<?, ??>) -> ? {
	switch (f) {
		FrpConst2(v, w): v;
		FrpValue2(v, w, __): ^v;
	}
}

fget2Second(f : Frp2<?, ??>) -> ?? {
	switch (f) {
		FrpConst2(v, w): w;
		FrpValue2(v, w, __): ^w;
	}
}


fsubscribe2(f : Frp2<?, ??>, fn : (?, ??) -> void) -> () -> void {
	switch (f) {
		FrpConst2(v, w): {
			fn(v, w);
			\ -> {};
		}
		FrpValue2(v, w, sub): {
			fn(^v, ^w);
			fsubscribe2s(f, fn);
		}
	}
}

fsubscribe2s(f : Frp2<?, ??>, fn : (?, ??) -> void) -> () -> void {
	switch (f) {
		FrpConst2(v, w): \ -> {};
		FrpValue2(v, w, subscribers): {
			n = pushDList(subscribers, fn);
			\ -> {
				removeDList(subscribers, n);
			}
		}
	}
}




apply2RefDList(list : DList<(?, ??) -> void>, v : ref ?, w : ref ??) -> void {
	apply2RefDNode(list.first, v, w);
}

apply2RefDNode(node : DNode<(?, ??) -> void>, v : ref ?, w : ref ??) -> void {
	switch (node : DNode) {
		DEnd(): {}
		DLink(fn, before, after, attached): {
			// node could be removed from the list in previous call, do nothing in this case.
			if (attached) {
				// Notice that we deference the value by purpose in each iteration, because a previous
				// iteration might have changed the value when used in behaviours.
				fn(^v, ^w);
				// in case if fn(^r) changed the list by removing inself, we have to use saved 'after' node
				nextNode : DNode<(?, ??) -> void> =
					if (node.after == DEnd() && node.before == DEnd() && after != DEnd()) {
						after;
					} else {
						node.after;
					}
				apply2RefDNode(nextNode, v, w)
			}
		}
	}
}
