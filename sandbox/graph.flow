import forcelayout;

import ds/simplegraph;
import ui/slider;

Data(id : int, self : int, score: int);

main() {
	datapoints = [
		Data(3715, 1, 100),
		Data(2200, 1, 80),
		Data(2245, 1, 75),
		Data(2095, 1, 67),
		Data(19007, 2, 0),
		Data(19008, 2, 0),
		Data(19004, 4, 100),
		Data(2200, 1,20),
		Data(2245, 2, 75),
		Data(2095, 2, 50),
		Data(19007, 1, 100),
		Data(19005, 4, 0 ),
		Data(19008, 1, 100),
		Data(2200, 3,  0 ),
		Data(2245, 1, 100),
		Data(2458, 2, 0),
		Data(3468, 2, 0),
		Data(9458, 2, 0),
		Data(19005, 4, 0 ),
		Data(24556, 2, 0),
		Data(19008, 2, 0),
		Data(3428, 2, 0),
	];

	graph0 = makeSimpleGraph();

	graph = foldi(datapoints, graph0, \i, acc, data -> {
		if (i == 0) {
			addSimpleNode(acc, data.id);
		} else {
			prev = datapoints[i - 1];
			addSimpleEdge(acc, prev.id, data.id, data.score, 1)
		}
	});

	layout = graph2layout(getEGNodes(graph.graph), getEGEdges(graph.graph), [0], [], WidthHeight(600.0, 1024.0));

	gui = layout2form(layout);

	render(gui);
}

//

makeForceLayout() -> ForceLayout {
	ForceLayout(
		WidthHeight(600.0, 600.0), // size
		ref 0.1, // alpha
		0.9, // friction
		0.03, // gravity
		0.8, // theta
		[], // nodes
		[], // edges
	)	
}

addNodeIdToLayout(layout : ForceLayout, nodeid : int, fixcoordinate : bool) -> ForceLayout {
	fnode = if (layout.nodes == []) {
		x = layout.size.width / 2.0;
		y = 50.0;
		ForceNode(make(x), make(y), ref x, ref y, 10.0, 1000.0, true, true, nodeid);
	} else {
		// Layout our nodes in a snake
		lastNode = lastElement(layout.nodes, ForceNode(make(0.0), make(0.0), ref 0.0, ref 0.0, 0.0, 0.0, false, false, -1));
		angle = ((i2d(length(layout.nodes)) / 16.0) % 1.0) * 2.0 * PI;
		dx = cos(angle) * 75.0;
		dy = abs(sin(angle)) * 50.0;
		x = getValue(lastNode.x) + dx;
		y = getValue(lastNode.y) + dy;
		ForceNode(make(x), make(y), ref x, ref y, 10.0, 1000.0, false, false, nodeid);
	}

	ForceLayout(
		layout with
		nodes = arrayPush(layout.nodes, fnode)
	);
}

addEdgeToLayout(layout : ForceLayout, fromid : int, toid : int) -> ForceLayout {
	fromIndex = findiDef(layout.nodes, \n -> n.id == fromid, -1);
	toIndex = findiDef(layout.nodes, \n -> n.id == toid, -1);

	edge = ForceEdge(fromIndex, toIndex, 1.0, 50.0, 50.0);

	ForceLayout(
		layout with
		edges = arrayPush(layout.edges, edge)
	);
}


graph2layout(nodes : [GNode], edges : [GEdge], sources : [int], sinks : [int], size : WidthHeight) -> ForceLayout {
	layout0 = foldi(nodes, makeForceLayout(), \i, acc, node -> {
		addNodeIdToLayout(acc, node.id, i == 0)
	});
	fold(edges, layout0, \acc, edge -> {
		addEdgeToLayout(acc, edge.from, edge.to);
	})
}

layout2form(layout : ForceLayout) -> Form {
	generate(0, 100, \i -> forceTick(layout));
	formDiGraphLayout2(layout, \nodeid : int -> {
		color = if (random() < 0.5) green else if (random() < 0.5) yellow else red;
		size = random() * 20.0 + 10.0;
		Circle(0.0, 0.0, size, [Fill(color)])
	});
}

formDiGraphLayout2(layout : ForceLayout, nodeFn : (nodeid : int) -> Form) -> Form {
	nodes : [Form] =
		map(layout.nodes, \node : ForceNode -> {
			nodeForm = nodeFn(node.id);
			Slider(
				node.x, 
				node.y, 
				const(layout.size.width), 
				const(layout.size.height), 
				nodeForm, 
				[]
			);
		});

	edgesForms = 
		mapi(layout.edges, \i, edge -> {
			sourceNode = layout.nodes[edge.source];
			targetNode = layout.nodes[edge.target];

			Select2(
				select2(sourceNode.x, sourceNode.y, \x, y -> Point(x, y)), 
				select2(targetNode.x, targetNode.y, \x, y -> Point(x, y)), 
				drawGraphArrow
			)
		});

	Group(concat(edgesForms, nodes))
}

drawGraphArrow(p2 : Point, p1 : Point) -> Form {
	dx = p2.x - p1.x;
	dy = p2.y - p1.y;

	dist = sqrt(dx * dx + dy * dy);

	ux = dx / dist;
	uy = dy / dist;

	middle = dist / 2.0;

	side = 5.0;

	back1 = middle - 4.0;
	back2 = middle + 4.0;

	Group([
		Graphics([
			MoveTo(p1.x, p1.y), 
			LineTo(p2.x, p2.y),
		], [Stroke(0x888888), StrokeWidth(1.0)]),
		Graphics([
			MoveTo(p2.x - back1 * ux, p2.y - back1 * uy),
			LineTo(p2.x - side * uy - back1 * ux, p2.y + side * ux - back1 * uy),
			LineTo(p2.x - back2 * ux, p2.y - back2 * uy),
			LineTo(p2.x + side * uy - back1 * ux, p2.y - side * ux - back1 * uy),
			LineTo(p2.x - back1 * ux, p2.y - back1 * uy),
		], [Fill(0x888888)])
	])	
}