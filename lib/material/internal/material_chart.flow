import material/internal/material_line;
import material/internal/material_ellipsis;
import material/internal/material_button;
import tropic/selecttarray;

export {
	MChart2T(manager : MaterialManager, parent : MFocusGroup, m : MChart, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
	stepLength(len : double, isDate : bool) -> double;
	getChartColor(colors : [MColor], i : int) -> MColor;
}

MChartState(
	manager : MaterialManager,
	parent : MFocusGroup,

	wh : DynamicBehaviour<WidthHeight>,
	chartWH : DynamicBehaviour<WidthHeight>,
	positionScale : DynamicBehaviour<PositionScale>,

	title : string,
	subtitle : string,
	textColor : MColor,
	escapeHTML : bool,
	inCard : bool,
	isCurve : bool,
	showLegend : bool,
	hidePoints : bool,
	hideHover : bool,
	valuesPostfix : string,
	tooltipValuesPostfix : string,
	center : Pair<Transform<double>, Transform<double>>,
	centerPoint : Pair<Transform<Maybe<double>>, Transform<Maybe<double>>>,
	valuesLabels : Maybe<bool>,
	lineLabels : bool,

	verticalLines : Transform<bool>,
	horizontalLines : Transform<bool>,

	xAxisIsDate : bool,
	xAxisVertical : bool,
	xAxisValuesVisible : Transform<bool>,
	xAxisValuesOnLines : Transform<bool>,
	xAxisCaption : Transform<string>,
	xAxisValues : Transform<[Pair<double, string>]>,
	xAxisValuesStyle : [[MTextStyle]],
	xAxisValuesTranslate : Transform<Point>,

	yAxisValuesVisible : Transform<bool>,
	yAxisValuesOnLines : Transform<bool>,
	yAxisCaption : Transform<string>,
	yAxisValues : Transform<[Pair<double, string>]>,
	yAxisValuesTranslate : Transform<Point>,

	columns : Transform<[MChartColumnState]>
);

makeMChartState(manager : MaterialManager, parent : MFocusGroup, data : Transform<MChartData>, style : [MChartStyle]) -> MChartState {
	wh = makeWH();
	chartWH = makeWH();
	positionScale = make(zeroPositionScale);

	title = extractStruct(style, MChartTitle("")).title;
	subtitle = extractStruct(style, MChartSubtitle("")).subtitle;
	textColor = contrastingMColor(parent);
	escapeHTML = extractStruct(style, EscapeHTML(true)).escape;
	inCard = contains(style, MInCard());
	isCurve = contains(style, MChartCurve());
	showLegend = !contains(style, MHideLegend());
	hidePoints = contains(style, MHidePoints());
	hideHover = contains(style, MHideValueHover());
	valuesPostfix = extractStruct(style, MValuesPostfix("")).postfix;
	tooltipValuesPostfix = extractStruct(style, MTooltipValuesPostfix(valuesPostfix)).postfix;
	type = const(extractStruct(style, MChartType([])).chartType);
	center =
		fold(extractStructMany(style, MAxesCenter(0., 0.)), MAxesCenter(0., 0.), \acc, c -> MAxesCenter(acc.x + c.x, acc.y + c.y))
		|> (\center -> Pair(const(center.x), const(center.y)));
	valuesLabels = maybeMap(tryExtractStruct(style, MValuesLabels(false)), \vl -> vl.withPostfix);
	lineLabels = contains(style, MLineLabels());
	barWidth = extractStruct(style, MBarWidth(4., 1.));
	onClick = extractStruct(style, MOnChartClick([])).click;

	linesStyles = extractStruct(style, MChartLinesStyle([])).style;
	linesColors =
		concat(
			extractStruct(style, MLinesColors([])).colors,
			mapi(linesStyles, \i, st -> extractStruct(st, getChartColor(standartChartColors, i)))
		);
	linesVisible = map(extractStruct(style, MChartVisible([])).visible, \v -> make(v));

	verticalLines = const(contains(style, MShowVerticalLines()));
	horizontalLines = const(contains(style, MShowHorizontalLines()));

	xAxisIsDate = contains(style, MXAxisIsDate());
	xAxisVertical = contains(style, MXAxisVertical());
	xAxisValuesVisible = const(!contains(style, MHideXAxisValues()));
	xAxisValuesOnLines = const(contains(style, MXAxisValuesOnLines()));
	xAxisCaption =
		eitherFn(
			tryExtractStruct(style, MXAxisCaption("")),
			\c -> const(c.caption),
			\ -> fselect(data, FLift(\d -> elementAt(d.columns, 0, "")))
		);

	xAxisValuesStyle = extractStruct(style, MXAxisValuesStyle([])).style;
	yAxisValuesVisible = const(!contains(style, MHideYAxisValues()));
	yAxisValuesOnLines = const(contains(style, MYAxisValuesOnLines()));
	yAxisCaption = const(extractStruct(style, MYAxisCaption("")).caption);

	chartData =
		fselect(data, FLift(\d -> {
			maxDataLength = either(maxA(map(d.data, length)), 0);

			MChartData(
				generate(0, max(maxDataLength, length(d.columns)), \j -> elementAt(d.columns, j, "")),
				d.rows,
				generate(0, max(length(d.data), length(d.rows)), \i ->
					generate(0, max(maxDataLength, length(d.columns)), \j ->
						if (length(d.data) > i && length(d.data[i]) > j) {
							if (xAxisIsDate && j == 0) date2stamp(stamp2date(d.data[i][j])) else d.data[i][j];
						} else {
							if (j == 0) i2d(i + 1) else 0.0;
						}
					)
				)
			)
		}));

	dataV = fgetValue(chartData).data;

	xMin = either(minA(map(dataV, \r -> r[0])), 0.0);
	xMax = either(maxA(map(dataV, \r -> r[0])), 0.0);

	yMin = either(minA(map(dataV, \r -> either(minA(map(tail(r), \ry -> if (ry != -doubleMax) ry else doubleMax)), 0.0))), 0.0);
	yMax = either(maxA(map(dataV, \r -> either(maxA(tail(r)), 1.0))), 0.0);

	xAxisGridStep = const(extractStruct(style, MXAxisGridStep(1.0)).step);
	yAxisGridStep = const(extractStruct(style, MYAxisGridStep(stepLength(yMax - yMin, false))).step);

	xAxisScope =
		extractStruct(
			style,
			MXAxisScope(
				if (xMin < 0.0)
					dceil(-xMin / fgetValue(xAxisGridStep) + 1.0) * -fgetValue(xAxisGridStep)
				else
					dfloor(xMin / fgetValue(xAxisGridStep) - 1.0) * fgetValue(xAxisGridStep),
				dceil(xMax / fgetValue(xAxisGridStep) + 1.0) * fgetValue(xAxisGridStep)
			)
		)
		|> (\xAxisScope -> Pair(make(xAxisScope.min), make(xAxisScope.max)));
	yAxisScope =
		extractStruct(
			style,
			MYAxisScope(
				if (yMin < 0.0)
					dceil(-yMin / fgetValue(yAxisGridStep) + b2d(isCurve) / 4.0) * -fgetValue(yAxisGridStep)
				else
					dfloor(yMin / fgetValue(yAxisGridStep) - b2d(isCurve) / 4.0) * fgetValue(yAxisGridStep),
				dceil(yMax / fgetValue(yAxisGridStep) + b2d(isCurve) / 4.0) * fgetValue(yAxisGridStep)
			)
		)
		|> (\yAxisScope -> Pair(make(yAxisScope.min), make(yAxisScope.max)));

	centerPoint =
		Pair(
			fselect5(xAxisScope.first, xAxisScope.second, center.first, fwidth(chartWH), xAxisGridStep, \xmin, xmax, xcenter, wd, step ->
				if (xcenter >= xmin + step && xcenter <= xmax - step)
					Some((xcenter - xmin) * wd / (xmax - xmin))
				else
					None()
			),
			fselect5(yAxisScope.first, yAxisScope.second, center.second, fheight(chartWH), yAxisGridStep, \ymin, ymax, ycenter, hgt, step ->
				if (ycenter >= ymin + step && ycenter <= ymax - step)
					Some((ymax - ycenter) * hgt / (ymax - ymin))
				else
					None()
			)
		);

	xAxisValues =
		fselect5(fwidth(chartWH), xAxisScope.first, xAxisScope.second, xAxisGridStep, chartData, \wd, xmin, xmax, step, d ->
			mapi(
				generateWhile2(xmin, \i -> i <= xmax, \i -> i + step, idfn),
				\i, v ->
					Pair(
						(v - xmin) * wd / (xmax - xmin),
						if (i > 0 && length(d.rows) > i - 1)
							d.rows[i - 1]
						else if (xAxisIsDate)
							getDateString(stamp2date(v), false, false, false)
						else
							d2st(v, 2)
					)
			)
		);
	yAxisValues =
		fselect4(fheight(chartWH), yAxisScope.first, yAxisScope.second, yAxisGridStep, \hgt, ymin, ymax, step ->
			map(
				generateWhile2(ymin, \i -> i <= ymax, \i -> i + step, idfn),
				\v ->
					Pair(
						(ymax - v) * hgt / (ymax - ymin),
						d2st(v, 2)
					)
			)
		);

	xAxisValuesTranslate = extractStruct(style, MXAxisValuesTranslate(const(Point(0.0, 0.0)))).point;
	yAxisValuesTranslate = extractStruct(style, MYAxisValuesTranslate(const(Point(0.0, 0.0)))).point;

	columns =
		makeMChartColumnStateStates(
			chartData,
			type,
			chartWH,
			xAxisScope,
			yAxisScope,
			linesStyles,
			linesColors,
			linesVisible,
			onClick,
			barWidth,
			isCurve,
			xAxisIsDate,
			lineLabels,
			tooltipValuesPostfix
		);

	MChartState(
		manager,
		parent,

		wh,
		chartWH,
		positionScale,

		title,
		subtitle,
		textColor,
		escapeHTML,
		inCard,
		isCurve,
		showLegend,
		hidePoints,
		hideHover,
		valuesPostfix,
		tooltipValuesPostfix,
		center,
		centerPoint,
		valuesLabels,
		lineLabels,

		verticalLines,
		horizontalLines,

		xAxisIsDate,
		xAxisVertical,
		xAxisValuesVisible,
		fand(
			xAxisValuesOnLines,
			fIsSome(centerPoint.first)
		),
		xAxisCaption,
		xAxisValues,
		xAxisValuesStyle,
		xAxisValuesTranslate,

		yAxisValuesVisible,
		fand(
			yAxisValuesOnLines,
			fIsSome(centerPoint.second)
		),
		yAxisCaption,
		yAxisValues,
		yAxisValuesTranslate,

		columns
	);
}

MChartColumnState ::= MBarChartColumnState, MLineChartColumnState;

MBarChartColumnState(
	title : string,
	color : MColor,
	barWidth : MBarWidth,
	visible : DynamicBehaviour<bool>,
	hover : DynamicBehaviour<bool>,
	position : Transform<Point>,
	points : [MChartPoint],
	style : [TGraphicsStyle]
);

MLineChartColumnState(
	title : string,
	color : MColor,
	visible : DynamicBehaviour<bool>,
	hover : DynamicBehaviour<bool>,
	position : Transform<Point>,
	points : [MChartPoint],
	lineType : MMLineType,
	lineStyle : [TGraphicsStyle],
	hidePoints : bool,
	pointRadius : double,
	pointStyle : [TGraphicsStyle]
);

emptyMChartColumnState = MBarChartColumnState("", MWhite(), MBarWidth(0.0, 0.0), make(false), make(false), const(zeroPoint), [], []);

MChartPoint(
	id : int,
	title : string,
	value : Point,
	position : Transform<Point>,
	graphicsData : Transform<[StaticGraphicOp]>,
	hover : DynamicBehaviour<bool>,
	down : DynamicBehaviour<bool>,
	hoverData : Transform<[MChartHoverData]>,
	pointLabel : Maybe<Pair<string, [TParagraphStyle]>>,
	pointMarker : Maybe<Material>,
	onClick : Maybe<() -> void>
);

MChartHoverData(
	id : int,
	title : string,
	value : string,
	color : MColor
);

makeMChartColumnStateStates(
	data : Transform<MChartData>,
	type : Transform<[MMChartType]>,
	chartWH : Transform<WidthHeight>,
	xAxisScope : Pair<DynamicBehaviour<double>, DynamicBehaviour<double>>,
	yAxisScope : Pair<DynamicBehaviour<double>, DynamicBehaviour<double>>,
	linesStyles : [[MLineStyle]],
	linesColors : [MColor],
	linesVisible : [DynamicBehaviour<bool>],
	onClick : [(int) -> void],
	barWidth : MBarWidth,
	isCurve : bool,
	xAxisIsDate : bool,
	lineLabels : bool,
	tooltipValuesPostfix : string,
) -> Transform<[MChartColumnState]> {
	fselect2(data, type, FLift2(\d, t -> {
		barCount = countA(t, eq(MBarChart())) - 1;

		generate(1, length(d.data[0]), \i -> {
			title = d.columns[i];
			barChart = elementAt(t, i - 1, MLineChart()) == MBarChart();
			filteredData = filtermapi(d.data, \j, r -> if (r[i] != -doubleMax) Some(Pair(j, Point(r[0], r[i]))) else None());
			color = getChartColor(linesColors, i - 1);
			lineStyle = if (length(linesStyles) > 0) linesStyles[(i - 1) % length(linesStyles)] else [];
			opacity = extractStruct(lineStyle, FillOpacity(1.0)).opacity;
			pointLabelM = tryExtractStruct(lineStyle, MPointLabel(\__ -> ""));
			pointMarkerM = tryExtractStruct(lineStyle, MPointMarker(\__, __ -> TEmpty()));
			pointLabelStyle = extractStruct(lineStyle, MPointLabelStyle([MFill(color)])).style;

			controlPoints =
				if (!barChart && isCurve) {
					getCurveControlPoints(map(filteredData, \fd -> fd.second));
				} else {
					Pair([], []);
				};

			points =
				mapi(filteredData, \j, dd -> {
					id = dd.first;
					value = dd.second;
					point =
						fselect5(
							chartWH, xAxisScope.first, xAxisScope.second, yAxisScope.first, yAxisScope.second,
							\wh, xmin, xmax, ymin, ymax ->
								Point(
									(value.x - xmin) * wh.width / (xmax - xmin),
									(ymax - value.y) * wh.height / (ymax - ymin)
								)
						);
					pointLabel =
						maybeMap(
							pointLabelM,
							\pointLabel ->
								Pair(pointLabel.getLabel(value.y), pointLabelStyle)
						)
						|> (\pointLabel ->
							if (lineLabels && j == length(filteredData) - 1)
								eitherFn(
									pointLabel,
									\pl -> Some(Pair(pl.first + " " + title, pl.second)),
									\ -> Some(Pair(title, pointLabelStyle))
								)
							else
								pointLabel
						);
					pointMarker =
						maybeMap(
							pointMarkerM,
							\pointMarker -> pointMarker.getMarker(i, value.y)
						);

					MChartPoint(
						id,
						if (length(d.rows) > id)
							d.rows[id]
						else if (xAxisIsDate)
							getDateString(stamp2date(value.x), false, false, false)
						else
							d2st(value.x, 2),
						value,
						point,
						fsubselect(point, FLift(\p -> {
							if (barChart) {
								fselect(chartWH, FLift(\wh ->
									rectangle(p.x - barWidth.width / 2., p.y, barWidth.width, wh.height - p.y)
								))
							} else if (j == 0) {
								const([MoveTo(p.x, p.y), LineTo(p.x, p.y)])
							} else if (isCurve) {
								fselect5(
									chartWH, xAxisScope.first, xAxisScope.second, yAxisScope.first, yAxisScope.second,
									\wh, xmin, xmax, ymin, ymax -> {
										xc = (controlPoints.first[j - 1].x + (controlPoints.second[j - 1].x - controlPoints.first[j - 1].x) * 3.0 / 2.0 - xmin)
											* wh.width / (xmax - xmin);
										yc = (ymax - (controlPoints.first[j - 1].y + (controlPoints.second[j - 1].y - controlPoints.first[j - 1].y) * 3.0 / 2.0))
											* wh.height / (ymax - ymin);

										[CubicBezierTo(p.x, p.y, xc, yc)];
									}
								)
							} else {
								const([LineTo(p.x, p.y)])
							}
						})),
						make(false),
						make(false),
						fsubselect(point, FLift(\p -> {
							if (barChart) {
								const([MChartHoverData(i - 1, title, d2st(value.y, 2) + tooltipValuesPostfix, getChartColor(linesColors, i - 1))])
							} else {
								fselect3(chartWH, yAxisScope.first, yAxisScope.second, \wh, ymin, ymax ->
									map(getPointNeighbours(d.data[id], (ymax - ymin) / wh.height * 4.0, i, []), \pn ->
										MChartHoverData(pn - 1, d.columns[pn], d2st(d.data[id][pn], 2) + tooltipValuesPostfix, getChartColor(linesColors, pn - 1))
									)
								)
							}
						})),
						pointLabel,
						pointMarker,
						if (length(onClick) > i - 1) {
							Some(\ -> onClick[i - 1](id))
						} else {
							None();
						}
					)
				});

			if (barChart) {
				MBarChartColumnState(
					title,
					color,
					barWidth,
					elementAt(linesVisible, i - 1, make(true)),
					make(false),
					const(
						Point(
							(i2d(countA(subrange(t, 0, i - 1), \ct -> ct == MBarChart())) - i2d(barCount) / 2.) * (barWidth.width + barWidth.gapWidth),
							0.0
						)
					),
					points,
					[MFill(color), FillOpacity(opacity), StrokeOpacity(0.)]
				)
			} else {
				lineWidth = extractStruct(lineStyle, MWidth(2.0)).width;
				lineType = extractStruct(lineStyle, MLineType(MLineSolid())).type;

				MLineChartColumnState(
					title,
					color,
					elementAt(linesVisible, i - 1, make(true)),
					make(false),
					const(zeroPoint),
					points,
					lineType,
					[MStroke(color), StrokeOpacity(opacity), StrokeWidth(lineWidth)],
					contains(lineStyle, MHidePoints()),
					lineWidth,
					[MFill(color), FillOpacity(opacity)]
				);
			}
		})
	}));
}

MChart2T(manager : MaterialManager, parent : MFocusGroup, m : MChart, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	state = makeMChartState(manager, parent, const(m.data), m.style);

	TIfLazy(fgreateri(flength(state.columns), const(0)), \hd ->
		if (hd)
			drawMChart(state, m.style, m2t)
		else
			m2t(extractStruct(m.style, MEmptyMessage(MText(_("No Data"), [MTitle()]))).message, parent)
			|> TCenter
	)
	|> (\f -> TInspect([IAvailable(state.wh)], f))
	|> (\f -> TLines2(drawMChartTitle(state, m2t), f))
	|> (\f -> TBorder(8.0, 16.0, 8.0, 16.0, f))
	|> (\f ->
		if (state.inCard)
			TFrame(0.0, 2.0, [Fill(if (getLightBackground(parent)) white else 0x424242)], f)
			|> (\f2 -> TShadow(parent, const(2.0), f2))
		else
			f
	)
	|> (\f ->
		eitherMap(
			tryExtractStruct(m.style, WidthHeight(-1., -1.)),
			\ff ->
				if (ff.width > 0.0) {
					if (ff.height > 0.0) {
						TAvailable(f, TSized(const(ff)));
					} else {
						TAvailableWidth(f, const(ff.width));
					}
				} else if (ff.height > 0.0) {
					TAvailableHeight(f, const(ff.height));
				} else {
					f;
				},
			f
		)
	)
}

drawMChart(state : MChartState, style : [MChartStyle], m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	TGroup([
		drawMChartLines(state),
		drawMChartColumns(state, m2t),
		drawMChartAxes(state, m2t),
		drawMChartInteractive(state)
	])
	|> (\f -> TCrop(const(Point(-8.0, -8.0)), fselect(state.chartWH, FLift(\wh -> WidthHeight(wh.width + 16.0, wh.height + 16.0))), f))
	|> (\f -> TBorder4(-8.0, f))
	|> (\f -> TFixSize(f, TFillXY()))
	|> (\f -> TInspect([IAvailable(state.chartWH)], f))
	|> (\f -> TPositionScale(state.positionScale, f))
	|> TCanvas
	|> (\f -> drawMChartXAxisLegend(state, f, m2t))
	|> (\f -> drawMChartYAxisLegend(state, f, m2t))
	|> (\f -> TProportionCols([Pair(const(3.0), f), Pair(const(1.0), drawMChartLegend(state, m2t))]))
	|> TBorderTop(20.0)
}

drawMChartTitle(state : MChartState, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	makeTitle = \text, fontStyle : MFontStyle ->
		 if (text != "")
		 	MEllipsisText2T(
		 		state.manager,
		 		state.parent,
		 		MEllipsisText(
					 text,
					 [
						fontStyle,
						state.textColor,
						MShowTooltip(const(true)),
						EscapeHTML(state.escapeHTML)
					]
				),
		 		m2t
		 	)
			|> (\f2 -> TBorder(8.0, 0.0, 8.0, 0.0, f2))
		else
			TEmpty();

	TLines2(
		makeTitle(state.title, MHeadline()),
		makeTitle(state.subtitle, MSubheading())
	)
	|> TBorderBottom(if (state.title != "" || state.subtitle != "") 16.0 else 0.0)
}

drawMChartAxes(state : MChartState, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	axesLinesStyle = [Stroke(contrastingColor(state.parent)), StrokeOpacity(0.24), StrokeWidth(1.0)];

	TGroup([
		TShowLazy(state.verticalLines, \ ->
			TDynamicGraphics(
				fselect2(state.chartWH, state.centerPoint.first, FLift2(\wh, xcenter ->
					eitherMap(
						xcenter,
						\c ->
							[
								MoveTo(c, 0.0),
								LineTo(c, wh.height)
							],
						[]
					)
				)),
				const(axesLinesStyle)
			)
		),
		TShowLazy(state.horizontalLines, \ ->
			TDynamicGraphics(
				fselect2(state.chartWH, state.centerPoint.second, FLift2(\wh, ycenter ->
					eitherMap(
						ycenter,
						\c ->
							[
								MoveTo(0.0, c),
								LineTo(wh.width, c)
							],
						[]
					)
				)),
				const(axesLinesStyle)
			)
		)
	])
}

drawMChartXAxisLegend(state : MChartState, content : Tropic, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	(\ -> TLines2(
		TShowLazy(state.xAxisValuesVisible, \ ->
			TSelect(
				fmapi(
					fsubrange(state.xAxisValues, const(1), fsubtracti(flength(state.xAxisValues), const(2))),
					\i, d -> {
						MEllipsisText2T(
							state.manager,
							state.parent,
							MEllipsisText(
								d.second,
								concat(
									elementAt(state.xAxisValuesStyle, i, [MCaption(), state.textColor, EscapeHTML(state.escapeHTML)]),
									[
										MShowTooltip(const(true))
									]
								)
							),
							m2t
						)
						|> (\f -> TBorder4(8.0, f))
						|> (\f -> if (state.xAxisVertical) TRotate90Left(f) else f)
						|> (\f -> TCopySize2(f, \sz, tr -> TShift(tr, TScale(const(Factor(if (state.xAxisVertical) 0.6 else 0.5, 0.0)), sz))))
						|> (\f -> TTranslate(const(Point(d.first, 0.0)), f))
						|> (\f -> TTranslate(state.xAxisValuesTranslate, f))
					}
				),
				TGroup
			)
		),
		TSelect(state.xAxisCaption, \c ->
			if (c != "")
				MEllipsisText2T(
					state.manager,
					state.parent,
					MEllipsisText(
						c,
						[
							MBody(),
							state.textColor,
							MShowTooltip(const(true)),
							EscapeHTML(state.escapeHTML)
						]
					),
					m2t
				)
				|> TCenterX
			else
				TEmpty()
		)
	))
	|> (\f ->
		TIfLazy(state.xAxisValuesOnLines, \v ->
			if (v)
				TGroup2(
					content,
					TTranslate(
						fselect2(fheight(state.chartWH), state.centerPoint.second, FLift2(\hgt, ycenter ->
							Point(min(max(either(ycenter, 0.0), 20.0), hgt - 20.0), 0.0)
						)),
						f()
					)
				)
			else
				TLines2(content, f())
		)
	)
}

drawMChartYAxisLegend(state : MChartState, content : Tropic, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	(\ -> TCols2(
		TSelect(state.yAxisCaption, \c ->
			if (c != "")
				MEllipsisText2T(
					state.manager,
					state.parent,
					MEllipsisText(
						c,
						[
							MBody(),
							state.textColor,
							MShowTooltip(const(true)),
							EscapeHTML(state.escapeHTML)
						]
					),
					m2t
				)
				|> TRotate90Left
				|> TCenterY
			else
				TEmpty()
		),
		TShowLazy(
			state.yAxisValuesVisible,
			\ ->
				TSelect(
					fmapi(state.yAxisValues, \i, d -> {
						MEllipsisText2T(
							state.manager,
							state.parent,
							MEllipsisText(
								d.second + state.valuesPostfix,
								[
									MCaption(),
									state.textColor,
									MShowTooltip(const(true)),
									EscapeHTML(state.escapeHTML)
								]
							),
							m2t
						)
						|> (\f -> TBorder4(8.0, f))
						|> (\f -> TCopySize2(f, \sz, tr -> TShift(tr, TScale(const(Factor(1.0, 0.5)), sz))))
						|> (\f -> TTranslate(const(Point(0.0, d.first)), f))
						|> (\f -> TTranslate(state.yAxisValuesTranslate, f))
					}),
					TGroup
				)
				|> (\f -> TCopySize2(f, \sz, tr -> TFixSize(TCols2(TWidth(sz), tr), sz)))
				|> TBorderRight(8.0)
		)
	)
	|> (\f -> TAvailableHeight(f, fheight(state.chartWH))))
	|> (\f ->
		TIfLazy(state.yAxisValuesOnLines, \v ->
			if (v)
				TGroup2(
					content,
					TTranslate(
						fselect2(fwidth(state.chartWH), state.centerPoint.first, FLift2(\wd, xcenter ->
							Point(min(max(either(xcenter, 0.0), 20.0), wd - 20.0), 0.0)
						)),
						f()
					)
				)
			else
				TCols2(f(), content)
		)
	)
}

drawMChartLines(state : MChartState) -> Tropic {
	gridLinesStyle = [Stroke(contrastingColor(state.parent)), StrokeOpacity(0.14), StrokeWidth(1.0)];

	TGroup2(
		TShowLazy(state.verticalLines, \ ->
			TDynamicGraphics(
				fsubselect(fheight(state.chartWH), FLift(\hgt ->
					fmap(state.xAxisValues, \d ->
						[
							MoveTo(d.first, 0.0),
							LineTo(d.first, hgt)
						]
					)
					|> fconcatA
				)),
				const(gridLinesStyle)
			)
		),
		TShowLazy(state.horizontalLines, \ ->
			TDynamicGraphics(
				fsubselect(fwidth(state.chartWH), FLift(\wd ->
					fmap(state.yAxisValues, \d ->
						[
							MoveTo(0.0, d.first),
							LineTo(wd, d.first)
						]
					)
					|> fconcatA
				)),
				const(gridLinesStyle)
			)
		)
	);
}

drawMChartLegend(state : MChartState, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	if (state.showLegend)
		SelectTLines(state.columns, \__, __, c -> {
			MCheckBox2T(
				state.manager,
				state.parent,
				MCheckBox(
					MEllipsisText(
						c.title,
						[
							MSubheading(),
							state.textColor,
							MShowTooltip(const(true)),
							EscapeHTML(state.escapeHTML)
						]
					),
					c.visible,
					[
						c.color,
						MIconSize(20.0),
						THovering(c.hover)
					]
				),
				m2t
			)
			|> TBorderTop(-2.0)
			|> TBorderBottom(-6.0)
		})
		|> (\f ->
			TCopySize2(
				f,
				\sz, tr ->
					MScroll2T(
						state.manager,
						state.parent,
						MScroll(
							tr,
							TGroup2(
								TMinimumGroup2(
									TWidth(sz),
									TFillX()
								),
								TFillY()
							),
							[
								TScrollBound(const(true), const(true))
							]
						),
						m2t
					)
			)
		)
		|> (\f -> TBorder(16.0, -8.0, 16.0, 16.0, f))
	else
		TEmpty();
}

drawMChartColumns(state : MChartState,  m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	hoverPointRadius = 8.0;

	SelectTGroup(state.columns, \__, __, chart -> {
		switch (chart : MChartColumnState) {
			MBarChartColumnState(title, color, barWidth, visible, hover, position, points, style): {
				(\ -> map(points, \p ->
					TGroup([
						TDynamicGraphics(p.graphicsData, const(style)),
						TShowLazy(fOr(p.down, fOr(hover, p.hover)), \ -> TDynamicGraphics(p.graphicsData, const([Fill(contrastingColor(state.parent)), FillOpacity(0.2)]))),
						TShowLazy(p.down, \ -> TDynamicGraphics(p.graphicsData, const([Fill(contrastingColor(state.parent)), FillOpacity(0.2)])))
					])
					|> (\f -> drawMChartValueLabel(state, chart, p, f))
					|> (\f -> drawMChartHoverPoint(state, p, f))
				)
				|> TGroup
				|> (\f -> TTranslate(position, f)))
				|> (\f -> TShowLazy(visible, f))
			}
			MLineChartColumnState(title, color, visible, hover, position, points, lineType, lineStyle, hidePoints, pointRadius, pointStyle): {
				(\ -> TGroup2(
					TSelect(fmerge(map(points, \p -> p.graphicsData)), \gd ->
						TGroup2(
							TShowLazy(
								hover,
								\ -> makeLineByType(
									concatA(gd),
									lineType,
									state.isCurve,
									replaceStructMany(
										lineStyle,
										[
											StrokeWidth(extractStruct(lineStyle, StrokeWidth(1.0)).width * 2.0),
											Stroke(contrastingColor(state.parent)),
											StrokeOpacity(extractStruct(lineStyle, StrokeOpacity(1.0)).opacity * (if (getLightBackground(state.parent)) 0.1 else 0.3))
										]
									)
								)
							),
							makeLineByType(concatA(gd), lineType, state.isCurve, lineStyle)
						)
					),
					if (state.hidePoints || hidePoints)
						TEmpty()
					else
						map(points, \p ->
							TTranslate(
								p.position,
								TScale(
									fif(
										p.down,
										if (isSome(p.onClick))
											const(Factor(2.0, 2.0))
										else
											const(Factor(1.0, 1.0)),
										if ((state.hideHover && isNone(p.onClick)) || isSome(p.pointMarker))
											const(Factor(1.0, 1.0))
										else
											fif(p.hover, const(Factor(1.5, 1.5)), const(Factor(1.0, 1.0)))
									),
									eitherFn(
										p.pointMarker,
										\pointMarker ->
											m2t(pointMarker, state.parent)
											|> (\f -> TCopySize2(f, \sz, tr -> TShift(tr, TScale(const(Factor(0.5, 0.5)), sz)))),
										\ ->
											TTranslate(
												const(Point(-pointRadius, -pointRadius)),
												TCircle(pointRadius, pointStyle)
											)
									)
								)
							)
							|> (\f -> drawMChartValueLabel(state, chart, p, f))
							|> (\f -> drawMChartHoverPoint(state, p, f))
						)
						|> TGroup
				)
				|> (\f -> TTranslate(position, f)))
				|> (\f -> TShowLazy(visible, f))
			}
		}
	})
}

drawMChartValueLabel(state : MChartState, chart : MChartColumnState, point : MChartPoint, content : Tropic) -> Tropic {
	eitherMap(
		state.valuesLabels,
		\withPostfix ->
			TGroup2(
				content,
				MText2T(
					state.parent,
					d2st(point.value.y, 2) + if (withPostfix) state.valuesPostfix else "",
					[MCaptionSolid(), chart.color, EscapeHTML(state.escapeHTML)]
				)
				|> (\f -> TCopySize2(f, \sz, tr -> TShift(tr, TScale(const(Factor(0.5, 1.0)), sz))))
				|> (\f -> TTranslate(fselect(point.position, FLift(\p -> Point(p.x, p.y - 8.0))), f))
			),
		content
	)
	|> (\f ->
		eitherMap(
			point.pointLabel,
			\pointLabel -> {
				TGroup2(
					f,
					TParagraph(const(pointLabel.first), pointLabel.second)
					|> (\f2 -> TCopySize2(f2, \sz, tr -> TShift(tr, TScale(const(Factor(0.5, 1.0)), sz))))
					|> (\f2 -> TTranslate(fselect(point.position, FLift(\p -> Point(p.x, p.y - 8.0 - 16.0 * b2d(isSome(state.valuesLabels))))), f2))
				)
			},
			f
		)
	)
}

drawMChartHoverPoint(state : MChartState, point : MChartPoint, content : Tropic) -> Tropic {
	hoverPointRadius = 8.0;

	if (state.hideHover)
		content
	else
		TConstruct(
			[
				makeSubscribeUns(fgreateri(flength(point.hoverData), const(0)), \hoverEnabled ->
					if (hoverEnabled)
						[
							makeSubscribeUns(point.hover, \hover ->
								if (hover)
									[
										TLines2(
											MText2T(
												state.parent,
												point.title,
												[MBodyBold(), state.textColor, EscapeHTML(state.escapeHTML)]
											)
											|> TBorderBottom(8.),
											SelectTLines(
												fselect2(point.hoverData, state.columns, FLift2(\hd, c ->
													map(hd, \d -> Pair(d, elementAt(c, d.id, emptyMChartColumnState).hover))
												)),
												\__, __, d ->
													TConstruct(
														[
															\ -> {
																nextDistinct(d.second, true);
																\ -> nextDistinct(d.second, false);
															}
														],
														TLines2(
															MText2T(state.parent, d.first.title, [MListBody(), state.textColor, EscapeHTML(state.escapeHTML)])
															|> (\t -> TBorder(0., 8., 0., 4., t)),
															MText2T(state.parent, d.first.value, [MHeadline(), d.first.color, EscapeHTML(state.escapeHTML)])
														)
													)
											)
										)
										|> (\f2 -> TFrame(16.0, 2.0, [Fill(if (state.textColor == MWhite()) 0x424242 else white)], f2))
										|> (\f2 -> TShadow(state.parent, const(8.0), f2))
										|> (\f2 -> TBorder(16.0, 16.0, 0.0, 0.0, f2))
										|> (\f2 ->
											TTranslate(
												fselect2(state.positionScale, point.position, FLift2(\ps, p ->
													Point(ps.pos.x + p.x, ps.pos.y + p.y)
												)),
												f2
											)
										)
										|> (\f2 -> trender(f2, state.manager.manager.renderStyle))
									]
								else
									[]
							)()
						]
					else
						[]
				)
			]
			|> (\subs ->
				eitherMap(
					point.onClick,
					\onClick ->
						arrayPush(subs, make2Subscribe2(point.hover, point.down, \h, d -> if (h && d) onClick())),
					subs
				)
			),
			content
		);
}

drawMChartInteractive(state : MChartState) -> Tropic {
	hoverPointRadius = 8.0;
	currentPoint : ref Maybe<MChartPoint> = ref None();

	TInteractive(
		[
			MouseDown2(\h, mi -> {
				if (!h && mi.inside()) {
					maybeApply(^currentPoint, \d -> nextDistinct(d.down, true));
					isSome(^currentPoint);
				} else {
					h;
				}
			}),
			MouseUp2(\h, mi -> {
				maybeApply(^currentPoint, \d -> nextDistinct(d.down, false));
				h || isSome(^currentPoint);
			}),
			MouseMove2(\h, mi -> {
				if (!h) {
					m = mi();

					if (m.inside) {
						prevCurrentPoint = ^currentPoint;
						currentPoint := None();

						hh = fold(fgetValue(state.columns), false, \hit, chart ->
							hit ||
								fold(chart.points, hit, \hit2, point -> {
									if (!hit2) {
										position = fgetValue(chart.position);
										hit3 =
											switch (chart) {
												MBarChartColumnState(__, __, __, __, __, __, __, __): {
													fold(fgetValue(point.graphicsData), hit2, \hit3, data ->
														hit || hittestStaticGraphicShape(data, Point(m.x - position.x, m.y - position.y))
													);
												}
												MLineChartColumnState(__, __, __, __, __, __, __, __, __, __, __): {
													hittestStaticGraphicShape(
														GCircle(fgetValue(point.position).x, fgetValue(point.position).y, hoverPointRadius),
														Point(m.x - position.x, m.y - position.y)
													);
												}
											};

										if (hit3) {
											eitherFn(
												prevCurrentPoint,
												\p -> {
													if (p == point) {
														currentPoint := prevCurrentPoint;
													} else {
														nextDistinct(point.hover, true);
														currentPoint := Some(point);
													}
												},
												\ -> {
													nextDistinct(point.hover, true);
													currentPoint := Some(point);
												}
											)
										}

										hit3;
									} else {
										hit2;
									}
								})
						);

						if (^currentPoint != prevCurrentPoint) {
							maybeApply(prevCurrentPoint, \d -> nextDistinct(d.hover, false));
						}

						hh;
					} else {
						maybeApply(^currentPoint, \d -> nextDistinct(d.hover, false));
						currentPoint := None();

						h;
					}
				} else {
					h;
				}
			})
		],
		TRectangle(interactiveRectangleStyle, TSized(state.wh))
	)
}

hittestStaticGraphicShape(shape : StaticGraphicOp, point : Point) -> bool {
	switch (shape : StaticGraphicOp) {
		GRect(x, y, width, height): {
			x <= point.x && x + width >= point.x && y <= point.y && y + height >= point.y;
		}
		GRoundedRect(x, y, width, height, radius): {
			x <= point.x && x + width >= point.x && y <= point.y && y + height >= point.y;
		}
		GEllipse(x, y, width, height): {
			dx = abs(x - point.x);
			dy = abs(y - point.y);

			1.0 >= dx * dx / width * width + dy * dy / height * height;
		}
		GCircle(x, y, radius): {
			dx = abs(x - point.x);
			dy = abs(y - point.y);

			radius > sqrt(dx * dx + dy * dy);
		}
		default: {
			false;
		}
	}
}

getPointNeighbours(r : [double], distDelta : double, i : int, acc1 : [int]) -> [int] {
	foldi(tail(r), acc1, \k, acc, d ->
		if ((d + distDelta) > r[i] && (d - distDelta) < r[i] && !contains(acc, k + 1) && (r[k + 1] != -doubleMax))
			if (k + 1 == i)
				arrayPush(acc, i)
			else
				getPointNeighbours(r, distDelta, k + 1, arrayPush(acc, k + 1))
		else
			acc)
}

stepLength(len : double, isDate : bool) -> double {
	if (len == 0.0)
		(if (isDate) msInDay else 0.5)
	else {
		lengthLimit = 1.0;
		lengthDivider = 10.0;
		lengthDivider2 = 2.0;
		(if (len > lengthLimit) {
			generateWhile2(len, \l -> l > lengthLimit, \l -> l / lengthDivider, \l -> l)
			|> (\f -> pow2(lengthDivider, length(f) - 1))
			|> (\f -> either(f, 1.0))
		} else {
			generateWhile2(len, \l -> l < lengthLimit, \l -> l * lengthDivider, \l -> l)
			|> (\f -> pow2(lengthDivider, - length(f)))
			|> (\f -> either(f, 1.0))
		})
		|> (\f2 -> if (len / f2 < 2.0) f2 / 2.0 else f2)
		|> (\f2 -> if (len / f2 < 4.0) f2 / 2.0 else f2)
	}
}

getFirstControlPoints(rhs : [double]) -> [double] {
	n = length(rhs);
	x = ref arrayRepeat(0.0, n); // Solution vector.
	tmp = ref ^x; // Temp workspace.

	b = ref 2.0;
	x := replace(^x, 0, rhs[0] / ^b);

	fori(1, n - 1, \i -> {
		tmp := replace(^tmp, i, 1.0 / ^b);
		b := (if (i < n - 1) 4.0 else 3.5) - ^tmp[i];
		x := replace(^x, i, (rhs[i] - ^x[i - 1]) / ^b);
	});

	fori(1, n - 1, \i -> {
		x := replace(^x, n - i - 1, ^x[n - i - 1] - ^tmp[n - i] * ^x[n - i]);
	});

	^x;
}

getCurveControlPoints(knots : [Point]) -> Pair<[Point], [Point]> {
	n = length(knots) - 1;

	if (n < 1)
		Pair([], [])
	else if (n == 1) {
		// Special case: Bezier curve should be a straight line.
		// 3P1 = 2P0 + P3
		px = (2.0 * knots[0].x + knots[1].x) / 3.0;
		py = (2.0 * knots[0].y + knots[1].y) / 3.0;

		// P2 = 2P1 – P0
		Pair([Point(px, py)], [Point(2.0 * px - knots[0].x, 2.0 * py - knots[0].y)])
	} else {
		// Calculate first Bezier control points
		// Right hand side vector
		rhs = ref arrayRepeat(0.0, n);

		// Set right hand side X values
		fori(1, n - 2, \i -> {
			rhs := replace(^rhs, i, 4.0 * knots[i].x + 2.0 * knots[i + 1].x);
		});
		rhs := replace(^rhs, 0, knots[0].x + 2.0 * knots[1].x);
		rhs := replace(^rhs, n - 1, (8.0 * knots[n - 1].x + knots[n].x) / 2.0);

		// Get first control points X-values
		x = getFirstControlPoints(^rhs);

		// Set right hand side Y values
		fori(1, n - 2, \i -> {
			rhs := replace(^rhs, i, 4.0 * knots[i].y + 2.0 * knots[i + 1].y);
		});
		rhs := replace(^rhs, 0, knots[0].y + 2.0 * knots[1].y);
		rhs := replace(^rhs, n - 1, (8.0 * knots[n - 1].y + knots[n].y) / 2.0);

		// Get first control points Y-values
		y = getFirstControlPoints(^rhs);

		// Fill output arrays.
		firstControlPoints = ref arrayRepeat(zeroPoint, n);
		secondControlPoints = ref ^firstControlPoints;

		fori(0, n - 1, \i -> {
			firstControlPoints := replace(^firstControlPoints, i, Point(x[i], y[i]));
			if (i < n - 1)
				secondControlPoints :=
					replace(^secondControlPoints, i,
						Point(2.0 * knots[i + 1].x - x[i + 1],
							2.0 * knots[i + 1].y - y[i + 1]))
			else
				secondControlPoints :=
					replace(^secondControlPoints, i,
						Point((knots[n].x + x[n - 1]) / 2.0,
							(knots[n].y + y[n - 1]) / 2.0))
		});

		Pair(^firstControlPoints, ^secondControlPoints)
	}
}

standartChartColors : [MColor] =
	[MBlue(500), MOrange(500), MGreen(500), MPurple(500), MRed(500), MTeal(500),
		MLime(500), MBrown(500), MCyan(500)];

getChartColor(colors : [MColor], i : int) -> MColor {
	(if (length(colors) == 0) standartChartColors else colors)
		|> (\arr -> arr[i % length(arr)])
}