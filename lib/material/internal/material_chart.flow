import material/internal/material_line;
import material/internal/material_ellipsis;
import material/internal/material_button;
import tropic/selecttarray;

export {
	MChart2T(manager : MaterialManager, parent : MFocusGroup, m : MChart, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
}

MChartState(
	manager : MaterialManager,
	parent : MFocusGroup,

	data : MChartData,

	wh : DynamicBehaviour<WidthHeight>,
	chartWH : DynamicBehaviour<WidthHeight>,
	positionScale : DynamicBehaviour<PositionScale>,

	title : string,
	subtitle : string,
	textColor : MColor,
	escapeHTML : bool,
	inCard : bool,
	isCurve : bool,
	showLegend : bool,
	hidePoints : bool,
	hideHover : bool,
	valuesPostfix : string,
	tooltipValuesPostfix : string,
	center : MAxesCenter,
	valuesLabels : Maybe<bool>,
	lineLabels : bool,

	verticalLines : bool,
	horizontalLines : bool,

	xAxisIsDate : bool,
	xAxisVertical : bool,
	xAxisValuesVisible : bool,
	xAxisValuesOnLines : bool,
	xAxisCaption : string,
	xAxisScope : MXAxisScope,
	xAxisGridStep : double,
	xAxisValues : Transform<[Pair<double, double>]>,
	xAxisValuesStyle : [[MTextStyle]],
	xAxisValuesTranslate : Transform<Point>,

	yAxisValuesVisible : bool,
	yAxisValuesOnLines : bool,
	yAxisCaption : string,
	yAxisScope : MYAxisScope,
	yAxisGridStep : double,
	yAxisValues : Transform<[Pair<double, double>]>,
	yAxisValuesTranslate : Transform<Point>,

	columns : [MChartColumnState]
);

makeMChartState(manager : MaterialManager, parent : MFocusGroup, data : MChartData, style : [MChartStyle]) -> MChartState {
	wh = makeWH();
	chartWH = makeWH();
	positionScale = make(zeroPositionScale);

	title = extractStruct(style, MChartTitle("")).title;
	subtitle = extractStruct(style, MChartSubtitle("")).subtitle;
	textColor = contrastingMColor(parent);
	escapeHTML = extractStruct(style, EscapeHTML(true)).escape;
	inCard = contains(style, MInCard());
	isCurve = contains(style, MChartCurve());
	showLegend = !contains(style, MHideLegend());
	hidePoints = contains(style, MHidePoints());
	hideHover = contains(style, MHideValueHover());
	valuesPostfix = extractStruct(style, MValuesPostfix("")).postfix;
	tooltipValuesPostfix = extractStruct(style, MTooltipValuesPostfix(valuesPostfix)).postfix;
	type =
		extractStruct(style, MChartType([])).chartType
		|> (\f ->
			if (length(data.data) > 0 && length(f) < length(data.data[0]))
				generate(0, length(data.data[0]), \i -> elementAt(f, i, MLineChart()))
			else
				f
		);
	center = fold(extractStructMany(style, MAxesCenter(0., 0.)), MAxesCenter(0., 0.), \acc, c -> MAxesCenter(acc.x + c.x, acc.y + c.y));
	valuesLabels = maybeMap(tryExtractStruct(style, MValuesLabels(false)), \vl -> vl.withPostfix);
	lineLabels = contains(style, MLineLabels());
	barWidth = extractStruct(style, MBarWidth(4., 1.));
	onClick = extractStruct(style, MOnChartClick([])).click;

	linesStyles = extractStruct(style, MChartLinesStyle([])).style;
	linesColors =
		concat(
			extractStruct(style, MLinesColors([])).colors,
			mapi(linesStyles, \i, st -> extractStruct(st, getChartColor(standartChartColors, i)))
		);

	verticalLines = contains(style, MShowVerticalLines());
	horizontalLines = contains(style, MShowHorizontalLines());

	xAxisIsDate = contains(style, MXAxisIsDate());
	xAxisVertical = contains(style, MXAxisVertical());
	xAxisValuesVisible = !contains(style, MHideXAxisValues());
	xAxisValuesOnLines = contains(style, MXAxisValuesOnLines());
	xAxisCaption = extractStruct(style, MXAxisCaption(elementAt(data.columns, 0, ""))).caption;

	xAxisValuesStyle = extractStruct(style, MXAxisValuesStyle([])).style;
	yAxisValuesVisible = !contains(style, MHideYAxisValues());
	yAxisValuesOnLines = contains(style, MYAxisValuesOnLines());
	yAxisCaption = extractStruct(style, MYAxisCaption("")).caption;

	maxDataLength = either(maxA(map(data.data, length)), 0);
	chartData =
		MChartData(
			generate(0, max(maxDataLength, length(data.columns)), \j -> elementAt(data.columns, j, "")),
			data.rows,
			generate(0, max(length(data.data), length(data.rows)), \i ->
				generate(0, max(maxDataLength, length(data.columns)), \j ->
					if (length(data.data) > i && length(data.data[i]) > j) {
						if (xAxisIsDate && j == 0) date2stamp(stamp2date(data.data[i][j])) else data.data[i][j];
					} else {
						if (j == 0) i2d(i + 1) else 0.0;
					}
				)
			)
		);

	xMin = either(minA(map(chartData.data, \r -> r[0])), 0.0);
	xMax = either(maxA(map(chartData.data, \r -> r[0])), 0.0);

	yMin = either(minA(map(chartData.data, \r -> either(minA(map(tail(r), \ry -> if (ry != -doubleMax) ry else doubleMax)), 0.0))), 0.0);
	yMax = either(maxA(map(chartData.data, \r -> either(maxA(tail(r)), 1.0))), 0.0);

	xAxisGridStep = extractStruct(style, MXAxisGridStep(1.0)).step;
	yAxisGridStep = extractStruct(style, MYAxisGridStep(stepLength(yMax - yMin, false))).step;

	xAxisScope =
		extractStruct(
			style,
			MXAxisScope(
				if (xMin < 0.0)
					dceil(-xMin / xAxisGridStep + 1.0) * -xAxisGridStep
				else
					dfloor(xMin / xAxisGridStep - 1.0) * xAxisGridStep,
				dceil(xMax / xAxisGridStep + 1.0) * xAxisGridStep
			)
		);
	yAxisScope =
		extractStruct(
			style,
			MYAxisScope(
				if (yMin < 0.0)
					dceil(-yMin / yAxisGridStep + b2d(isCurve) / 4.0) * -yAxisGridStep
				else
					dfloor(yMin / yAxisGridStep - b2d(isCurve) / 4.0) * yAxisGridStep,
				dceil(yMax / yAxisGridStep + b2d(isCurve) / 4.0) * yAxisGridStep
			)
		);

	xAxisValues = generateWhile2(xAxisScope.min, \i -> i <= xAxisScope.max, \i -> i + xAxisGridStep, idfn);
	yAxisValues = generateWhile2(yAxisScope.min, \i -> i <= yAxisScope.max, \i -> i + yAxisGridStep, idfn);

	xAxisValuesTranslate = extractStruct(style, MXAxisValuesTranslate(const(Point(0.0, 0.0)))).point;
	yAxisValuesTranslate = extractStruct(style, MYAxisValuesTranslate(const(Point(0.0, 0.0)))).point;

	xAxisValuesT = fselect(fwidth(chartWH), FLift(\wd ->
		map(xAxisValues, \d ->
			Pair((d - xAxisScope.min) * wd / (xAxisScope.max - xAxisScope.min), d)
		)
	));
	yAxisValuesT = fselect(fheight(chartWH), FLift(\hgt ->
		map(yAxisValues, \d ->
			Pair((yAxisScope.max - d) * hgt / (yAxisScope.max - yAxisScope.min), d)
		)
	));

	columns =
		makeMChartColumnStateStates(
			chartData,
			type,
			chartWH,
			xAxisScope,
			yAxisScope,
			linesStyles,
			linesColors,
			onClick,
			barWidth,
			isCurve,
			xAxisIsDate,
			lineLabels,
			tooltipValuesPostfix
		);

	MChartState(
		manager,
		parent,

		chartData,

		wh,
		chartWH,
		positionScale,

		title,
		subtitle,
		textColor,
		escapeHTML,
		inCard,
		isCurve,
		showLegend,
		hidePoints,
		hideHover,
		valuesPostfix,
		tooltipValuesPostfix,
		center,
		valuesLabels,
		lineLabels,

		verticalLines,
		horizontalLines,

		xAxisIsDate,
		xAxisVertical,
		xAxisValuesVisible,
		xAxisValuesOnLines && center.x > xAxisScope.min + xAxisGridStep && center.x < xAxisScope.max - xAxisGridStep,
		xAxisCaption,
		xAxisScope,
		xAxisGridStep,
		xAxisValuesT,
		xAxisValuesStyle,
		xAxisValuesTranslate,

		yAxisValuesVisible,
		yAxisValuesOnLines && center.y > yAxisScope.min + yAxisGridStep && center.y < yAxisScope.max - yAxisGridStep,
		yAxisCaption,
		yAxisScope,
		yAxisGridStep,
		yAxisValuesT,
		yAxisValuesTranslate,

		columns
	);
}

MChartColumnState ::= MBarChartColumnState, MLineChartColumnState;

MBarChartColumnState(
	title : string,
	color : MColor,
	barWidth : MBarWidth,
	visible : DynamicBehaviour<bool>,
	hover : DynamicBehaviour<bool>,
	position : Transform<Point>,
	points : [MChartPoint],
	style : [TGraphicsStyle]
);

MLineChartColumnState(
	title : string,
	color : MColor,
	visible : DynamicBehaviour<bool>,
	hover : DynamicBehaviour<bool>,
	position : Transform<Point>,
	points : [MChartPoint],
	lineType : MMLineType,
	lineStyle : [TGraphicsStyle],
	hidePoints : bool,
	pointRadius : double,
	pointStyle : [TGraphicsStyle]
);

MChartPoint(
	id : int,
	title : string,
	value : Point,
	position : Transform<Point>,
	graphicsData : Transform<[StaticGraphicOp]>,
	hover : DynamicBehaviour<bool>,
	down : DynamicBehaviour<bool>,
	hoverData : Transform<[MChartHoverData]>,
	pointLabel : Maybe<Pair<string, [TParagraphStyle]>>,
	pointMarker : Maybe<Material>,
	onClick : Maybe<() -> void>
);

MChartHoverData(
	title : string,
	value : string,
	color : MColor
);

makeMChartColumnStateStates(
	data : MChartData,
	chartType : [MMChartType],
	chartWH : Transform<WidthHeight>,
	xAxisScope : MXAxisScope,
	yAxisScope : MYAxisScope,
	linesStyles : [[MLineStyle]],
	linesColors : [MColor],
	onClick : [(int) -> void],
	barWidth : MBarWidth,
	isCurve : bool,
	xAxisIsDate : bool,
	lineLabels : bool,
	tooltipValuesPostfix : string,
) -> [MChartColumnState] {
	barCount = countA(chartType, eq(MBarChart())) - 1;

	generate(1, length(data.data[0]), \i -> {
		title = data.columns[i];
		barChart = if (length(chartType) >= i) chartType[i - 1] == MBarChart() else false;
		filteredData = filtermapi(data.data, \j, r -> if (r[i] != -doubleMax) Some(Pair(j, Point(r[0], r[i]))) else None());
		color = getChartColor(linesColors, i - 1);
		lineStyle = if (length(linesStyles) > 0) linesStyles[(i - 1) % length(linesStyles)] else [];
		opacity = extractStruct(lineStyle, FillOpacity(1.0)).opacity;
		pointLabelM = tryExtractStruct(lineStyle, MPointLabel(\__ -> ""));
		pointMarkerM = tryExtractStruct(lineStyle, MPointMarker(\__, __ -> TEmpty()));
		pointLabelStyle = extractStruct(lineStyle, MPointLabelStyle([MFill(color)])).style;

		controlPoints =
			if (!barChart && isCurve) {
				getCurveControlPoints(map(filteredData, \fd -> fd.second));
			} else {
				Pair([], []);
			};

		points =
			mapi(filteredData, \j, d -> {
				id = d.first;
				value = d.second;
				getPoint = \wh ->
					Point(
						(value.x - xAxisScope.min) * wh.width / (xAxisScope.max - xAxisScope.min),
						(yAxisScope.max - value.y) * wh.height / (yAxisScope.max - yAxisScope.min)
					);
				pointLabel =
					maybeMap(
						pointLabelM,
						\pointLabel ->
							Pair(pointLabel.getLabel(value.y), pointLabelStyle)
					)
					|> (\pointLabel ->
						if (lineLabels && j == length(filteredData) - 1)
							eitherFn(
								pointLabel,
								\pl -> Some(Pair(pl.first + " " + title, pl.second)),
								\ -> Some(Pair(title, pointLabelStyle))
							)
						else
							pointLabel
					);
				pointMarker =
					maybeMap(
						pointMarkerM,
						\pointMarker -> pointMarker.getMarker(i, value.y)
					);

				MChartPoint(
					id,
					if (length(data.rows) > id)
						data.rows[id]
					else if (xAxisIsDate)
						getDateString(stamp2date(value.x), false, false, false)
					else
						d2st(value.x, 2),
					value,
					fselect(chartWH, getPoint |> FLift),
					fselect(chartWH, FLift(\wh -> {
						p = getPoint(wh);

						if (barChart) {
							rectangle(p.x - barWidth.width / 2., p.y, barWidth.width, wh.height - p.y)
						} else if (j == 0) {
							[MoveTo(p.x, p.y), LineTo(p.x, p.y)]
						} else if (isCurve) {
							xc = (controlPoints.first[j - 1].x + (controlPoints.second[j - 1].x - controlPoints.first[j - 1].x) * 3.0 / 2.0 - xAxisScope.min)
								* wh.width / (xAxisScope.max - xAxisScope.min);
							yc = (yAxisScope.max - (controlPoints.first[j - 1].y + (controlPoints.second[j - 1].y - controlPoints.first[j - 1].y) * 3.0 / 2.0))
								* wh.height / (yAxisScope.max - yAxisScope.min);

							[CubicBezierTo(p.x, p.y, xc, yc)]
						} else {
							[LineTo(p.x, p.y)]
						}
					})),
					make(false),
					make(false),
					fselect(chartWH, FLift(\wh -> {
						if (barChart) {
							[MChartHoverData(title, d2st(value.y, 2) + tooltipValuesPostfix, getChartColor(linesColors, i - 1))]
						} else {
							map(getPointNeighbours(data.data[id], (yAxisScope.max - yAxisScope.min) / wh.height * 4.0, i, []), \pn ->
								MChartHoverData(data.columns[pn], d2st(data.data[id][pn], 2) + tooltipValuesPostfix, getChartColor(linesColors, pn - 1))
							)
						}
					})),
					pointLabel,
					pointMarker,
					if (length(onClick) > i - 1) {
						Some(\ -> onClick[i - 1](id))
					} else {
						None();
					}
				)
			});

		if (barChart) {
			MBarChartColumnState(
				title,
				color,
				barWidth,
				make(true),
				make(false),
				const(
					Point(
						(i2d(countA(subrange(chartType, 0, i - 1), \ct -> ct == MBarChart())) - i2d(barCount) / 2.) * (barWidth.width + barWidth.gapWidth),
						0.0
					)
				),
				points,
				[MFill(color), FillOpacity(opacity), StrokeOpacity(0.)]
			)
		} else {
			lineWidth = extractStruct(lineStyle, MWidth(2.0)).width;
			lineType = extractStruct(lineStyle, MLineType(MLineSolid())).type;

			MLineChartColumnState(
				title,
				color,
				make(true),
				make(false),
				const(zeroPoint),
				points,
				lineType,
				[MStroke(color), StrokeOpacity(opacity), StrokeWidth(lineWidth)],
				contains(lineStyle, MHidePoints()),
				lineWidth,
				[MFill(color), FillOpacity(opacity)]
			);
		}
	})
}

MChart2T(manager : MaterialManager, parent : MFocusGroup, m : MChart, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	state = makeMChartState(manager, parent, m.data, m.style);

	makeTitle = \text, fontStyle : MFontStyle ->
		 if (text != "")
		 	MEllipsisText2T(
		 		manager,
		 		parent,
		 		MEllipsisText(
					 text,
					 [
						fontStyle,
						state.textColor,
						MShowTooltip(const(true)),
						EscapeHTML(state.escapeHTML)
					]
				),
		 		m2t
		 	)
			|> (\f2 -> TBorder(8.0, 0.0, 8.0, 0.0, f2))
		else
			TEmpty();

	(if (length(m.data.data) > 0 && exists(m.data.data, \i -> exists(tail(i), neq(-doubleMax)))) {
		drawMChart(state, m.style, m2t);
	} else {
		m2t(extractStruct(m.style, MEmptyMessage(MText(_("No Data"), [MTitle()]))).message, parent)
		|> TCenter
	})
	|> (\f -> TInspect([IAvailable(state.wh)], f))
	|> (\f ->
		TLines([
			makeTitle(state.title, MHeadline()),
			makeTitle(state.subtitle, MSubheading()),
			if (state.title != "" || state.subtitle != "")
				TFixed(16.0, 16.0)
			else
				TEmpty(),
			f
		])
	)
	|> (\f -> TBorder(8.0, 16.0, 8.0, 16.0, f))
	|> (\f ->
		if (state.inCard)
			TFrame(0.0, 2.0, [Fill(if (getLightBackground(parent)) white else 0x424242)], f)
			|> (\f2 -> TShadow(parent, const(2.0), f2))
		else
			f
	)
	|> (\f ->
		eitherMap(
			tryExtractStruct(m.style, WidthHeight(-1., -1.)),
			\ff ->
				if (ff.width > 0.0) {
					if (ff.height > 0.0) {
						TAvailable(f, TSized(const(ff)));
					} else {
						TAvailableWidth(f, const(ff.width));
					}
				} else if (ff.height > 0.0) {
					TAvailableHeight(f, const(ff.height));
				} else {
					f;
				},
			f
		)
	)
}

drawMChart(
	state : MChartState,
	style : [MChartStyle],
	m2t : (Material, MFocusGroup) -> Tropic
) -> Tropic {
	topBorder = 20.0;

	TGroup([
		drawMChartLines(state),
		drawMChartColumns(state, m2t),
		drawMChartAxes(state, m2t),
		drawMChartInteractive(state)
	])
	|> (\f -> TCrop(const(Point(-8.0, -8.0)), fselect(state.chartWH, FLift(\wh -> WidthHeight(wh.width + 16.0, wh.height + 16.0))), f))
	|> (\f -> TBorder4(-8.0, f))
	|> (\f -> TFixSize(f, TFillXY()))
	|> (\f -> TInspect([IAvailable(state.chartWH)], f))
	|> (\f -> TPositionScale(state.positionScale, f))
	|> TCanvas
	|> (\f -> drawMChartXAxisLegend(state, f, m2t))
	|> (\f -> drawMChartYAxisLegend(state, f, m2t))
	|> (\f -> TProportionCols([Pair(const(3.0), f), Pair(const(1.0), drawMChartLegend(state, m2t))]))
	|> TBorderTop(topBorder)
}

drawMChartAxes(state : MChartState, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	axesLinesStyle = [Stroke(contrastingColor(state.parent)), StrokeOpacity(0.24), StrokeWidth(1.0)];

	TGroup([
		if (state.verticalLines && state.xAxisScope.min <= state.center.x && state.xAxisScope.max >= state.center.x)
			TDynamicGraphics(
				fselect(state.chartWH, FLift(\wh ->
					[
						MoveTo((state.center.x - state.xAxisScope.min) * wh.width / (state.xAxisScope.max - state.xAxisScope.min), 0.0),
						LineTo((state.center.x - state.xAxisScope.min) * wh.width / (state.xAxisScope.max - state.xAxisScope.min), wh.height)
					]
				)),
				const(axesLinesStyle)
			)
		else
			TEmpty(),
		if (state.horizontalLines && state.yAxisScope.min <= state.center.y && state.yAxisScope.max >= state.center.y)
			TDynamicGraphics(
				fselect(state.chartWH, FLift(\wh ->
					[
						MoveTo(0.0, (state.yAxisScope.max - state.center.y) * wh.height / (state.yAxisScope.max - state.yAxisScope.min)),
						LineTo(wh.width, (state.yAxisScope.max - state.center.y) * wh.height / (state.yAxisScope.max - state.yAxisScope.min))
					]
				)),
				const(axesLinesStyle)
			)
		else
			TEmpty()
	])
}

drawMChartXAxisLegend(state : MChartState, content : Tropic, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	TLines2(
		if (state.xAxisValuesVisible)
			TSelect(
				fmapi(ffilter(state.xAxisValues, \d -> d.second > state.xAxisScope.min && d.second < state.xAxisScope.max), \i, d -> {
					MEllipsisText2T(
						state.manager,
						state.parent,
						MEllipsisText(
							if (length(state.data.rows) > i)
								state.data.rows[i]
							else if (state.xAxisIsDate)
								getDateString(stamp2date(d.second), false, false, false)
							else
								d2st(d.second, 2),
							concat(
								elementAt(state.xAxisValuesStyle, i, [MCaption(), state.textColor, EscapeHTML(state.escapeHTML)]),
								[
									MShowTooltip(const(true))
								]
							)
						),
						m2t
					)
					|> (\f -> TBorder4(8.0, f))
					|> (\f -> if (state.xAxisVertical) TRotate90Left(f) else f)
					|> (\f -> TCopySize2(f, \sz, tr -> TShift(tr, TScale(const(Factor(if (state.xAxisVertical) 0.6 else 0.5, 0.0)), sz))))
					|> (\f -> TTranslate(const(Point(d.first, 0.0)), f))
					|> (\f -> TTranslate(state.xAxisValuesTranslate, f))
				}),
				TGroup
			)
		else
			TEmpty(),
		if (state.xAxisCaption != "")
			MEllipsisText2T(
				state.manager,
				state.parent,
				MEllipsisText(
					state.xAxisCaption,
					[
						MBody(),
						state.textColor,
						MShowTooltip(const(true)),
						EscapeHTML(state.escapeHTML)
					]
				),
				m2t
			)
			|> TCenterX
		else
			TEmpty()
	)
	|> (\f ->
		if (state.xAxisValuesOnLines)
			TGroup2(
				content,
				TTranslate(
					fselect(state.chartWH, FLift(\wh ->
						Point(0.0, min(max((state.yAxisScope.max - state.center.y) / (state.yAxisScope.max - state.yAxisScope.min), 0.01), 0.95) * wh.height)
					)),
					f
				)
			)
		else
			TLines2(content, f)
	)
}

drawMChartYAxisLegend(state : MChartState, content : Tropic, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	TCols2(
		if (state.yAxisCaption != "")
			MEllipsisText2T(
				state.manager,
				state.parent,
				MEllipsisText(
					state.yAxisCaption,
					[
						MBody(),
						state.textColor,
						MShowTooltip(const(true)),
						EscapeHTML(state.escapeHTML)
					]
				),
				m2t
			)
			|> TRotate90Left
			|> TCenterY
		else
			TEmpty(),
		if (state.yAxisValuesVisible)
			TSelect(
				fmapi(state.yAxisValues, \i, d -> {
					MEllipsisText2T(
						state.manager,
						state.parent,
						MEllipsisText(
							d2st(d.second, 2) + state.valuesPostfix,
							[
								MCaption(),
								state.textColor,
								MShowTooltip(const(true)),
								EscapeHTML(state.escapeHTML)
							]
						),
						m2t
					)
					|> (\f -> TBorder4(8.0, f))
					|> (\f -> TCopySize2(f, \sz, tr -> TShift(tr, TScale(const(Factor(1.0, 0.5)), sz))))
					|> (\f -> TTranslate(const(Point(0.0, d.first)), f))
					|> (\f -> TTranslate(state.yAxisValuesTranslate, f))
				}),
				TGroup
			)
			|> (\f -> TCopySize2(f, \sz, tr -> TFixSize(TCols2(TWidth(sz), tr), sz)))
			|> TBorderRight(8.0)
		else
			TEmpty()
	)
	|> (\f -> TAvailableHeight(f, fheight(state.chartWH)))
	|> (\f ->
		if (state.yAxisValuesOnLines)
			TGroup2(
				content,
				TTranslate(
					fselect(state.chartWH, FLift(\wh ->
						Point(min(max((state.center.x - state.xAxisScope.min) / (state.xAxisScope.max - state.xAxisScope.min), 0.01), 0.95) * wh.width, 0.0)
					)),
					f
				)
			)
		else
			TCols2(f, content)
	)
}

drawMChartLines(state : MChartState) -> Tropic {
	gridLinesStyle = [Stroke(contrastingColor(state.parent)), StrokeOpacity(0.14), StrokeWidth(1.0)];

	TGroup2(
		if (state.verticalLines)
			TDynamicGraphics(
				fsubselect(fheight(state.chartWH), FLift(\hgt ->
					fmap(state.xAxisValues, \d ->
						[
							MoveTo(d.first, 0.0),
							LineTo(d.first, hgt)
						]
					)
					|> fconcatA
				)),
				const(gridLinesStyle)
			)
		else
			TEmpty(),
		if (state.horizontalLines)
			TDynamicGraphics(
				fsubselect(fwidth(state.chartWH), FLift(\wd ->
					fmap(state.yAxisValues, \d ->
						[
							MoveTo(0.0, d.first),
							LineTo(wd, d.first)
						]
					)
					|> fconcatA
				)),
				const(gridLinesStyle)
			)
		else
			TEmpty()
	);
}

drawMChartLegend(state : MChartState, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	if (state.showLegend)
		map(state.columns, \c -> {
			MCheckBox2T(
				state.manager,
				state.parent,
				MCheckBox(
					MEllipsisText(
						c.title,
						[
							MSubheading(),
							state.textColor,
							MShowTooltip(const(true)),
							EscapeHTML(state.escapeHTML)
						]
					),
					c.visible,
					[
						c.color,
						MIconSize(20.0),
						THovering(c.hover)
					]
				),
				m2t
			)
			|> TBorderTop(-2.0)
			|> TBorderBottom(-6.0)
		})
		|> TLines
		|> (\f ->
			TCopySize2(
				f,
				\sz, tr ->
					MScroll2T(
						state.manager,
						state.parent,
						MScroll(
							tr,
							TGroup2(
								TMinimumGroup2(
									TWidth(sz),
									TFillX()
								),
								TFillY()
							),
							[
								TScrollBound(const(true), const(true))
							]
						),
						m2t
					)
			)
		)
		|> (\f -> TBorder(16.0, -8.0, 16.0, 16.0, f))
	else
		TEmpty();
}

drawMChartColumns(state : MChartState,  m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	hoverPointRadius = 8.0;

	TGroup(
		map(state.columns, \chart -> {
			switch (chart : MChartColumnState) {
				MBarChartColumnState(title, color, barWidth, visible, hover, position, points, style): {
					map(points, \p ->
						TGroup([
							TDynamicGraphics(p.graphicsData, const(style)),
							TShow(fOr(p.down, fOr(hover, p.hover)), TDynamicGraphics(p.graphicsData, const([Fill(black), FillOpacity(0.2)]))),
							TShow(p.down, TDynamicGraphics(p.graphicsData, const([Fill(black), FillOpacity(0.2)])))
						])
						|> (\f -> drawMChartValueLabel(state, chart, p, f))
						|> (\f -> drawMChartHoverPoint(state, p, f))
					)
					|> TGroup
					|> (\f -> TTranslate(position, f))
					|> (\f -> TShow(visible, f))
				}
				MLineChartColumnState(title, color, visible, hover, position, points, lineType, lineStyle, hidePoints, pointRadius, pointStyle): {
					TGroup2(
						TSelect(fmerge(map(points, \p -> p.graphicsData)), \gd -> makeLineByType(concatA(gd), lineType, state.isCurve, lineStyle)),
						if (state.hidePoints || hidePoints)
							TEmpty()
						else
							map(points, \p ->
								TTranslate(
									p.position,
									TScale(
										fif(p.down, const(Factor(2.0, 2.0)), fif(fOr(p.hover, hover), const(Factor(1.5, 1.5)), const(Factor(1.0, 1.0)))),
										eitherFn(
											p.pointMarker,
											\pointMarker ->
												m2t(pointMarker, state.parent)
												|> (\f -> TCopySize2(f, \sz, tr -> TShift(tr, TScale(const(Factor(0.5, 0.5)), sz)))),
											\ ->
												TTranslate(
													const(Point(-pointRadius, -pointRadius)),
													TCircle(pointRadius, pointStyle)
												)
										)
									)
								)
								|> (\f -> drawMChartValueLabel(state, chart, p, f))
								|> (\f -> drawMChartHoverPoint(state, p, f))
							)
							|> TGroup
					)
					|> (\f -> TTranslate(position, f))
					|> (\f -> TShow(visible, f))
				}
			}
		})
	)
}

drawMChartValueLabel(state : MChartState, chart : MChartColumnState, point : MChartPoint, content : Tropic) -> Tropic {
	eitherMap(
		state.valuesLabels,
		\withPostfix ->
			TGroup2(
				content,
				MText2T(
					state.parent,
					d2st(point.value.y, 2) + if (withPostfix) state.valuesPostfix else "",
					[MCaptionSolid(), chart.color, EscapeHTML(state.escapeHTML)]
				)
				|> (\f -> TCopySize2(f, \sz, tr -> TShift(tr, TScale(const(Factor(0.5, 1.0)), sz))))
				|> (\f -> TTranslate(fselect(point.position, FLift(\p -> Point(p.x, p.y - 8.0))), f))
			),
		content
	)
	|> (\f ->
		eitherMap(
			point.pointLabel,
			\pointLabel -> {
				TGroup2(
					f,
					TParagraph(const(pointLabel.first), pointLabel.second)
					|> (\f2 -> TCopySize2(f2, \sz, tr -> TShift(tr, TScale(const(Factor(0.5, 1.0)), sz))))
					|> (\f2 -> TTranslate(fselect(point.position, FLift(\p -> Point(p.x, p.y - 8.0 - 16.0 * b2d(isSome(state.valuesLabels))))), f2))
				)
			},
			f
		)
	)
}

drawMChartHoverPoint(state : MChartState, point : MChartPoint, content : Tropic) -> Tropic {
	hoverPointRadius = 8.0;

	if (state.hideHover)
		content
	else
		TConstruct(
			[
				makeSubscribeUns(fgreateri(flength(point.hoverData), const(0)), \hoverEnabled ->
					if (hoverEnabled)
						[
							makeSubscribeUns(point.hover, \hover ->
								if (hover)
									[
										TLines2(
											MText2T(
												state.parent,
												point.title,
												[MBodyBold(), state.textColor, EscapeHTML(state.escapeHTML)]
											)
											|> TBorderBottom(8.),
											SelectTLines(
												point.hoverData,
												\__, __, d ->
													TLines2(
														MText2T(state.parent, d.title, [MListBody(), state.textColor, EscapeHTML(state.escapeHTML)])
														|> (\t -> TBorder(0., 8., 0., 4., t)),
														MText2T(state.parent, d.value, [MHeadline(), d.color, EscapeHTML(state.escapeHTML)])
													)
											)
										)
										|> (\f2 -> TFrame(16.0, 2.0, [Fill(if (state.textColor == MWhite()) 0x424242 else white)], f2))
										|> (\f2 -> TShadow(state.parent, const(8.0), f2))
										|> (\f2 -> TBorder(16.0, 16.0, 0.0, 0.0, f2))
										|> (\f2 ->
											TTranslate(
												fselect2(state.positionScale, point.position, FLift2(\ps, p ->
													Point(ps.pos.x + p.x, ps.pos.y + p.y)
												)),
												f2
											)
										)
										|> (\f2 -> trender(f2, state.manager.manager.renderStyle))
									]
								else
									[]
							)()
						]
					else
						[]
				)
			]
			|> (\subs ->
				eitherMap(
					point.onClick,
					\onClick ->
						arrayPush(subs, make2Subscribe2(point.hover, point.down, \h, d -> if (h && d) onClick())),
					subs
				)
			),
			content
		);
}

drawMChartInteractive(state : MChartState) -> Tropic {
	hoverPointRadius = 8.0;
	currentPoint : ref Maybe<MChartPoint> = ref None();

	TInteractive(
		[
			MouseDown2(\h, mi -> {
				if (!h && mi.inside()) {
					maybeApply(^currentPoint, \d -> nextDistinct(d.down, true));
					isSome(^currentPoint);
				} else {
					h;
				}
			}),
			MouseUp2(\h, mi -> {
				maybeApply(^currentPoint, \d -> nextDistinct(d.down, false));
				h || isSome(^currentPoint);
			}),
			MouseMove2(\h, mi -> {
				if (!h) {
					m = mi();

					if (m.inside) {
						prevCurrentPoint = ^currentPoint;
						currentPoint := None();

						hh = fold(state.columns, false, \hit, chart ->
							hit ||
								fold(chart.points, hit, \hit2, point -> {
									if (!hit2) {
										position = fgetValue(chart.position);
										hit3 =
											switch (chart) {
												MBarChartColumnState(__, __, __, __, __, __, __, __): {
													fold(fgetValue(point.graphicsData), hit2, \hit3, data ->
														hit || hittestStaticGraphicShape(data, Point(m.x - position.x, m.y - position.y))
													);
												}
												MLineChartColumnState(__, __, __, __, __, __, __, __, __, __, __): {
													hittestStaticGraphicShape(
														GCircle(fgetValue(point.position).x, fgetValue(point.position).y, hoverPointRadius),
														Point(m.x - position.x, m.y - position.y)
													);
												}
											};

										if (hit3) {
											eitherFn(
												prevCurrentPoint,
												\p -> {
													if (p == point) {
														currentPoint := prevCurrentPoint;
													} else {
														nextDistinct(point.hover, true);
														currentPoint := Some(point);
													}
												},
												\ -> {
													nextDistinct(point.hover, true);
													currentPoint := Some(point);
												}
											)
										}

										hit3;
									} else {
										hit2;
									}
								})
						);

						if (^currentPoint != prevCurrentPoint) {
							maybeApply(prevCurrentPoint, \d -> nextDistinct(d.hover, false));
						}

						hh;
					} else {
						maybeApply(^currentPoint, \d -> nextDistinct(d.hover, false));
						currentPoint := None();

						h;
					}
				} else {
					h;
				}
			})
		],
		TRectangle(interactiveRectangleStyle, TSized(state.wh))
	)
}

hittestStaticGraphicShape(shape : StaticGraphicOp, point : Point) -> bool {
	switch (shape : StaticGraphicOp) {
		GRect(x, y, width, height): {
			x <= point.x && x + width >= point.x && y <= point.y && y + height >= point.y;
		}
		GRoundedRect(x, y, width, height, radius): {
			x <= point.x && x + width >= point.x && y <= point.y && y + height >= point.y;
		}
		GEllipse(x, y, width, height): {
			dx = abs(x - point.x);
			dy = abs(y - point.y);

			1.0 >= dx * dx / width * width + dy * dy / height * height;
		}
		GCircle(x, y, radius): {
			dx = abs(x - point.x);
			dy = abs(y - point.y);

			radius > sqrt(dx * dx + dy * dy);
		}
		default: {
			false;
		}
	}
}

getPointNeighbours(r : [double], distDelta : double, i : int, acc1 : [int]) -> [int] {
	foldi(tail(r), acc1, \k, acc, d ->
		if ((d + distDelta) > r[i] && (d - distDelta) < r[i] && !contains(acc, k + 1) && (r[k + 1] != -doubleMax))
			if (k + 1 == i)
				arrayPush(acc, i)
			else
				getPointNeighbours(r, distDelta, k + 1, arrayPush(acc, k + 1))
		else
			acc)
}

stepLength(len : double, isDate : bool) -> double {
	if (len == 0.0)
		(if (isDate) msInDay else 0.5)
	else {
		lengthLimit = 1.0;
		lengthDivider = 10.0;
		lengthDivider2 = 2.0;
		(if (len > lengthLimit) {
			generateWhile2(len, \l -> l > lengthLimit, \l -> l / lengthDivider, \l -> l)
			|> (\f -> pow2(lengthDivider, length(f) - 1))
			|> (\f -> either(f, 1.0))
		} else {
			generateWhile2(len, \l -> l < lengthLimit, \l -> l * lengthDivider, \l -> l)
			|> (\f -> pow2(lengthDivider, - length(f)))
			|> (\f -> either(f, 1.0))
		})
		|> (\f2 -> if (len / f2 < 2.0) f2 / 2.0 else f2)
		|> (\f2 -> if (len / f2 < 4.0) f2 / 2.0 else f2)
	}
}

getFirstControlPoints(rhs : [double]) -> [double] {
	n = length(rhs);
	x = ref arrayRepeat(0.0, n); // Solution vector.
	tmp = ref ^x; // Temp workspace.

	b = ref 2.0;
	x := replace(^x, 0, rhs[0] / ^b);

	fori(1, n - 1, \i -> {
		tmp := replace(^tmp, i, 1.0 / ^b);
		b := (if (i < n - 1) 4.0 else 3.5) - ^tmp[i];
		x := replace(^x, i, (rhs[i] - ^x[i - 1]) / ^b);
	});

	fori(1, n - 1, \i -> {
		x := replace(^x, n - i - 1, ^x[n - i - 1] - ^tmp[n - i] * ^x[n - i]);
	});

	^x;
}

getCurveControlPoints(knots : [Point]) -> Pair<[Point], [Point]> {
	n = length(knots) - 1;

	if (n < 1)
		Pair([], [])
	else if (n == 1) {
		// Special case: Bezier curve should be a straight line.
		// 3P1 = 2P0 + P3
		px = (2.0 * knots[0].x + knots[1].x) / 3.0;
		py = (2.0 * knots[0].y + knots[1].y) / 3.0;

		// P2 = 2P1 – P0
		Pair([Point(px, py)], [Point(2.0 * px - knots[0].x, 2.0 * py - knots[0].y)])
	} else {
		// Calculate first Bezier control points
		// Right hand side vector
		rhs = ref arrayRepeat(0.0, n);

		// Set right hand side X values
		fori(1, n - 2, \i -> {
			rhs := replace(^rhs, i, 4.0 * knots[i].x + 2.0 * knots[i + 1].x);
		});
		rhs := replace(^rhs, 0, knots[0].x + 2.0 * knots[1].x);
		rhs := replace(^rhs, n - 1, (8.0 * knots[n - 1].x + knots[n].x) / 2.0);

		// Get first control points X-values
		x = getFirstControlPoints(^rhs);

		// Set right hand side Y values
		fori(1, n - 2, \i -> {
			rhs := replace(^rhs, i, 4.0 * knots[i].y + 2.0 * knots[i + 1].y);
		});
		rhs := replace(^rhs, 0, knots[0].y + 2.0 * knots[1].y);
		rhs := replace(^rhs, n - 1, (8.0 * knots[n - 1].y + knots[n].y) / 2.0);

		// Get first control points Y-values
		y = getFirstControlPoints(^rhs);

		// Fill output arrays.
		firstControlPoints = ref arrayRepeat(zeroPoint, n);
		secondControlPoints = ref ^firstControlPoints;

		fori(0, n - 1, \i -> {
			firstControlPoints := replace(^firstControlPoints, i, Point(x[i], y[i]));
			if (i < n - 1)
				secondControlPoints :=
					replace(^secondControlPoints, i,
						Point(2.0 * knots[i + 1].x - x[i + 1],
							2.0 * knots[i + 1].y - y[i + 1]))
			else
				secondControlPoints :=
					replace(^secondControlPoints, i,
						Point((knots[n].x + x[n - 1]) / 2.0,
							(knots[n].y + y[n - 1]) / 2.0))
		});

		Pair(^firstControlPoints, ^secondControlPoints)
	}
}

standartChartColors : [MColor] =
	[MBlue(500), MOrange(500), MGreen(500), MPurple(500), MRed(500), MTeal(500),
		MLime(500), MBrown(500), MCyan(500)];

getChartColor(colors : [MColor], i : int) -> MColor {
	(if (length(colors) == 0) standartChartColors else colors)
		|> (\arr -> arr[i % length(arr)])
}