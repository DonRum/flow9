import material/measing;
import material/internal/material_theme;

export {
	// Adds a shadow to reflect the z-order as specified in
	// https://www.google.com/design/spec/what-is-material/elevation-shadows.html
	// z is between 0.0 (no shade) to 24.0
	TShadow(parent : MFocusGroup, z : Transform<double>, t : Tropic) -> Tropic;
	TEasedShadow(manager : MaterialManager, parent : MFocusGroup, z : Transform<double>, t : Tropic, duration : double) -> Tropic;

	TShadowShape(parent : MFocusGroup, z : Transform<double>, t : Tropic, style : [TGraphicsStyle], shape: ShadowShape) -> Tropic;
	TEasedShadowShape(manager : MaterialManager, parent : MFocusGroup, z : Transform<double>, t : Tropic, style : [TGraphicsStyle], duration : double, shape : ShadowShape) -> Tropic;
}

showMaterialShadows = ref !isUrlParameterFalse("material_shadows");

TShadow(parent : MFocusGroup, z : Transform<double>, t : Tropic) -> Tropic {
	TShadowShape(parent, z, t, [], ComponentShape("MEmpty"));
}

TEasedShadow(manager : MaterialManager, parent : MFocusGroup, z : Transform<double>, t : Tropic, duration : double) -> Tropic {
	TEasedShadowShape(manager, parent, z, t, [], duration, ComponentShape("MEmpty"))
}

TShadowShape(parent : MFocusGroup, zo : Transform<double>, t : Tropic, style : [TGraphicsStyle], shape : ShadowShape) -> Tropic {
	if (!^showMaterialShadows) {
		t
	} else {
		TFilter(
			fselect(zo, FLift(\z -> {
				zPercent = z / 24.;

				placement1 = lerp(0., 19., zPercent);
				color1 = lerp(0.1, 0.3, zPercent);
				blur1 = lerp(0., 38., zPercent);

				placement2 = lerp(0., 15., zPercent);
				color2 = lerp(0.24, 0.22, zPercent);
				blur2 = lerp(2., 12., zPercent);

				colorMultiplier = 1.5;
				blurMultiplier = if (js) 1. else 3.;

				if (z == 0.0) {
					[]
				} else {
					[
						// shadow by key light
						DropShadow([
							Placement(90.0, placement1),
							Color(black, color1 * colorMultiplier),
							Radius(blur1 * blurMultiplier),
						]),
						// shadow by ambient light
						// DropShadow([
						// 	Placement(90.0, placement2),
						// 	Color(black, color2),
						// 	Radius(blur2 * blurMultiplier),
						// ])
					]
				}
			})),
			(if (getLightBackground(parent) || style == [])
				t
			else
				TDecorator(
					t,
					[
						Pair(
							const(true),
							\sz ->
								TSelect(zo, \z -> {
									if (z == 0.0) {
										TEmpty()
									} else {
										overlayOpacity = \ ->
											if (z < 1.0) {
												lerp(0.0, 0.05, z)
											} else if (z < 2.0) {
												lerp(0.05, 0.07, z - 1.0)
											} else if (z < 3.0) {
												lerp(0.07, 0.08, z - 2.0)
											} else if (z < 4.0) {
												lerp(0.08, 0.09, z - 3.0)
											} else if (z < 6.0) {
												lerp(0.09, 0.11, (z - 4.0) / 2.0)
											} else if (z < 8.0) {
												lerp(0.11, 0.12, (z - 6.0) / 2.0)
											} else if (z < 12.0) {
												lerp(0.12, 0.14, (z - 8.0) / 4.0)
											} else if (z < 16.0) {
												lerp(0.14, 0.15, (z - 12.0) / 4.0)
											} else {
												lerp(0.15, 0.16, (z - 16.0) / 8.0)
											};

										switch (shape: ShadowShape) {
											ComponentShape(component):
												MShape(parent, [Fill(white), FillOpacity(overlayOpacity())], TSized(sz), component);
											RectangleShape():
												TRectangle([Fill(white), FillOpacity(overlayOpacity())], TSized(sz));
											RoundedShape(nw, ne, lw, le):
												TRounded(nw, ne, lw, le, [Fill(white), FillOpacity(overlayOpacity())], TSized(sz));
											BottomRectangleShape():
												TRectangle([Fill(white), FillOpacity(overlayOpacity())], TSized(sz));
											RoundShape():
												TSelect(fwidth(sz), \wd ->
													TCircle(wd / 2.0, [Fill(white), FillOpacity(overlayOpacity())])
												);
											TropicShape(ts):
												TEmpty();
										}
									}
								})
						)
					],
					true
				))
			|> (\f ->
				if (style == [])
					f
				else
					TDecorator(
						t,
						[
							Pair(
								const(true),
								\sz ->
									switch (shape: ShadowShape) {
										RectangleShape():
											TRectangle(style, TSized(sz));
										RoundedShape(nw, ne, lw, le):
											TRounded(nw, ne, lw, le, style, TSized(sz));
										ComponentShape(component):
											MShape(parent, style, TSized(sz), component);
										BottomRectangleShape():
											TBorder(0.0, 0.0, 0.0, -0.5, TSized(sz))
											|> (\f2 -> TRectangle(style, f2));
										RoundShape():
											TSelect(fwidth(sz), \wd -> TCircle(wd / 2.0, style));
										TropicShape(ts):
											ts;
									}
							)
						],
						false
					)
			)
		)
	}
}

TEasedShadowShape(manager : MaterialManager, parent : MFocusGroup, z0 : Transform<double>, t : Tropic, style : [TGraphicsStyle], duration : double, shape : ShadowShape) -> Tropic {
	if (parent.theme.enableAnimations) {
		zAnimation = make(fgetValue(z0));

		TShadowShape(parent, zAnimation, t, style, shape)
		|> (\f ->
			MEasingAnimation(
				manager,
				parent,
				const(duration),
				const(easingStandartCurve),
				z0,
				\v : double -> if (v != getValue(zAnimation)) Some(Pair(getValue(zAnimation), v)) else None(),
				\v, dx -> next(zAnimation, v.first + dx*(v.second - v.first)),
				[MContinueOnNone()],
				f
			)
		)
	} else {
		TShadowShape(parent, z0, t, style, shape)
	}
}