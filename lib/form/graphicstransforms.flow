import form/form;
import math/geometry;
import math/matrix;

export {
	apply2dPointTransform(p : Point, matrix : [[double]]) -> Point;
	apply2dPathTransform(path : [StaticGraphicOp], matrix : [[double]]) -> [StaticGraphicOp];
	apply2dTransform(g : Graphics, matrix : [[double]]) -> Graphics;

	make2dTransform_nop() -> [[double]];
	make2dTransform_translate(dx : double, dy : double) -> [[double]];
	make2dTransform_scale(sx : double, sy : double) -> [[double]]; // NOTE: negative scales allowed
	make2dTransform_rotate(degrees : double) -> [[double]];
	make2dTransform_rotate2(degrees : double, axisX : double, axisY : double) -> [[double]];

	// To combine matrices use multiplyMatrices() function from matrix.flow

	deconstructGraphicsPath(path : [StaticGraphicOp]) -> [StaticGraphicOp];
	StaticGraphicOp2GPolygon(ops : [StaticGraphicOp]) -> GPolygon;

	bezierCurveLength(fromX : double, fromY : double, cpX : double, cpY : double, cpX2 : double, cpY2 : double, toX : double, toY : double) -> int;
	quadraticCurveLength(fromX : double, fromY : double, cpX : double, cpY : double, toX : double, toY : double) -> int;
	bezierCurveTo(fromX : double, fromY : double, cpX : double, cpY : double, cpX2 : double, cpY2 : double, toX : double, toY : double, n : int) -> [double];
}

apply2dPointTransform(p : Point, matrix : [[double]]) -> Point {
	m = p.x * matrix[0][2] + p.y * matrix[1][2] + matrix[2][2];
	Point(
		(p.x * matrix[0][0] + p.y * matrix[1][0] + matrix[2][0]) / m,
		(p.x * matrix[0][1] + p.y * matrix[1][1] + matrix[2][1]) / m
	)
}

apply2dPathTransform(path : [StaticGraphicOp], matrix : [[double]]) -> [StaticGraphicOp] {
	map(path |> deconstructGraphicsPath, \op -> switch (op) {
		MoveTo(x, y): { p = apply2dPointTransform(Point(x,y), matrix); MoveTo(p.x, p.y) }
		LineTo(x, y): { p = apply2dPointTransform(Point(x,y), matrix); LineTo(p.x, p.y) }
		CubicBezierTo(x, y, cx, cy): { p = apply2dPointTransform(Point(x,y), matrix); cp = apply2dPointTransform(Point(cx,cy), matrix); CubicBezierTo(p.x, p.y, cp.x, cp.y) }
		QuadraticBezierTo(x, y, cx, cy): { p = apply2dPointTransform(Point(x,y), matrix); cp = apply2dPointTransform(Point(cx,cy), matrix); QuadraticBezierTo(p.x, p.y, cp.x, cp.y) }
		ClosePath(): op;
		default: op;
	})
}

apply2dTransform(g : Graphics, matrix : [[double]]) -> Graphics {
	Graphics(
		apply2dPathTransform(g.path, matrix),
		g.style
	)
}

make2dTransform_nop() {
	[
		[1.0, 0.0, 0.0],
		[0.0, 1.0, 0.0],
		[0.0, 0.0, 1.0],
	]
}

make2dTransform_translate(dx, dy) {
	[
		[1.0, 0.0, 0.0],
		[0.0, 1.0, 0.0],
		[ dx,  dy, 1.0],
	]
}


make2dTransform_scale(sx, sy) {
	[
		[ sx, 0.0, 0.0],
		[0.0,  sy, 0.0],
		[0.0, 0.0, 1.0],
	]
}

make2dTransform_rotate(degrees) {
	[
		[cosinus(degrees),   -sinus(degrees), 0.0],
		[  sinus(degrees),  cosinus(degrees), 0.0],
		[             0.0,               0.0, 1.0],
	]
}

make2dTransform_rotate2(degrees, axisX, axisY) {
	t1 = make2dTransform_translate(-axisX, -axisY);
	t2 = make2dTransform_rotate(degrees);
	t3 = make2dTransform_translate(axisX, axisY);
	multiplyMatrices(multiplyMatrices(t1, t2), t3)
}

deconstructGraphicsPath(path : [StaticGraphicOp]) -> [StaticGraphicOp] {
	deconstructGEllipse = \acc, x, y, wd, hgt -> {
		segs = 8;
		angleStep = 45.0;
		angleStepR = PI / 4.0;

		currAngleR = ref 0.0;
		angleMidR = ref 0.0;

		graphicsPathInit = [MoveTo(x, y - hgt)];

		lastX = ref 0.0;
		lastY = ref 0.0;

		concat3(
			acc,
			for(graphicsPathInit, \gp -> (length(gp) < segs + length(graphicsPathInit)), \gp -> {
				currAngleR := min(^currAngleR + angleStepR, 2.0 * PI);
				angleMidR := ^currAngleR - angleStepR * 0.5;

				lastX := x + sin(^currAngleR) * wd;
				lastY := y - cos(^currAngleR) * hgt;

				arrayPush(
					gp,
					CubicBezierTo(
						^lastX,
						^lastY,
						x + sin(^angleMidR) * wd / cos(angleStepR * 0.5),
						y - cos(^angleMidR) * hgt / cos(angleStepR * 0.5)
					)
				)
			}),
			[ClosePath()]
		)
	};

	fold(path, [], \acc : [StaticGraphicOp], p ->
		switch (p : StaticGraphicOp) {
			GRect(x, y, wd, hgt): {
				concat(
					acc,
					[
						MoveTo(x, y),
						LineTo(x + wd, y),
						LineTo(x + wd, y + hgt),
						LineTo(x, y + hgt),
						LineTo(x, y),
						ClosePath()
					]
				)
			}
			GRoundedRect(x, y, wd, hgt, r): {
				concat(
					acc,
					[
						MoveTo(r + x, y),
						LineTo(wd - r + x, y),
						CubicBezierTo(wd + x, r + y, wd + x, y),
						LineTo(wd + x, r + y),
						LineTo(wd + x, hgt - r + y),
						CubicBezierTo(wd - r + x, hgt + y, wd + x, hgt + y),
						LineTo(wd - r + x, hgt + y),
						LineTo(r + x, hgt + y),
						CubicBezierTo(x, hgt - r + y, x, hgt + y),
						LineTo(x, hgt - r + y),
						LineTo(x, r + y),
						CubicBezierTo(r + x, y, x, y),
						LineTo(r + x, y),
						ClosePath()
					]
				)
			}
			GEllipse(x, y, wd, hgt): {
				deconstructGEllipse(acc, x, y, wd, hgt);
			}
			GCircle(x, y, r): {
				deconstructGEllipse(acc, x, y, r, r);
			}
			GPolygon(polygonPath): {
				arrayPush(
					filtermapi(splitBy(polygonPath, 2), \i, xy ->
						if (length(xy) > 1) {
							if (i == 0)
								Some(MoveTo(xy[0], xy[1]))
							else
								Some(LineTo(xy[0], xy[1]))
						} else {
							None();
						}
					),
					ClosePath()
				)
			}
			default : arrayPush(acc, p);
		}
	)
}

StaticGraphicOp2GPolygon(ops : [StaticGraphicOp]) -> GPolygon {
	lastX = ref 0.0;
	lastY = ref 0.0;

	GPolygon(concatA(map(deconstructGraphicsPath(ops), \op ->
		switch (op : StaticGraphicOp) {
			CubicBezierTo(cx, cy, x, y): {
				n = quadraticCurveLength(^lastX, ^lastY, x, y, cx, cy);

				generate(1, n + 1, \i -> {
					j = i2d(i) / i2d(n);

					xa = ^lastX + ((x - ^lastX) * j);
					ya = ^lastY + ((y - ^lastY) * j);

					xx = xa + (((x + ((cx - x) * j)) - xa) * j);
					yy = ya + (((y + ((cy - y) * j)) - ya) * j);

					if (n == i) {
						lastX := xx;
						lastY := yy;
					}

					[xx, yy];
				})
				|> concatA;
			}
			QuadraticBezierTo(x, y, cx, cy): {
				n = quadraticCurveLength(^lastX, ^lastY, x, y, cx, cy);

				generate(1, n + 1, \i -> {
					j = i2d(i) / i2d(n);

					xa = ^lastX + ((x - ^lastX) * j);
					ya = ^lastY + ((y - ^lastY) * j);

					xx = xa + (((x + ((cx - x) * j)) - xa) * j);
					yy = ya + (((y + ((cy - y) * j)) - ya) * j);

					if (n == i) {
						lastX := xx;
						lastY := yy;
					}

					[xx, yy];
				})
				|> concatA;
			}
			MoveTo(x, y): {
				lastX := x;
				lastY := y;

				[x, y];
			}
			LineTo(x, y): {
				lastX := x;
				lastY := y;

				[x, y];
			}
			default: {
				[];
			}
		}
	)));

}

bezierCurveLength(fromX : double, fromY : double, cpX : double, cpY : double, cpX2 : double, cpY2 : double, toX : double, toY : double) -> int {
	n = 10;
	result = ref 0.0;
	prevX = ref fromX;
	prevY = ref fromY;

	fori(1, n, \i -> {
		t = i2d(i) / i2d(n);
		t2 = t * t;
		t3 = t2 * t;
		nt = (1.0 - t);
		nt2 = nt * nt;
		nt3 = nt2 * nt;

		x = (nt3 * fromX) + (3.0 * nt2 * t * cpX) + (3.0 * nt * t2 * cpX2) + (t3 * toX);
		y = (nt3 * fromY) + (3.0 * nt2 * t * cpY) + (3.0 * nt * t2 * cpY2) + (t3 * toY);
		dx = ^prevX - x;
		dy = ^prevY - y;
		prevX := x;
		prevY := y;

		result := ^result + sqrt((dx * dx) + (dy * dy));
	});

	floor(^result);
}

quadraticCurveLength(fromX : double, fromY : double, cpX : double, cpY : double, toX : double, toY : double) -> int {
	ax = fromX - (2.0 * cpX) + toX;
	ay = fromY - (2.0 * cpY) + toY;
	bx = (2.0 * cpX) - (2.0 * fromX);
	by = (2.0 * cpY) - (2.0 * fromY);
	a = 4.0 * ((ax * ax) + (ay * ay));
	b = 4.0 * ((ax * bx) + (ay * by));
	c = (bx * bx) + (by * by);

	s = 2.0 * sqrt(a + b + c);
	a2 = sqrt(a);
	a32 = 2.0 * a * a2;
	c2 = 2.0 * sqrt(c);
	ba = b / a2;

	floor(
		(
			(a32 * s)
				+ (a2 * b * (s - c2))
				+ (
					((4.0 * c * a) - (b * b))
					* log(((2.0 * a2) + ba + s) / (ba + c2))
				)
		) / (4.0 * a32)
	);
}

bezierCurveTo(fromX : double, fromY : double, cpX : double, cpY : double, cpX2 : double, cpY2 : double, toX : double, toY : double, n : int) -> [double] {
	path = ref [fromX, fromY];

	fori(1, n, \i -> {
		j = i2d(i) / i2d(n);

		dt = (1.0 - j);
		dt2 = dt * dt;
		dt3 = dt2 * dt;

		t2 = j * j;
		t3 = t2 * j;

		path :=
			concat(
				^path,
				[
					(dt3 * fromX) + (3.0 * dt2 * j * cpX) + (3.0 * dt * t2 * cpX2) + (t3 * toX),
					(dt3 * fromY) + (3.0 * dt2 * j * cpY) + (3.0 * dt * t2 * cpY2) + (t3 * toY)
				]
			);
	});

   	^path;
}