import fusion;
import math/transformmatrix;
import ds/array_diff;

export {
	fmap(a : Transform<[??]>, fn : (??) -> ?) -> Transform<[?]>;
	fmapu(a : Transform<[??]>, fn : (??) -> Pair<?, [() -> void]>) -> Transform<[?]>;
	fmapi(a : Transform<[??]>, fn : (int, ??) -> ?) -> Transform<[?]>;
	fmapiu(a : Transform<[??]>, fn : (Transform<int>, ??) -> Pair<?, [() -> void]>) -> Transform<[?]>;

	fiteriu(a : Transform<[??]>, fn : (Transform<int>, ??) -> [() -> void]) -> () -> void;

	fsubmap(a : Transform<[??]>, fn : (??) -> Transform<?>) -> Transform<[?]>;
	fsubmapi(a : Transform<[??]>, fn : (Transform<int>, ??) -> Transform<?>) -> Transform<[?]>;

	ffold(a : Transform<[??]>, def : Transform<?>, fn : (?, ??) -> ?) -> Transform<?>;

	ffilter(a : Transform<[?]>, fn : (?) -> bool) -> Transform<[?]>;
	ffiltermap(a : Transform<[??]>, fn : (??) -> Maybe<?>) -> Transform<[?]>;
	ffiltermapi(a : Transform<[??]>, fn : (int, ??) -> Maybe<?>) -> Transform<[?]>;

	fsubfilter(a : Transform<[?]>, fn : (?) -> Transform<bool>) -> Transform<[?]>;
	fsubfiltermap(a : Transform<[??]>, fn : (??) -> Transform<Maybe<?>>) -> Transform<[?]>;
	fsubfiltermapi(a : Transform<[??]>, fn : (Transform<int>, ??) -> Transform<Maybe<?>>) -> Transform<[?]>;

	flength(a : Transform<[?]>) -> Transform<int>;
	felementAt(a : Transform<[?]>, idx : Transform<int>, def : Transform<?>) -> Transform<?>;

	fpointaddition(p1 : Transform<Point>, p2 : Transform<Point>) -> Transform<Point>;
	fpointsubtract(p1 : Transform<Point>, p2 : Transform<Point>) -> Transform<Point>;
	fpointmultiply(p1 : Transform<Point>, p2 : Transform<Point>) -> Transform<Point>;
	fpointdivide(p1 : Transform<Point>, p2 : Transform<Point>) -> Transform<Point>;

	fwhaddition(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight>;
	fwhsubtract(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight>;
	fwhmultiply(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight>;
	fwhdivide(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight>;
	fwhmin(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight>;
	fwhmax(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight>;

	fwidthaddition(wh : Transform<WidthHeight>, width : Transform<double>) -> Transform<WidthHeight>;
	fwidthsubtract(wh : Transform<WidthHeight>, width : Transform<double>) -> Transform<WidthHeight>;
	fheightaddition(wh : Transform<WidthHeight>, height : Transform<double>) -> Transform<WidthHeight>;
	fheightsubtract(wh : Transform<WidthHeight>, height : Transform<double>) -> Transform<WidthHeight>;

	fpoint2transform(point : Transform<Point>) -> Transform<TransformMatrix>;
	fx2transform(x : Transform<double>) -> Transform<TransformMatrix>;
	fy2transform(y : Transform<double>) -> Transform<TransformMatrix>;
	ffactor2transform(factor : Transform<Factor>) -> Transform<TransformMatrix>;
	frotate2transform(rotate : Transform<double>) -> Transform<TransformMatrix>; // In degrees

	fpointfactor2transform(point : Transform<Point>, factor : Transform<Factor>) -> Transform<TransformMatrix>;
	fworldtransform(parent : Transform<TransformMatrix>, child : Transform<TransformMatrix>) -> Transform<TransformMatrix>;
	finverttransform(transform : Transform<TransformMatrix>) -> Transform<TransformMatrix>;

	fwh2bounds(wh : Transform<WidthHeight>) -> Transform<Bounds>;
	fapplytransform(wh : Transform<WidthHeight>, t : Transform<TransformMatrix>) -> Transform<Bounds>;
	fboundsapplytransform(bounds : Transform<Bounds>, tm : Transform<TransformMatrix>) -> Transform<Bounds>;
	fboundscrop(b1 : Transform<Bounds>, b2 : Transform<Bounds>) -> Transform<Bounds>;
	fboundsoverlap(b1 : Transform<Bounds>, b2 : Transform<Bounds>) -> Transform<bool>;
	flocalbounds(bounds : Transform<Bounds>, tm : Transform<TransformMatrix>) -> Transform<Bounds>;

	fIsSome(b : Transform<Maybe<?>>) -> Transform<bool>;
	fIsNone(b : Transform<Maybe<?>>) -> Transform<bool>;
	fifsome(b1 : Transform<Maybe<??>>, then1 : Transform<?>, else1 : Transform<?>)  -> Transform<?>;

	fFirstOfPair(b : Transform<Pair<?, ??>>) -> Transform<?>;
	fSecondOfPair(b : Transform<Pair<?, ??>>) -> Transform<??>;

	feq2(a : Transform<?>, b : Transform<?>) -> Transform<bool>;
	fneq2(a : Transform<?>, b : Transform<?>) -> Transform<bool>;

	fands(a : [Transform<bool>], def : bool) -> Transform<bool>;
	fOrs(a : [Transform<bool>], def : bool) -> Transform<bool>;

	ftriple(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>) -> Transform<Triple<?, ??, ???>>;
	fquadruple(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>) -> Transform<Quadruple<?, ??, ???, ????>>;

	fsome(b : Transform<??>) -> Transform<Some<??>>;

	feither(b : Transform<Maybe<?>>, alternative : Transform<??>) -> Transform<??>;

	feitherMap(b : Transform<Maybe<?>>, fn : (?) -> ??, alternative : Transform<??>) -> Transform<??>;
	feitherFn(b : Transform<Maybe<?>>, fn : (?) -> ??, alternative : () -> ??) -> Transform<??>;

	fsubeitherMap(b : Transform<Maybe<?>>, fn : (?) -> Transform<??>, alternative : Transform<??>) -> Transform<??>;
	fsubeitherFn(b : Transform<Maybe<?>>, fn : (?) -> Transform<??>, alternative : () -> Transform<??>) -> Transform<??>;

	fmaybeBind(b : Transform<Maybe<?>>, fn : (?) -> Maybe<??>) -> Transform<Maybe<??>>;
	fmaybeMap(b : Transform<Maybe<?>>, fn : (?) -> ??) -> Transform<Maybe<??>>;

	fsubmaybeBind(b : Transform<Maybe<?>>, fn : (?) -> Transform<Maybe<??>>) -> Transform<Maybe<??>>;
	fsubmaybeMap(b : Transform<Maybe<?>>, fn : (?) -> Transform<??>) -> Transform<Maybe<??>>;

	forder(b : Transform<[?]>, order : Transform<[int]>) -> Transform<[?]>;
	fdeorder(b : Transform<[?]>, order : Transform<[int]>) -> Transform<[?]>;

	fpprint(title : string) -> (Transform<?>) -> Transform<?>;

	ffuse(t : Transform<?>) -> Pair<Behaviour<?>, [() -> () -> void]>;
	applyallsubs(array : [() -> () -> void]) -> [() -> void];

	fselectdelay(b : Transform<?>, fn : (?) -> int) -> Transform<??>;
	flerp(start : double, end : double, t : Transform<double>) -> Transform<double>;

	flookupTree(tree : Transform<Tree<?, ??>>, key : Transform<?>) -> Transform<Maybe<??>>;
	fremoveFromTree(tree : Transform<Tree<?, ??>>, key : Transform<?>) -> Transform<Tree<?, ??>>;

	// Advised dispose helpers
	initUnsM() -> ref Maybe<() -> void>;
	setUnsM(uns : ref Maybe<() -> void>, v : () -> void) -> void;
	dispUnsM(uns : ref Maybe<() -> void>) -> void;
}

fmap(a : Transform<[??]>, fn : (??) -> ?) -> Transform<[?]> {
	input = ref [];
	output = ref [];

	fselect(a, FLift(\a0 -> {
		iter(arrayDiff(^input, a0, false) |> reverseA, \op ->
			switch (op : ArrayOperation) {
				ArrayNop(x, y): {
					// output := moveElement(^output, x, y);
				}
				ArrayInsert(x, y, v): {
					output := insertArray(^output, y, fn(v));
				}
				ArrayReplace(x, y, v): {
					output := replace(^output, y, fn(v));
				}
				ArrayRemove(x, y): {
					output := removeIndex(^output, y);
				}
			}
		);

		input := a0;
		^output;
	}));
}

fmapu(a : Transform<[??]>, fn : (??) -> Pair<?, [() -> void]>) -> Transform<[?]> {
	nested = ref false;
	input = ref [];
	output = ref [];
	disposers = ref [];

	fdisposable(
		fselect(a, FLift(\a0 -> {
			if (!^nested) {
				nested := true;
				diff = arrayDiff(^input, a0, false) |> reverseA;

				// Call disposers before initializers
				iter(diff, \op -> {
					switch (op : ArrayOperation) {
						ArrayNop(x, y): {
							// d = ^disposers[x];

							// disposers := insertArray(removeIndex(^disposers, x), y, d);
						}
						ArrayInsert(x, y, v): {
							disposers := insertArray(^disposers, y, []);
						}
						ArrayReplace(x, y, v): {
							if (length(^disposers) > y) {
								applyall(^disposers[y]);
							}

							disposers := replace(^disposers, y, []);
						}
						ArrayRemove(x, y): {
							if (length(^disposers) > y) {
								applyall(^disposers[y]);
							}

							disposers := removeIndex(^disposers, y);
						}
					}
				});

				iter(diff, \op ->
					switch (op : ArrayOperation) {
						ArrayNop(x, y): {
							// d = ^output[x];

							// output := insertArray(removeIndex(^output, x), y, d);
						}
						ArrayInsert(x, y, v): {
							d = fn(v);

							output := insertArray(^output, y, d.first);
							disposers := replace(^disposers, y, d.second);
						}
						ArrayReplace(x, y, v): {
							d = fn(v);

							output := replace(^output, y, d.first);
							disposers := replace(^disposers, y, d.second);
						}
						ArrayRemove(x, y): {
							output := removeIndex(^output, y);
						}
					}
				);

				input := a0;
				nested := false;
			}

			^output;
		})),
		\ -> {
			nested := true;
			map(^disposers, applyall);

			input := [];
			output := [];
			disposers := [];
			nested := false;
		}
	)
}

fmapi(a : Transform<[??]>, fn : (int, ??) -> ?) -> Transform<[?]> {
	input = ref [];
	output = ref [];

	fselect(a, FLift(\a0 -> {
		newOutput = ref [];

		iter(arrayDiff(^input, a0, true) |> reverseA, \op -> {
			switch (op : ArrayOperation) {
				ArrayNop(x, y): {
					if (x != y) {
						newOutput := insertArray(^newOutput, y, fn(y, ^input[x]));
					} else {
						newOutput := insertArray(^newOutput, y, ^output[x]);
					}
				}
				ArrayInsert(x, y, v): {
					newOutput := insertArray(^newOutput, y, fn(y, v));
				}
				ArrayReplace(x, y, v): {
					newOutput := replace(^newOutput, y, fn(y, v));
				}
				ArrayRemove(x, y): {
					newOutput := removeIndex(^newOutput, y);
				}
			}
		});

		output := ^newOutput;
		input := a0;
		^output;
	}));
}

fmapiu(a : Transform<[??]>, fn : (Transform<int>, ??) -> Pair<?, [() -> void]>) -> Transform<[?]> {
	nested = ref false;
	input = ref [];
	output = ref [];
	disposers = ref [];
	indexes = ref [];

	fdisposable(
		fselect(a, FLift(\a0 -> {
			if (!^nested) {
				nested := true;
				diff = arrayDiff(^input, a0, false) |> reverseA;

				// Call disposers before initializers
				iter(diff, \op -> {
					switch (op : ArrayOperation) {
						ArrayNop(x, y): {
							// d = ^disposers[x];

							// disposers := insertArray(removeIndex(^disposers, x), y, d);
						}
						ArrayInsert(x, y, v): {
							disposers := insertArray(^disposers, y, []);
						}
						ArrayReplace(x, y, v): {
							if (length(^disposers) > y) {
								applyall(^disposers[y]);
							}

							disposers := replace(^disposers, y, []);
						}
						ArrayRemove(x, y): {
							if (length(^disposers) > y) {
								applyall(^disposers[y]);
							}

							disposers := removeIndex(^disposers, y);
						}
					}
				});

				iter(diff, \op -> {
					switch (op : ArrayOperation) {
						ArrayNop(x, y): {
							// index = ^indexes[x];
							// d = ^output[x];

							// indexes := insertArray(removeIndex(^indexes, x), y, index);
							// output := insertArray(removeIndex(^output, x), y, d);
						}
						ArrayInsert(x, y, v): {
							index = make(y);
							d = fn(index, v);

							indexes := insertArray(^indexes, y, index);
							output := insertArray(^output, y, d.first);
							disposers := replace(^disposers, y, d.second);
						}
						ArrayReplace(x, y, v): {
							index = ^indexes[y];
							d = fn(index, v);

							output := replace(^output, y, d.first);
							disposers := replace(^disposers, y, d.second);
						}
						ArrayRemove(x, y): {
							indexes := removeIndex(^indexes, y);
							output := removeIndex(^output, y);
						}
					}
				});

				iteri(^indexes, \i, ii -> nextDistinct(ii, i));

				input := a0;
				nested := false;
			}

			^output;
		})),
		\ -> {
			nested := true;
			map(^disposers, applyall);

			input := [];
			output := [];
			disposers := [];
			indexes := [];
			nested := false;
		}
	);
}

fiteriu(a : Transform<[??]>, fn : (Transform<int>, ??) -> [() -> void]) -> () -> void {
	makeSubscribe(fmapiu(a, \i, v -> Pair(false, fn(i, v))), nop1)();
}

fsubmap(a : Transform<[??]>, fn : (??) -> Transform<?>) -> Transform<[?]> {
	nested = ref false;
	input = ref [];
	output = make([]);
	disposers = ref [];
	indexes = ref [];

	fdisposable(
		fsubselect(a, FLift(\a0 -> {
			if (!^nested) {
				nested := true;
				diff = arrayDiff(^input, a0, false) |> reverseA;

				// Call disposers before initializers
				iter(diff, \op -> {
					switch (op : ArrayOperation) {
						ArrayNop(x, y): {}
						ArrayInsert(x, y, v): {
							disposers := insertArray(^disposers, y, nop);
						}
						ArrayReplace(x, y, v): {
							if (length(^disposers) > y) {
								^disposers[y]();
							}

							disposers := replace(^disposers, y, nop);
						}
						ArrayRemove(x, y): {
							if (length(^disposers) > y) {
								^disposers[y]();
							}

							disposers := removeIndex(^disposers, y);
						}
					}
				});

				iter(diff, \op ->
					switch (op : ArrayOperation) {
						ArrayNop(x, y): {}
						ArrayInsert(x, y, v): {
							index = make(y);
							d = fn(v);

							indexes := insertArray(^indexes, y, index);
							next(output, insertArray(getValue(output), y, fgetValue(d)));
							disposers :=
								replace(
									^disposers,
									y,
									makeSubscribe2(d, \v0 -> next(output, replace(getValue(output), fgetValue(index), v0)))()
								);
						}
						ArrayReplace(x, y, v): {
							index = ^indexes[y];
							d = fn(v);

							next(output, replace(getValue(output), y, fgetValue(d)));
							disposers :=
								replace(
									^disposers,
									y,
									makeSubscribe2(d, \v0 -> next(output, replace(getValue(output), fgetValue(index), v0)))()
								);
						}
						ArrayRemove(x, y): {
							indexes := removeIndex(^indexes, y);
							next(output, removeIndex(getValue(output), y));
						}
					}
				);

				iteri(^indexes, \i, ii -> nextDistinct(ii, i));

				input := a0;
				nested := false;
			}

			output;
		})),
		\ -> {
			nested := true;
			applyall(^disposers);

			input := [];
			next(output, []);
			disposers := [];
			indexes := [];
			nested := false;
		}
	);
}

fsubmapi(a : Transform<[??]>, fn : (Transform<int>, ??) -> Transform<?>) -> Transform<[?]> {
	nested = ref false;
	input = ref [];
	output = make([]);
	disposers = ref [];
	indexes = ref [];

	fdisposable(
		fsubselect(a, FLift(\a0 -> {
			if (!^nested) {
				nested := true;
				diff = arrayDiff(^input, a0, false) |> reverseA;

				// Call disposers before initializers
				iter(diff, \op -> {
					switch (op : ArrayOperation) {
						ArrayNop(x, y): {}
						ArrayInsert(x, y, v): {
							disposers := insertArray(^disposers, y, nop);
						}
						ArrayReplace(x, y, v): {
							if (length(^disposers) > y) {
								^disposers[y]();
							}

							disposers := replace(^disposers, y, nop);
						}
						ArrayRemove(x, y): {
							if (length(^disposers) > y) {
								^disposers[y]();
							}

							disposers := removeIndex(^disposers, y);
						}
					}
				});

				iter(diff, \op ->
					switch (op : ArrayOperation) {
						ArrayNop(x, y): {}
						ArrayInsert(x, y, v): {
							index = make(y);
							d = fn(index, v);

							indexes := insertArray(^indexes, y, index);
							next(output, insertArray(getValue(output), y, fgetValue(d)));
							disposers :=
								replace(
									^disposers,
									y,
									makeSubscribe2(d, \v0 -> next(output, replace(getValue(output), fgetValue(index), v0)))()
								);
						}
						ArrayReplace(x, y, v): {
							index = ^indexes[y];
							d = fn(index, v);

							next(output, replace(getValue(output), y, fgetValue(d)));
							disposers :=
								replace(
									^disposers,
									y,
									makeSubscribe2(d, \v0 ->
										next(output, replace(getValue(output), fgetValue(index), v0))
									)()
								);
						}
						ArrayRemove(x, y): {
							indexes := removeIndex(^indexes, y);
							next(output, removeIndex(getValue(output), y));
						}
					}
				);

				iteri(^indexes, \i, ii -> nextDistinct(ii, i));

				input := a0;
				nested := false;
			}

			output;
		})),
		\ -> {
			nested := true;
			applyall(^disposers);

			input := [];
			next(output, []);
			disposers := [];
			indexes := [];
			nested := false;
		}
	);
}

ffold(a : Transform<[??]>, def : Transform<?>, fn : (?, ??) -> ?) -> Transform<?> {
	nested = ref false;
	input = ref [];
	output : DynamicBehaviour<[Transform<?>]> = make([def]);
	disposers = ref [];
	indexes = ref [];

	fdisposable(
		fsubselect(a, FLift(\a0 -> {
			if (!^nested) {
				nested := true;
				diff = arrayDiff(^input, a0, false) |> reverseA;

				iter(diff, \op ->
					switch (op : ArrayOperation) {
						ArrayNop(x, y): {}
						ArrayInsert(x, y, v): {
							index = make(y);

							indexes := insertArray(^indexes, y, index);
							next(
								output,
								insertArray(
									getValue(output),
									y + 1,
									fsubselect(felementAt(output, index, const(def)), FLift(\el -> fselect(el, FLift(\e -> fn(e, v)))))
								)
							);
						}
						ArrayReplace(x, y, v): {
							index = ^indexes[y];

							next(
								output,
								replace(
									getValue(output),
									y + 1,
									fsubselect(felementAt(output, index, const(def)), FLift(\el -> fselect(el, FLift(\e -> fn(e, v)))))
								)
							);
						}
						ArrayRemove(x, y): {
							indexes := removeIndex(^indexes, y);
							next(output, removeIndex(getValue(output), y + 1));
						}
					}
				);

				iteri(^indexes, \i, ii -> nextDistinct(ii, i));

				input := a0;
				nested := false;
			}

			fsubselect(felementAt(output, const(length(getValue(output)) - 1), const(def)), idfn |> FLift);
		})),
		\ -> {
			nested := true;
			applyall(^disposers);

			input := [];
			next(output, []);
			disposers := [];
			indexes := [];
			nested := false;
		}
	);
}

ffilter(v : Transform<[?]>, fn : (?) -> bool) -> Transform<[?]> {
	ffiltermap(v, \vv -> if (fn(vv)) Some(vv) else None());
}

ffiltermap(v : Transform<[??]>, fn : (??) -> Maybe<?>) -> Transform<[?]> {
	fselect(fmap(v, fn), FLift(\vv -> filtermap(vv, idfn)));
}

ffiltermapi(v : Transform<[??]>, fn : (int, ??) -> Maybe<?>) -> Transform<[?]> {
	fselect(fmapi(v, fn), FLift(\vv -> filtermap(vv, idfn)));
}

fsubfilter(v : Transform<[?]>, fn : (?) -> Transform<bool>) -> Transform<[?]> {
	fsubfiltermap(v, \vv -> fif(fn(vv), const(Some(vv)), const(None())));
}

fsubfiltermap(v : Transform<[??]>, fn : (??) -> Transform<Maybe<?>>) -> Transform<[?]> {
	fselect(fsubmap(v, fn), FLift(\vv -> filtermap(vv, idfn)));
}

fsubfiltermapi(v : Transform<[??]>, fn : (Transform<int>, ??) -> Transform<Maybe<?>>) -> Transform<[?]> {
	fselect(fsubmapi(v, fn), FLift(\vv -> filtermap(vv, idfn)));
}

flength(v : Transform<[?]>) -> Transform<int> {
	fselect(v, FLift(length))
}

felementAt(a : Transform<[?]>, idx : Transform<int>, def : Transform<?>) -> Transform<?> {
	fselect3(a, idx, def, \v, i, d -> elementAt(v, i, d))
}

fpointaddition(p1 : Transform<Point>, p2 : Transform<Point>) -> Transform<Point> {
	fselect2(p1, p2, FLift2(\v1, v2 -> Point(v1.x + v2.x, v1.y + v2.y)));
}

fpointsubtract(p1 : Transform<Point>, p2 : Transform<Point>) -> Transform<Point> {
	fselect2(p1, p2, FLift2(\v1, v2 -> Point(v1.x - v2.x, v1.y - v2.y)));
}

fpointmultiply(p1 : Transform<Point>, p2 : Transform<Point>) -> Transform<Point> {
	fselect2(p1, p2, FLift2(\v1, v2 -> Point(v1.x * v2.x, v1.y * v2.y)));
}

fpointdivide(p1 : Transform<Point>, p2 : Transform<Point>) -> Transform<Point> {
	fselect2(p1, p2, FLift2(\v1, v2 -> Point(v1.x / v2.x, v1.y / v2.y)));
}

fwhaddition(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight> {
	fselect2(wh1, wh2, FLift2(\v1, v2 -> WidthHeight(v1.width + v2.width, v1.height + v2.height)));
}

fwhsubtract(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight> {
	fselect2(wh1, wh2, FLift2(\v1, v2 -> WidthHeight(v1.width - v2.width, v1.height - v2.height)));
}

fwhmultiply(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight> {
	fselect2(wh1, wh2, FLift2(\v1, v2 -> WidthHeight(v1.width * v2.width, v1.height * v2.height)));
}

fwhdivide(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight> {
	fselect2(wh1, wh2, FLift2(\v1, v2 -> WidthHeight(v1.width / v2.width, v1.height / v2.height)));
}

fwhmin(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight> {
	fselect2(wh1, wh2, FLift2(\v1, v2 -> WidthHeight(min(v1.width, v2.width), min(v1.height, v2.height))));
}

fwhmax(wh1 : Transform<WidthHeight>, wh2 : Transform<WidthHeight>) -> Transform<WidthHeight> {
	fselect2(wh1, wh2, FLift2(\v1, v2 -> WidthHeight(max(v1.width, v2.width), max(v1.height, v2.height))));
}

fwidthaddition(wh : Transform<WidthHeight>, width : Transform<double>) -> Transform<WidthHeight> {
	fselect2(wh, width, FLift2(\v, wd -> WidthHeight(v.width + wd, v.height)));
}

fwidthsubtract(wh : Transform<WidthHeight>, width : Transform<double>) -> Transform<WidthHeight> {
	fselect2(wh, width, FLift2(\v, wd -> WidthHeight(v.width - wd, v.height)));
}

fheightaddition(wh : Transform<WidthHeight>, height : Transform<double>) -> Transform<WidthHeight> {
	fselect2(wh, height, FLift2(\v, hgt -> WidthHeight(v.width, v.height + hgt)));
}

fheightsubtract(wh : Transform<WidthHeight>, height : Transform<double>) -> Transform<WidthHeight> {
	fselect2(wh, height, FLift2(\v, hgt -> WidthHeight(v.width, v.height - hgt)));
}

fpoint2transform(point : Transform<Point>) -> Transform<TransformMatrix> {
	fselect(point, FLift(\v -> {
		TransformMatrix(
			1.0,
			0.0,
			0.0,
			1.0,
			v.x,
			v.y
		)
	}));
}

fx2transform(x : Transform<double>) -> Transform<TransformMatrix> {
	fselect(x, FLift(\v -> {
		TransformMatrix(
			1.0,
			0.0,
			0.0,
			1.0,
			v,
			0.0
		)
	}));
}

fy2transform(y : Transform<double>) -> Transform<TransformMatrix> {
	fselect(y, FLift(\v -> {
		TransformMatrix(
			1.0,
			0.0,
			0.0,
			1.0,
			0.0,
			v
		)
	}));
}

ffactor2transform(factor : Transform<Factor>) -> Transform<TransformMatrix> {
	fselect(factor, FLift(\v -> {
		TransformMatrix(
			v.x,
			0.0,
			0.0,
			v.y,
			0.0,
			0.0
		)
	}));
}

frotate2transform(rotate : Transform<double>) -> Transform<TransformMatrix> {
	fselect(rotate, FLift(\v -> {
		cosv = cosinus(v);
		sinv = sinus(v);

		TransformMatrix(
			cosv,
			sinv,
			-sinv,
			cosv,
			0.0,
			0.0
		)
	}));
}

fpointfactor2transform(point : Transform<Point>, factor : Transform<Factor>) -> Transform<TransformMatrix> {
	fselect2(point, factor, FLift2(\p, f -> {
		TransformMatrix(
			f.x,
			0.0,
			0.0,
			f.y,
			p.x,
			p.y
		)
	}));
}

fworldtransform(parent : Transform<TransformMatrix>, child : Transform<TransformMatrix>) -> Transform<TransformMatrix> {
	fselect2(parent, child, FLift2(\pt, lt -> {
		TransformMatrix(
			(lt.a * pt.a) + (lt.b * pt.c),
			(lt.a * pt.b) + (lt.b * pt.d),
			(lt.c * pt.a) + (lt.d * pt.c),
			(lt.c * pt.b) + (lt.d * pt.d),
			(lt.tx * pt.a) + (lt.ty * pt.c) + pt.tx,
			(lt.tx * pt.b) + (lt.ty * pt.d) + pt.ty
		)
	}));
}

finverttransform(transform : Transform<TransformMatrix>) -> Transform<TransformMatrix> {
	fselect(transform, FLift(\tr -> {
		n = tr.a * tr.d - tr.b * tr.c;

		TransformMatrix(
			tr.d / n,
			-tr.b / n,
			-tr.c / n,
			tr.a / n,
			((tr.c * tr.ty) - (tr.d * tr.tx)) / n,
			-((tr.a * tr.ty) - (tr.b * tr.tx)) / n
		)
	}));
}

fwh2bounds(wh : Transform<WidthHeight>) -> Transform<Bounds> {
	fselect(wh, FLift(\v -> Bounds(0., 0., v.width, v.height)));
}

fapplytransform(box : Transform<WidthHeight>, tm : Transform<TransformMatrix>) -> Transform<Bounds> {
	fselect2(box, tm, FLift2(\wh, t -> Bounds(t.tx, t.ty, wh.width * t.a + wh.height * t.c + t.tx, wh.width * t.b + wh.height * t.d + t.ty)));
}

fboundsapplytransform(bounds : Transform<Bounds>, tm : Transform<TransformMatrix>) -> Transform<Bounds> {
	fselect2(bounds, tm, FLift2(\b, t ->
		Bounds(
			b.minX * t.a + b.minY * t.c + t.tx,
			b.minX * t.b + b.minY * t.d + t.ty,
			b.maxX * t.a + b.maxY * t.c + t.tx,
			b.maxX * t.b + b.maxY * t.d + t.ty
		)
	));
}

fboundscrop(b1 : Transform<Bounds>, b2 : Transform<Bounds>) -> Transform<Bounds> {
	if (b1 == const(zeroBounds)) {
		b2;
	} else if (b2 == const(zeroBounds)) {
		b1;
	} else {
		fselect2(b1, b2, FLift2(\v1, v2 -> Bounds(max(v1.minX, v2.minX), max(v1.minY, v2.minY), min(v1.maxX, v2.maxX), min(v1.maxY, v2.maxY))));
	}
}

fboundsoverlap(b1 : Transform<Bounds>, b2 : Transform<Bounds>) -> Transform<bool> {
	if (b1 == const(zeroBounds) || b2 == const(zeroBounds)) {
		const(true)
	} else {
		fselect2(b1, b2, FLift2(\v1, v2 -> {
			max(v1.minX, v1.maxX) >= min(v2.minX, v2.maxX) &&
				min(v1.minX, v1.maxX) <= max(v2.minX, v2.maxX) &&
				max(v1.minY, v1.maxY) >= min(v2.minY, v2.maxY) &&
				min(v1.minY, v1.maxY) <= max(v2.minY, v2.maxY)
		}));
	}
}

flocalbounds(bounds : Transform<Bounds>, tm : Transform<TransformMatrix>) -> Transform<Bounds> {
	fselect2(bounds, tm, FLift2(\b, t ->
		Bounds(
			(b.minX - t.tx) / t.a,
			(b.minY - t.ty) / t.d,
			(b.maxX - t.tx) / t.a,
			(b.maxY - t.ty) / t.d
		)
	));
}

fIsSome(b : Transform<Maybe<?>>) -> Transform<bool> {
	fselect(b, FLift(isSome));
}

fIsNone(b : Transform<Maybe<?>>) -> Transform<bool> {
	fselect(b, FLift(isNone));
}

fifsome(b1 : Transform<Maybe<??>>, then1 : Transform<?>, else1 : Transform<?>)  -> Transform<?> {
	fif(fIsSome(b1), then1, else1)
}

fFirstOfPair(b : Transform<Pair<?, ??>>) -> Transform<?> {
	fselect(b, FLift(\p : Pair<?, ??> -> p.first))
}

fSecondOfPair(b : Transform<Pair<?, ??>>) -> Transform<??> {
	fselect(b, FLift(\p : Pair<?, ??> -> p.second))
}

feq2(a : Transform<?>, b : Transform<?>) -> Transform<bool> {
	fselect2(a, b, FLift2(\v1, v2 -> v1 == v2))
}

fneq2(a : Transform<?>, b : Transform<?>) -> Transform<bool> {
	fnot(feq2(a, b))
}

fFoldBool(a : [Transform<bool>], def : bool, fn : (Transform<bool>, Transform<bool>) -> Transform<bool>) -> Transform<bool> {
	l = length(a);
	if (l == 0) const(def)
	else if (l == 1) a[0]
	else if (l == 2) fn(a[0], a[1])
	else {
		half = l / 2;
		fn(fFoldBool(take(a, half), def, fn), fFoldBool(tailFrom(a, half), def, fn))
	}
}

fands(a : [Transform<bool>], def : bool) -> Transform<bool> {
	fFoldBool(a, def, fand);
}

fOrs(a : [Transform<bool>], def : bool) -> Transform<bool> {
	fFoldBool(a, def, fOr);
}

ftriple(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>) -> Transform<Triple<?, ??, ???>> {
	fselect3(v1, v2, v3, \a1, a2, a3 -> Triple(a1, a2, a3));
}

fquadruple(v1 : Transform<?>, v2 : Transform<??>, v3 : Transform<???>, v4 : Transform<????>) -> Transform<Quadruple<?, ??, ???, ????>> {
	fselect4(v1, v2, v3, v4, \a1, a2, a3, a4 -> Quadruple(a1, a2, a3, a4));
}

fsome(b : Transform<??>) -> Transform<Some<??>> {
	fselect(b, FLift(\v -> Some(v)));
}

feither(b : Transform<Maybe<?>>, alternative : Transform<??>) -> Transform<??> {
	fsubselect(b, FLift(\v ->
		eitherMap(
			v,
			\v0 -> const(v0),
			alternative
		)
	));
}

feitherMap(b : Transform<Maybe<?>>, fn : (?) -> ??, alternative : Transform<??>) -> Transform<??> {
	fsubselect(b, FLift(\v ->
		eitherMap(
			v,
			\v0 -> const(fn(v0)),
			alternative
		)
	));
}

feitherFn(b : Transform<Maybe<?>>, fn : (?) -> ??, alternative : () -> ??) -> Transform<??> {
	fselect(b, FLift(\v ->
		eitherFn(
			v,
			fn,
			alternative
		)
	));
}

fsubeitherMap(b : Transform<Maybe<?>>, fn : (?) -> Transform<??>, alternative : Transform<??>) -> Transform<??> {
	fsubselect(b, FLift(\v ->
		eitherMap(
			v,
			fn,
			alternative
		)
	));
}

fsubeitherFn(b : Transform<Maybe<?>>, fn : (?) -> Transform<??>, alternative : () -> Transform<??>) -> Transform<??> {
	fsubselect(b, FLift(\v ->
		eitherFn(
			v,
			fn,
			alternative
		)
	));
}

fmaybeBind(b : Transform<Maybe<?>>, fn : (?) -> Maybe<??>) -> Transform<Maybe<??>> {
	fselect(b, FLift(\v -> maybeBind(v, fn)));
}

fmaybeMap(b : Transform<Maybe<?>>, fn : (?) -> ??) -> Transform<Maybe<??>> {
	fmaybeBind(b, \v -> Some(fn(v)));
}

fsubmaybeBind(b : Transform<Maybe<?>>, fn : (?) -> Transform<Maybe<??>>) -> Transform<Maybe<??>> {
	fsubselect(b, FLift(\v -> eitherMap(v, fn, const(None()))));
}

fsubmaybeMap(b : Transform<Maybe<?>>, fn : (?) -> Transform<??>) -> Transform<Maybe<??>> {
	fsubselect(b, FLift(\v -> eitherMap(v, \v0 -> fselect(fn(v0), FLift(\v1 -> Some(v1))), const(None()))));
}

forder(b : Transform<[?]>, order : Transform<[int]>) -> Transform<[?]> {
	fselect2(b, order, FLift2(\v, o -> fold(o, [], \acc, i -> if (i >= 0 && i < length(v)) arrayPush(acc, v[i]) else acc)))
}

fdeorder(b : Transform<[?]>, order : Transform<[int]>) -> Transform<[?]> {
	fselect2(b, order, FLift2(\v, o -> foldi(v, [], \i, acc, it -> {
		id = findiDef(o, \oi -> oi == i, -1);

		if (id >= 0 && id < length(v))
			arrayPush(acc, v[id])
		else
			acc;
	})))
}

ffuse(t : Transform<?>) -> Pair<Behaviour<?>, [() -> () -> void]> {
	switch (t) {
		ConstBehaviour(v): Pair(t, []);
		default: {
			b = make(fgetValue(t));

			Pair(b, [\ -> fconnect(t, b)])
		}
	}
}

applyallsubs(array : [() -> () -> void]) -> [() -> void] {
	map(array, apply0)
}

fselectdelay(b : Transform<?>, fn : (?) -> int) -> Transform<??> {
	provider : ref Maybe<DynamicBehaviour<?>> = ref None();
	uns = ref nop;

	fsubselect(b, FLift(\v -> {
		^uns();
		r = fn(v);

		eitherFn(
			^provider,
			\p -> {
				uns :=
					if (r > 0) {
						interruptibleTimer(r, \ -> nextDistinct(p, v));
					} else {
						nextDistinct(p, v);
						nop;
					};

				p;
			},
			\ -> {
				provider := Some(make(v));
				either(^provider, const(v));
			}
		);
	}))
}

flerp(start : double, end : double, t : Transform<double>) -> Transform<double> {
	fselect(t, FLift(\v -> (1.0 - v) * start + v * end));
}

flookupTree(tree : Transform<Tree<?, ??>>, key : Transform<?>) -> Transform<Maybe<??>> {
	fselect2(tree, key, FLift2(\t, k -> lookupTree(t, k)));
}

fremoveFromTree(tree : Transform<Tree<?, ??>>, key : Transform<?>) -> Transform<Tree<?, ??>> {
	fselect2(tree, key, FLift2(\t, k -> removeFromTree(t, k)));
}

initUnsM() -> ref Maybe<() -> void> {
	ref None()
}

setUnsM(uns : ref Maybe<() -> void>, v : () -> void) -> void {
	uns := Some(v);
}

dispUnsM(uns : ref Maybe<() -> void>) -> void {
	// a version of dispUns() without functions comparison
	switch (^uns) {
		Some(f): {
			f();
			uns := None();
		}
		None(): {}
	}
}

// For debug purposes

fpprint(title : string) -> (Transform<?>) -> Transform<?> {
	\tr -> {
		fsubscribe(tr, \v -> pprint(title + " : ")(v) |> ignore);
		tr
	}
}