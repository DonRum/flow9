// Â© Copyright 2014 Area9 Technologies.

import ds/tree;
import math/math;

export {
	// Compares two arrays, and returns a list of operations to apply to change the old to the new
	arrayDiff(old : [?], new : [?], fullProtocol : bool) -> [ArrayOperation<?>];
	arrayDiffWithSwapp(old : [?], new : [?], fullProtocol : bool) -> [ArrayOperationWithSwapp<?>];

	// reverse protocol, for backward compatibility
	arrayDiffReversed(old : [?], new : [?], fullProtocol : bool) -> [ArrayOperation<?>];

	// Livenshtein-based protocol
	applyProtocol(
		source : [?],
		protocol : [ArrayOperation<?>],
		insertFn : (newValue : ?) -> ?, //
		replaceFn : (oldValue : ?, newValue : ?) -> ?,
		removeFn : (oldValue : ?) -> Maybe<?> // if None() then element will be removed, if Some - replaced
	) -> [?];

	// Damerhau-Livenshtein - based protocol (accepts Livenshtein-based protocol too because it is subset)
	applyProtocolWithSwapp(
		source : [?],
		protocol : [ArrayOperationWithSwapp<?>],
		insertFn : (newValue : ?) -> ?, //
		replaceFn : (oldValue : ?, newValue : ?) -> ?,
		removeFn : (oldValue : ?) -> Maybe<?>, // if None() then element will be removed, if Some - replaced
		swapFn : (Pair<?, ?>) -> Pair<?, ?>
	) -> [?];

	applyProtocolInvariant(source : [?], protocol : [ArrayOperationWithSwapp<?>]) -> [?];

	// Levenshtein, see https://en.wikipedia.org/wiki/Levenshtein_distance
	ArrayOperation<?> ::= ArrayNop, ArrayInsert<?>, ArrayReplace<?>, ArrayRemove;
		ArrayNop(oldindex : int, newindex : int);
		ArrayInsert(oldindex : int, newindex : int, value : ?);
		ArrayReplace(oldindex : int, newindex : int, value : ?);
		ArrayRemove(oldindex : int, newindex : int);

	// Damerau-Levenshtein, see https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance
	ArrayOperationWithSwapp<?> ::= ArrayOperation<?>, ArraySwap;
		ArraySwap(oldindex : int, newindex : int, value : Pair<?, ?>);
}

arrayDiff(s : [?], t : [?], fullProtocol : bool) -> [ArrayOperation<?>] {
	filtermap(
		arrayDiffExt(s, t, fullProtocol, false),
		\p : ArrayOperationWithSwapp<?> -> {
			switch (p) {
				ArrayOperation(): Some(p);
				default: None();
			}
		}
	)
}

arrayDiffWithSwapp(s : [?], t : [?], fullProtocol : bool) -> [ArrayOperationWithSwapp<?>] {
	arrayDiffExt(s, t, fullProtocol, true)
}

// Constructs a protocol "script" which changes one array to another.
// fullProtocol leaves ArrayNop operations in the result (false by default)
// Basically, this is Levenshtein
arrayDiffExt(s : [?], t : [?], fullProtocol : bool, swapp : bool) -> [ArrayOperationWithSwapp<?>] {
	m = length(s);
	n = length(t);

	// Initialize the matrix of costs and operations
	d : [[ref Pair<int, ArrayOperationWithSwapp>]] = generate(0, m + 1, \i -> {
			generate(0, n + 1, \j -> {
				p : Pair<int, ArrayOperationWithSwapp> = if (i == 0 && j != 0) {
					Pair(j, ArrayInsert(0, j - 1, t[j - 1]));
				} else {
					if (j == 0 && i != 0) {
						Pair(i, ArrayRemove(i - 1, 0));
					} else {
						Pair(0, ArrayNop(-1, -1));
					}
				};
				ref p
			});
		});

	dij = \ii, jj -> {
		^((d[ii])[jj]).first;
	}

	fori(1, m, \i -> { // s
		si = s[i - 1];
		fori(1, n, \j -> { // t
			tj = t[j - 1];
			if (si == tj) {
				// Equal as is. No change
				d[i][j] := Pair(dij(i - 1, j - 1), ArrayNop(i-1, j-1));
			} else {
				delcost = dij(i - 1, j) + 1;
				inscost = dij(i, j - 1) + 1;
				repcost = dij(i - 1, j - 1) + 1;

				cost = min3(
					delcost,  // Deletion
					inscost, // Insertion
					repcost // Replacement
				);

				d[i][j] := Pair(cost,
					if (cost == repcost) {
						ArrayReplace(i - 1, j - 1, tj)
					} else if (cost == inscost) {
						ArrayInsert(i, j - 1, tj);
					} else if (cost == delcost) {
						ArrayRemove(i - 1, j)
					} else {
						ArrayNop(i-1, j-1)
					}
				);

				if (swapp && i > 1 && j > 1) {
					si2 = s[i - 2];
					tj2 = t[j - 2];
					if (si == tj2 && si2 == tj) {
						swapcost = dij(i - 2, j - 2) + 1;
						if (swapcost <= cost) {
							d[i][j] := Pair(swapcost, ArraySwap(i - 1, j - 1, Pair(si, tj)));
						}
					}
				}
			}
		});
	});

	/*iteri(d, \y, row : [ref Pair<int, ArrayOperation>] -> {
		println(i2s(y) + "(" +  (if (y > 0) toString(s[y - 1])  else "") + "): " + fold(row, "", \acc, r : ref Pair<int, ArrayOperation> -> {
			p = ^r;
			acc + i2s(p.first) + " (" + toString(p.second) + "), "
		}));
	});*/

	makeArrayDiffOps(d, m, n, [], fullProtocol);
}

arrayDiffReversed(old : [?], new : [?], fullProtocol : bool) -> [ArrayOperation<?>] {
	reverseA(arrayDiff(old, new, fullProtocol))
}

makeArrayDiffOps(d : [[ref Pair<int, ArrayOperationWithSwapp<?>>]], y : int, x : int, acc : [ArrayOperationWithSwapp<?>], fullProtocol : bool) -> [ArrayOperationWithSwapp<?>] {
	c = ^(d[y][x]);
	// println(i2s(y) + "," + i2s(x) + ": " + toString(c));
	if (c.second.oldindex == -1 || c.second.newindex == -1) acc
	else {
		nacc = if (!fullProtocol && isSameStructType(c.second, ArrayNop(0, 0))) {
			// Skip the NOPs
			acc;
		} else {
			arrayPush(acc, c.second);
		};
		makeArrayDiffOps(d, c.second.oldindex, c.second.newindex, nacc, fullProtocol)
	}
}

applyProtocol(
	source : [?],
	protocol : [ArrayOperation<?>],
	insertFn : (?) -> ?,
	replaceFn : (?, ?) -> ?,
	removeFn : (?) -> Maybe<?>
) -> [?]  {
	applyProtocolWithSwapp(source, protocol, insertFn, replaceFn, removeFn, idfn)
}

applyProtocolWithSwapp(
	source : [?],
	protocol : [ArrayOperationWithSwapp<?>],
	insertFn : (?) -> ?,
	replaceFn : (?, ?) -> ?,
	removeFn : (?) -> Maybe<?>,
	swapFn : (Pair<?, ?>) -> Pair<?, ?>
) -> [?] {
	fold(protocol, source, \acc, op -> {
		switch (op : ArrayOperationWithSwapp) {
			ArrayNop(__, __): acc;
			ArrayInsert(i, __, v): insertArray(acc, i, insertFn(v));
			ArrayReplace(i, __, v): replace(acc, i, replaceFn(acc[i], v));
			ArrayRemove(i, __): {
				eitherFn(
					removeFn(acc[i]),
					\newVal -> replace(acc, i, newVal),
					\ -> removeIndex(acc, i)
				)
			}
			ArraySwap(i, __, v): {
				swapped = swapFn(v);
				replace(
					replace(acc, i, swapped.second),
					i-1,
					swapped.first
				);
			}
		}
	});
}

applyProtocolInvariant(source : [?], protocol : [ArrayOperationWithSwapp<?>]) -> [?] {
	applyProtocolWithSwapp(source, protocol,
		idfn,
		\__, newValue -> newValue,
		\__ -> None(),
		idfn
	);
}

// Test cases.
// printInfo(title : string, arr : [?], inline : bool) -> void {
// 	println(title + ":");
// 	if (inline) {
// 		println("  " + toString(arr));
// 	} else {
// 		iteri(arr, \i, a : ? -> println("  " + lpad(i2s(i), " ", 3) + " " + toString(a)));
// 	}
// }

// main() {
// 	fullProtocol = false;
// 	println("Running static tests...");
// 	assertEquals(arrayDiff([], [], fullProtocol), []);
// 	assertEquals(arrayDiff([0], [0], fullProtocol), []);
// 	assertEquals(arrayDiff([0,1], [0,1], fullProtocol), []);

// 	assertEquals(arrayDiff([], [0], fullProtocol), [ArrayInsert(0,0,0)]);
// 	assertEquals(arrayDiff([], [0,1], fullProtocol), [ArrayInsert(0,1,1), ArrayInsert(0,0,0)]);
// 	assertEquals(arrayDiff([], [0,1,2], fullProtocol), [ArrayInsert(0,2,2), ArrayInsert(0,1,1), ArrayInsert(0,0,0)]);

// 	assertEquals(arrayDiff([0], [0,1,2], fullProtocol), [ArrayInsert(1,2,2), ArrayInsert(1,1,1)]);
// 	assertEquals(arrayDiff([1], [0,1,2], fullProtocol), [ArrayInsert(1,2,2), ArrayInsert(0,0,0)]);

// 	assertEquals(arrayDiff([0], [], fullProtocol), [ArrayRemove(0,0)]);
// 	assertEquals(arrayDiff([0,1], [0], fullProtocol), [ArrayRemove(1,1)]);
// 	assertEquals(arrayDiff([0,1], [1], fullProtocol), [ArrayRemove(0,0)]);

// 	assertEquals(arrayDiff([0], [1], fullProtocol), [ArrayReplace(0,0,1)]);
// 	assertEquals(arrayDiff([0,1,2], [2,1,0], fullProtocol), [ArrayReplace(2,2,0), ArrayReplace(0,0,2)]);
// 	assertEquals(arrayDiff([0,1,2], [2,2,2], fullProtocol), [ArrayReplace(1,1,2), ArrayReplace(0,0,2)]);
// 	assertEquals(arrayDiff([0,1,2], [2,2,2], fullProtocol), [ArrayReplace(1,1,2), ArrayReplace(0,0,2)]);

// 	assertEquals(arrayDiff([0,1,2,3], [0,2,4], fullProtocol), [ArrayReplace(3,2,4), ArrayRemove(1,1)]);
// 	assertEquals(arrayDiff([0,1,2,3], [0,2,2,3,5], fullProtocol), [ArrayInsert(4,4,5), ArrayReplace(1,1,2)]);
// 	assertEquals(arrayDiff([0,1,2,3], [0,2,2,3,5], fullProtocol), [ArrayInsert(4,4,5), ArrayReplace(1,1,2)]);
// 	assertEquals(arrayDiff([0,1,2,3,4], [1,2,3,5,6], fullProtocol), [ArrayReplace(4,4,6), ArrayInsert(4,3,5), ArrayRemove(0,0)]);
// 	println("   PASSED");

// 	applyProtocolWithChange = \theSource, theProtocol ->
// 		applyProtocolWithSwapp(theSource, theProtocol,
// 			\newValue ->  {//insertFn
// 				"INS[" + newValue + "]"
// 			},
// 			\oldValue, newValue -> { // replaceFn
// 				"REPLACE[" + oldValue + " -> " + newValue + "]"
// 			},
// 			\oldValue -> { // removeFn
// 				Some("DEL[" + oldValue + "]")
// 			},
// 			\p : Pair<string, string> -> { // swapFn
// 				Pair(
// 					"SWAP[" + p.first + " -> " + p.second + "]",
// 					"SWAP[" + p.first + " <- " + p.second + "]"
// 				)
// 			}
// 		);

// 	a2s = \a -> map(a, toString);

// 	testData : [Pair<[string], [string]>] = [
// 		Pair(
// 			["The", " ", "boy", " ", "walked", " ", "down", " ", "the", " ", "street", "." ],
// 			["The", " ", "boy", " ", "is", " ", "walks", " ", "down", " ", "the", " ", "street", "." ]
// 		),
// 		Pair(
// 			["The", " ", "boy walked", " ", "down", " ", "the", " ", "street", "."],
// 			["The", " ", "boy is walks down", " ", "the", " ", "street", "."]
// 		),
// 		Pair(
// 			[0, 1, 2, 1, 4,  1, 6,        1, 8, 1, 10, 11, 12] |> a2s,
// 			[0, 1, 2, 1, 21, 1, 22, 1, 6, 1, 8, 1, 10, 11, 12] |> a2s
// 		)
// 	];

// 	randomInt = \upto : int-> {
// 		floor(random() * i2d(upto))
// 	}
// 	minLength = 3;
// 	maxLength = 100;

// 	randomTestData : [Pair<[string], [string]>] =
// 		generate(0, 1000, \__ -> {
// 			Pair(
// 				generate(0, minLength + randomInt(maxLength), \i -> i2s(randomInt(i))),
// 				generate(0, minLength + randomInt(maxLength), \i -> i2s(randomInt(i)))
// 			)
// 		}
// 	);

// 	allTests = concat(testData, randomTestData);

// 	// tests1 = [
// 	// 	Pair(
// 	// 		["0", "0", "1", "2", "3", "4", "5", "1", "1", "4"],
// 	// 		["0", "0", "0", "1", "3", "2", "4", "4", "4", "1"]
// 	// 	)
// 	// ];

// 	processTests = \tests, swapp : bool -> {
// 		println("Running" + (if (swapp) " " else " NO ") + "SWAPP " + i2s(length(tests)) + " random tests...");
// 		iteri(tests, \i, t -> {
// 			source = t.first;
// 			target = t.second;
// 			protocol = if (swapp) arrayDiffWithSwapp(source, target, false) else arrayDiff(source, target, false);

// 			restoredTarget = applyProtocolInvariant(source, protocol);
// 			targetWithChanges = applyProtocolWithChange(source, protocol);

// 			if (target != restoredTarget) {
// 				println("== " + i2s(i+1));
// 				println("Target != restoredTarget");
// 				printInfo("source", source, true);
// 				printInfo("target", target, true);
// 				printInfo("restoredTarget", restoredTarget, true);
// 				printInfo("protocol", protocol, false);
// 				printInfo("targetWithChanges", targetWithChanges, true);
// 				fail("Test failed.");
// 			}
// 		});

// 		println("   PASSED");
// 	}

// 	processTests(allTests, false);
// 	processTests(allTests, true);
// 	println("");

// 	quit(0);
// }
