import string;
import ds/list;
import ds/tree;
import text/blueprint;
import math/bits;

export {
	// LZW-compress a string
	lzw_encode(s : string) -> string;

	// Decompress an LZW-encoded string
	lzw_decode(data : string) -> string;
}

lzw_encode_rec(s : string, sLength : int, i : int, code : ref int, phrase : ref [int], dict : ref Tree<[int], int>, storeResult : () -> void) -> void {
	if (i < sLength) {
		currChar = getCharCodeAt(s, i);
		// tested List here, the array is better from performance and memory point of view
		newPhrase = arrayPush(^phrase, currChar);
		if (isSome(lookupTree(^dict, newPhrase))) {
			phrase := newPhrase;
		} else {
			storeResult();
			dict := setTree(^dict, newPhrase, ^code);
			code := ^code + 1;
			phrase := [currChar];
		}
		lzw_encode_rec(s, sLength, i + 1, code, phrase, dict, storeResult)
	} else {
		storeResult()
	}
}

lzw_encode(s : string) -> string {
	dict : ref Tree<[int], int> = ref makeTree();
	out : ref List<string> = ref makeList();
	phrase : ref [int]= ref [getCharCodeAt(s, 0)];
	code = ref 65536;

	intAsAtring : (int) -> string = \i -> {
		fromCharCode(i) + fromCharCode(bitUshr(i, 16));
	}

	lzw_encode_rec(s, strlen(s), 1, code, phrase, dict, \ -> {
		out := Cons(
			intAsAtring(if (length(^phrase) > 1) {
				lookupTreeDef(^dict, ^phrase, 0);
			} else {
				^phrase[0];
			}),
			^out
		);
	});

	list2string(^out)
}

lzw_decode_rec(
	i : int,
	limit : int,
	code : ref int,
	currChar : ref int,
	oldPhrase : ref List<int>,
	data : (int) -> int,
	dict : ref Tree<int, List<int>>,
	out : ref List<string>
) -> void {
	if (i <= limit) {
		currCode = data(i);
		phrase = if (currCode < 65536) {
			makeList1(data(i));
		} else {
			eitherFn(
				lookupTree(^dict, currCode),
				idfn,
				\ -> Cons(^currChar, ^oldPhrase)
			)
		}
		phraseA = phrase |> list2array;
		out := Cons(superglue(phraseA, fromCharCode, ""), ^out);
		currChar := phraseA[0];
		dict := setTree(^dict, ^code, Cons(^currChar, ^oldPhrase));
		code := ^code + 1;
		oldPhrase := phrase;

		lzw_decode_rec(i + 1, limit, code, currChar, oldPhrase, data, dict, out);
	}
}

// Decompress an LZW-encoded string
lzw_decode(s : string) -> string {
	data = \i : int -> {
		getCharCodeAt(s, 2*i) + bitShl(getCharCodeAt(s, 2*i + 1), 16);
	}

	dict : ref Tree<int, List<int>> = ref makeTree();
	currChar : ref int = ref data(0);
	out : ref List<string> = ref makeList1(getCharAt(s, 0));
	oldPhrase : ref List<int> = ref makeList1(^currChar);
	code = ref 65536;

	lzw_decode_rec(1, round(i2d(strlen(s))/2.0 - 1.0), code, currChar, oldPhrase, data, dict, out);

	list2string(^out)
}
