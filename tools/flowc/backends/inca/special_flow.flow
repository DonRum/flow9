import tools/flowc/incremental/fiexp;
import ds/tree;

export {
	SiEnv(
		functions : Tree<string, SiFunction>,
		vars : Tree<string, SiValue>
	);

	// Our code language
	SiExp ::= 
			SiValue, SiStructName, SiConstructor, SiField, SiSetField, SiIf, 
			SiSeq, SiLet, SiCall, SiPrim, SiVarRef, SiSwitch, SiDyn;

		SiStructName(name : string);
		SiConstructor(name : SiExp, fields :[SiExp]);
		SiField(value : SiExp, index : int);
		SiSetField(value : SiExp, index : int, newValue : SiExp);
		SiIf(c : SiExp, then : SiExp, else_ : SiExp);
		SiPrim(op : PrimOp, args : [SiExp]);
			PrimOp ::= FcPlusPrim, FcMinusPrim, FcMulPrim, FcDivPrim, FcModPrim,
				FcNegPrim,
				FcOrPrim, FcAndPrim, FcNotPrim,
				FcEqPrim, FcNePrim, FcLePrim, FcGePrim, FcLtPrim, FcGtPrim, 
				FcArrayPrim, FcIndexPrim;

	/*
			FcDerefPrim, FcAssignPrim, FcRefPrim, 
			FcCreateClosurePrim, FcQuote, FcUnquote;
	*/

		SiSeq(seq : [SiExp]);
		SiLet(name : string, value : SiExp, body : SiExp);
		SiVarRef(name : string);
		SiCall(name : string, args : [SiExp]);
		SiSwitch(x : SiExp, cases : [SiCase]);
			SiCase(struct : string, args : [string], body : SiExp);

		// For code which has to be run because of the change. In case of
		// if, call, constructor and seq, there can still be static parts inside
		// so in those cases, the sub-dynamic parts have their own SiDyn annotation
		SiDyn(c : SiExp);

	/*
			FiSwitch(x: FiVar, switchType : FiType, cases: [FiCase], type : FiType, start : int);
				// struct is "default" for default case
				FiCase(struct: string, argNames : [string], body: FiExp, start : int);
	*/

	SiValue ::= SiVoid, SiBool, SiInt, SiDouble, SiString, SiStructValue, SiArrayValue;
		SiVoid();
		SiBool(v: bool);
		SiInt(i : int);
		SiDouble(d : double);
		SiString(s : string);
		SiStructValue(name: string, args : [SiValue]);
		SiArrayValue(values : [SiValue]);

	SiFunction(name : string, inputs : [SiArgument], output : FiType, code : SiExp);
		SiArgument(name : string, type : FiType);
}
