import tools/flowc/backends/inca/special_flow;
import tools/flowc/backends/inca/env;
import tools/flowc/incremental/fi_helpers;

export {
	fi2special(env : IncaEnv) -> SiEnv;
}

fi2special(env : IncaEnv) -> SiEnv {
	lenv = liftLocalLambdas(env);

	env0 = SiEnv(makeTree(), makeTree());
	
	SiEnv(
		env0 with functions =
			foldTree(lenv.functions, env0.functions, 
				\n : string, f : FiFunctionDec, acc : Tree<string, SiFunction> -> setTree(acc, n, fifun2special(lenv, f))
			)
	);
}


fifun2special(env : IncaEnv, fi : FiFunctionDec) -> SiFunction {
	onError = \e -> {
		println("Error in " + fi.name + ": " + e);
	}
	SiFunction(
		fi.name, map(fi.lambda.args, \a : FiFunArg -> {
			SiArgument(a.name, fiType2special(env, onError, a.type))
		}),
		fiType2special(env, onError, fi.type.returnType),
		fiExp2special(env, onError, fi.lambda.body)
	);
}

fiType2special(env : IncaEnv, onError : (string) -> void, a : FiType) -> SiType {
	error = \e -> {
		onError("Do not support " + e + " types");
		SiTypeVoid();
	}
	switch (a) {
		FiTypeArray(t): SiTypeArray(fiType2special(env, onError, t));
		FiTypeFunction(args, returnType): {
			error("function");
		}
		FiTypeRef(t): error("ref"); 
		FiTypeParameter(n): SiTypeParameter(n);
		FiTypeBool(): SiTypeBool();
		FiTypeInt(): SiTypeInt();
		FiTypeDouble(): SiTypeDouble();
		FiTypeString(): SiTypeString();
		FiTypeFlow(): error("flow");
		FiTypeVoid(): SiTypeVoid();
		FiTypeNative(): error("name");
		FiTypeName(name, typeparameters): {
			mstr = lookupTree(env.structs, name);
			switch (mstr) {
				None(): {
					muni = lookupTree(env.unions, name);
					switch (muni) {
						None(): error("Unknown name " + name);
						Some(ut): {
							types = map(ut.typenames, \t -> {
								fiType2special(env, onError, t);
							});
							expanded :[[SiTypeStruct]] = map(types, \tt : SiType -> {
								switch (tt) {
									SiTypeUnion(__, ss): ss;
									SiTypeStruct(__, __): [tt];
									default: [];
								}
							});
							SiTypeUnion(name, concatA(expanded));
						}
					}
				}
				Some(str): {
					SiTypeStruct(str.name, map(str.args, \ar : FiStructArg -> {
						SiStructField(ar.name, fiType2special(env, onError, ar.type))
					}))
				}
			}
		}
	}
}

LambdaReplacements(
	// Prefix for generated names
	prefix : string,
	// New top-level lambdas
	lambdas : ref Tree<string, FiFunctionDec>,
	// Renaming of those local variables
	renamings : ref Tree<string, string>
);

liftLocalLambdas(env : IncaEnv) -> IncaEnv {
	foldTree(env.functions, env, \fnname, fndec, acc -> {
		rep = LambdaReplacements(fnname, ref makeTree(), ref makeTree());
		nlambda = extractLocalLambdas(rep, fndec.lambda);
		switch (nlambda) {
			FiLambda(__, __, __, __): {
				newFunc = FiFunctionDec(fndec with lambda = nlambda);
				func0 = setTree(acc.functions, fnname, newFunc);
				func1 = mergeTree(func0, ^(rep.lambdas));
				IncaEnv(
					acc with
					functions = func1;
				)
			}
			default: acc;
		}
	});
}

extractLocalLambdas(acc : LambdaReplacements, ex : FiExp) -> FiExp {
	switch (ex) {
		FiConst(): ex;
		FiLet(name, type, e1, e2, type2, start): {
			switch (type) {
				FiTypeFunction(__, __): {
					switch (e1) {
						FiLambda(args, body, t1, start2): {
							addLocalLambda(acc, name, type, e1, start);
							e2;
						}
						default: ex;
					}
				}
				default: {
					FiLet(
						name, 
						type, 
						extractLocalLambdas(acc, e1),
						extractLocalLambdas(acc, e2),
						type2,
						start
					);
				}
			}
		}
		FiLambda(args, body, type, start): {
			FiLambda(args, extractLocalLambdas(acc, body), type, start)
		}
		FiCall(f, args, type, start): {
			FiCall(
				extractLocalLambdas(acc, f),
				map(args, \a -> extractLocalLambdas(acc, a)),
				type,
				start
			);
		}
		FiVar(name, type, start): {
			FiVar(lookupTreeDef(^(acc.renamings), name, name), type, start);
		}
		FiIf(e1, e2, e3, type, start): {
			FiIf(
				extractLocalLambdas(acc, e1),
				extractLocalLambdas(acc, e2),
				extractLocalLambdas(acc, e3),
				type,
				start
			);
		}
		FiSwitch(x, switchType, cases, type, start): {
			FiSwitch(x, switchType, map(cases, \case -> {
				FiCase(
					case.struct,
					case.argNames,
					extractLocalLambdas(acc, case.body),
					case.start
				)
			}), type, start);
		}
		FiCast(e, tFrom, tTo, type, start): {
			FiCast(extractLocalLambdas(acc, e), tFrom, tTo, type, start);
		}
		FiSeq(es, type, start): {
			FiSeq(map(es, \e -> extractLocalLambdas(acc, e)), type, start);
		}
		FiCallPrim(op, es, type, start): {
			FiCallPrim(op, map(es, \e -> extractLocalLambdas(acc, e)), type, start);
		}
		FiRequire(flowfile, e, type, start): ex;
		FiUnsafe(name, fallback, type, start): ex;
	}
}

addLocalLambda(acc : LambdaReplacements, name : string, type : FiTypeFunction, lambda : FiLambda, start : int) -> void {
	newName = acc.prefix + "_" + name + "_lambda_" + i2s(sizeTree(^(acc.lambdas)));
	acc.lambdas := setTree(^(acc.lambdas), newName, 
		FiFunctionDec(
			newName,
			lambda,
			type,
			start,
			start,
		)
	);
	acc.renamings := setTree(^(acc.renamings), name, newName);
}

fiExp2special(env : IncaEnv, onError : (string) -> void, fe : FiExp) -> SiExp {
	error = \er -> {
		onError(er + " not supported");
		SiVoid();
	}
	switch (fe) {
		FiLambda(args, body, type, start): error("lambda");
		FiCall(f, args, type, start): {
			switch (f) {
				FiVar(v, __, __): {
					SiCall(v, map(args, \a -> fiExp2special(env, onError, a)));
				}
				default: error("first order function");
			}
		}
		FiVar(name, type, start): SiVarRef(name);
		FiLet(name, type, e1, e2, type2, start): {
			SiLet(name, fiExp2special(env, onError, e1), fiExp2special(env, onError, e2));
		}
		FiIf(e1, e2, e3, type, start): SiIf(fiExp2special(env, onError, e1), fiExp2special(env, onError, e2), fiExp2special(env, onError, e3));
		FiSwitch(x, switchType, cases, type, start): {
			SiSwitch(
				SiVarRef(x.name),
				map(cases, \case : FiCase -> {
					SiCase(
						case.struct, case.argNames, fiExp2special(env, onError, case.body)
					)
				})
			);
		}
		FiCast(e, tFrom, tTo, type, start): error("cast");
		FiSeq(es, type, start): SiSeq(map(es, \s -> fiExp2special(env, onError, s)));
		FiCallPrim(op, es, type, start): {
			ses = map(es, \ss -> fiExp2special(env, onError, ss));
			switch (op) {
				FcOrPrim(): SiPrim(op, ses);
				FcAndPrim(): SiPrim(op, ses);
				FcNotPrim(): SiPrim(op, ses);
				FcEqPrim(): SiPrim(op, ses);
				FcNePrim(): SiPrim(op, ses);
				FcLePrim(): SiPrim(op, ses);
				FcGePrim(): SiPrim(op, ses);
				FcLtPrim(): SiPrim(op, ses);
				FcGtPrim(): SiPrim(op, ses);
				FcPlusPrim(): SiPrim(op, ses);
				FcMinusPrim(): SiPrim(op, ses);
				FcMulPrim(): SiPrim(op, ses);
				FcDivPrim(): SiPrim(op, ses);
				FcModPrim(): SiPrim(op, ses);
				FcNegPrim(): SiPrim(op, ses);
				FcArrayPrim(): SiPrim(op, ses);
				FcIndexPrim(): SiPrim(op, ses);
				FcDerefPrim(): error("deref");
				FcAssignPrim(): error("assign");
				FcRefPrim(): error("ref");
				FcStructPrim(struct_name): SiConstructor(SiVarRef(struct_name), ses);
				FcFieldPrim(name): {
					structType = fiExpType(es[0]);
					field = siFieldNumber(env, structType, name);
					if (field == -1) {
						error("field " + name);
					} else {
						SiField(ses[0], field);
					}
				}
				FcSetMutablePrim(name): {
					structType = fiExpType(es[0]);
					field = siFieldNumber(env, structType, name);
					if (field == -1) {
						error("set field " + name);
					} else {
						SiSetField(ses[0], field, ses[1]);
					}
				}
				FcCreateClosurePrim(structName, functionName): {
					error("closure");
				}
				FcQuote(): error("quote");
				FcUnquote(): error("unquote");
			}
		}
		FiVoid(start): SiVoid();
		FiDouble(d, start): SiDouble(d);
		FiInt(i, start): SiInt(i);
		FiString(s, start): SiString(s);
		FiBool(b, start): SiBool(b);
		FiRequire(flowfile, e, type, start): error("require");
		FiUnsafe(name, fallback, type, start): error("unsafe");
	}
}

siFieldNumber(env : IncaEnv, structType : FiType, field : string) -> int {
	switch (structType) {
		FiTypeName(name, typeparameters): {
			mstr = lookupTree(env.structs, name);
			switch (mstr) {
				None(): -1;
				Some(str): {
					foldi(str.args, -1, \ix, acc, arg -> {
						if (arg.name == field) ix else acc;
					});
				}
			}
		}
		default: -1;
	}
}
