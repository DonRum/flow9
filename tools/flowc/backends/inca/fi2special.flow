import tools/flowc/backends/inca/special_flow;
import tools/flowc/backends/inca/env;

export {
	fi2special(env : IncaEnv) -> SiEnv;
}

fi2special(env : IncaEnv) -> SiEnv {
	env0 = SiEnv(makeTree(), makeTree());
	SiEnv(
		env0 with functions =
			foldTree(env.functions, env0.functions, 
				\n : string, f : FiFunctionDec, acc : Tree<string, SiFunction> -> setTree(acc, n, fifun2special(env, f))
			)
	);
}

fifun2special(env : IncaEnv, fi : FiFunctionDec) -> SiFunction {
	SiFunction(
		fi.name, map(fi.lambda.args, \a : FiFunArg -> {
			SiArgument(a.name, fiType2special(env, a.type))
		}),
		fiType2special(env, fi.type.returnType),
		fiExp2special(env, fi.lambda.body)
	);
}

fiType2special(env : IncaEnv, a : FiType) -> SiType {
	error = \e -> {
		println("Do not support " + e + " types");
		SiTypeVoid();
	}
	switch (a) {
		FiTypeArray(t): SiTypeArray(fiType2special(env, t));
		FiTypeFunction(args, returnType): {
			error("function");
		}
		FiTypeRef(t): error("ref"); 
		FiTypeParameter(n): error("polymorphic");
		FiTypeBool(): SiTypeBool();
		FiTypeInt(): SiTypeInt();
		FiTypeDouble(): SiTypeDouble();
		FiTypeString(): SiTypeString();
		FiTypeFlow(): error("flow");
		FiTypeVoid(): SiTypeVoid();
		FiTypeNative(): error("name");
		FiTypeName(name, typeparameters): {
			mstr = lookupTree(env.structs, name);
			switch (mstr) {
				None(): {
					muni = lookupTree(env.unions, name);
					switch (muni) {
						None(): error("Unknown name " + name);
						Some(ut): {
							types = map(ut.typenames, \t -> {
								fiType2special(env, t);
							});
							expanded :[[SiTypeStruct]] = map(types, \tt : SiType -> {
								switch (tt) {
									SiTypeUnion(__, ss): ss;
									SiTypeStruct(__, __): [tt];
									default: [];
								}
							});
							SiTypeUnion(name, concatA(expanded));
						}
					}
				}
				Some(str): {
					SiTypeStruct(str.name, map(str.args, \ar : FiStructArg -> {
						SiStructField(ar.name, fiType2special(env, ar.type))
					}))
				}
			}
		}
	}
}

fiExp2special(env : IncaEnv, fe : FiExp) -> SiExp {
	error = \er -> {
		println(er + " not supported");
		SiVoid();
	}
	switch (fe) {
		FiLambda(args, body, type, start): error("lambda");
		FiCall(f, args, type, start): {
			switch (f) {
				FiVar(v, __, __): {
					SiCall(v, map(args, \a -> fiExp2special(env, a)));
				}
				default: error("first order function");
			}
		}
		FiVar(name, type, start): SiVarRef(name);
		FiLet(name, type, e1, e2, type2, start): SiLet(name, fiExp2special(env, e1), fiExp2special(env, e2));
		FiIf(e1, e2, e3, type, start): SiIf(fiExp2special(env, e1), fiExp2special(env, e2), fiExp2special(env, e3));
		FiSwitch(x, switchType, cases, type, start): {
			error("switch");
		}
		FiCast(e, tFrom, tTo, type, start): error("cast");
		FiSeq(es, type, start): SiSeq(map(es, \s -> fiExp2special(env, s)));
		FiCallPrim(op, es, type, start): {
			ses = map(es, \ss -> fiExp2special(env, ss));
			switch (op) {
				FcOrPrim(): SiPrim(op, ses);
				FcAndPrim(): SiPrim(op, ses);
				FcNotPrim(): SiPrim(op, ses);
				FcEqPrim(): SiPrim(op, ses);
				FcNePrim(): SiPrim(op, ses);
				FcLePrim(): SiPrim(op, ses);
				FcGePrim(): SiPrim(op, ses);
				FcLtPrim(): SiPrim(op, ses);
				FcGtPrim(): SiPrim(op, ses);
				FcPlusPrim(): SiPrim(op, ses);
				FcMinusPrim(): SiPrim(op, ses);
				FcMulPrim(): SiPrim(op, ses);
				FcDivPrim(): SiPrim(op, ses);
				FcModPrim(): SiPrim(op, ses);
				FcNegPrim(): SiPrim(op, ses);
				FcArrayPrim(): SiPrim(op, ses);
				FcIndexPrim(): SiPrim(op, ses);
				FcDerefPrim(): error("deref");
				FcAssignPrim(): error("assign");
				FcRefPrim(): error("ref");
				FcStructPrim(struct_name): SiConstructor(SiVarRef(struct_name), ses);
				FcFieldPrim(name): {
					error("field");
//					SiField(ses[0], name);
				}
				FcSetMutablePrim(name): {
					// SiSetField(ses[0], name, ses[1]);
					error("setfield");
				}
				FcCreateClosurePrim(structName, functionName): error("closure");
				FcQuote(): error("quote");
				FcUnquote(): error("unquote");
			}
		}
		FiVoid(start): SiVoid();
		FiDouble(d, start): SiDouble(d);
		FiInt(i, start): SiInt(i);
		FiString(s, start): SiString(s);
		FiBool(b, start): SiBool(b);
		FiRequire(flowfile, e, type, start): error("require");
		FiUnsafe(name, fallback, type, start): error("unsafe");
	}
}
