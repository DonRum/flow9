import tools/flowc/backends/inca/env;
import text/blueprint;
import ds/simplegraph;
import tools/flowc/backends/inca/conversion_graph;

export {
	liftIncaGraph(env : IncaEnv) -> string;
}

liftIncaGraph(env : IncaEnv) -> string {
	// First, find what types we should generate converters for
	smallgraph = buildIncaConversionGraph(env, false);
	smallrev = reverseSimpleGraph(smallgraph);

	unions = foldTree(env.unions, makeSet(), \name, __, acc -> insertSet(acc, name));
	structsAndUnions = foldTree(env.structs, unions, \name, __, acc -> insertSet(acc, name));

	// This is a collection of the types that have more than one "upflow" source
	convertable = foldSet(structsAndUnions, makeSet1("void"), \acc, name -> {
		pre = getSimpleAdjacentNodes(smallrev, name);
		if (length(pre) >= 1) {
			insertSet(acc, name);
		} else {
			acc;
		}
	});
	// println("These are targets: " + toString(set2array(convertable)));

	// OK, build the graph for all structs so we can find the best path for conversion
	fullgraph = buildIncaConversionGraph(env, true);
	rev = reverseSimpleGraph(fullgraph);

	// OK, we have to find all structures that lead to "void"
	buildIncaConverterFunction(env, "void", fullgraph, rev);
}

buildIncaConverterFunction(env : IncaEnv, targetType : string, graph : SimpleGraph<string, string>, rev : SimpleGraph<string, string>) -> string {
	performable : Set<string> = reachableClosureFromSimpleNode(rev, targetType);

	structs = filterSet(performable, \name -> {
		// We ignore unions
		!containsKeyTree(env.unions, name)
	});

	blueprint("
			performIncaEffect_lifted(manager : IncaManager, value : IncaValue) -> void {
				id = IncaStructId(value);

				%dispatcher%
				else {
					println_lifted(value) |> ignore;
				}
			}
		", 
		[
			"dispatcher", buildIncaDispatcher(env, targetType, graph, structs)
		]
	);
}

buildIncaDispatcher(env : IncaEnv, targetType : string, graph : SimpleGraph<string, string>, performable : Set<string>) -> string {
	superglue(set2array(performable), \name -> {
		edges = getSimpleAdjacentEdges(graph, name);

		if (edges == []) {
			""
		} else {
			fn = if (length(edges) ==1) {
				edges[0]
			} else {
				println("TODO: find the shortest path to void for " + name);
				edges[0];
			}

			mfndef = lookupTree(env.functions, fn);
			ok = switch (mfndef) {
				None(): false;
				Some(fndef): length(fndef.type.args) == 1;
			}
			if (ok) {
				targets = getSimpleAdjacentNodes(graph, name);
				fncall = edges[0] + "_lifted(manager, value)";

				call = if (targets[0] == targetType) {
					// OK, this is good
					fncall + "; {}"
				} else {
					// OK, convert and the recurse
					"performIncaEffect_lifted(manager, " + fncall + ")";
				}

				blueprint("
					if (id == %name%_ID) {
						%call%
					}", ["name", name,
					"call", call
				])
			} else {
				// Requires more than one parameter, so we can not do it
				"";
			}
		}

	}, " else ");
}
