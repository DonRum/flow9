import tools/flowc/backends/inca/special_flow;
import tools/flowc/backends/inca/env;
import tools/flowc/incremental/fi_helpers;

export {
	fi2special(env : IncaEnv) -> SiEnv;
}

fi2special(env : IncaEnv) -> SiEnv {
	lenv = liftLocalLambdas(env);

	env0 = SiEnv(makeTree());
	
	SiEnv(
		env0 with functions =
			foldTree(lenv.functions, env0.functions, 
				\n : string, f : FiFunctionDec, acc : Tree<string, SiFunction> -> setTree(acc, n, fifun2special(lenv, f))
			)
	);
}

fifun2special(env : IncaEnv, fi : FiFunctionDec) -> SiFunction {
	onError = \e -> {
		println("Error in " + fi.name + ": " + e);
	}
	println("Converting " + fi.name);
	ex = fiExp2special(env, onError, fi.lambda.body);
	SiFunction(
		fi.name, map(fi.lambda.args, \a : FiFunArg -> {
			SiArgument(a.name, a.type)
		}),
		fi.type.returnType,
		ex
	);
}

LambdaReplacements(
	// Prefix for generated names
	prefix : string,
	// New top-level lambdas
	lambdas : ref Tree<string, FiFunctionDec>,
	// Renaming of those local variables
	renamings : ref Tree<string, string>
);

liftLocalLambdas(env : IncaEnv) -> IncaEnv {
	foldTree(env.functions, env, \fnname, fndec, acc -> {
		rep = LambdaReplacements(fnname, ref makeTree(), ref makeTree());
		nbody = extractLocalLambdas(rep, fndec.lambda.body);

		// TODO: Check that there are no free vars in the body
		// outside of globals. Requires that IncaEnv is extended
		// with global names, it seems.
		nlambda = FiLambda(fndec.lambda with body = nbody);
		newFunc = FiFunctionDec(fndec with lambda = nlambda);
		func0 = setTree(acc.functions, fnname, newFunc);
		func1 = mergeTree(func0, ^(rep.lambdas));
		IncaEnv(
			acc with
			functions = func1;
		)
	});
}

extractLocalLambdas(acc : LambdaReplacements, ex : FiExp) -> FiExp {
	switch (ex) {
		FiConst(): ex;
		FiLet(name, type, e1, e2, type2, start): {
			switch (type) {
				FiTypeFunction(__, __): {
					switch (e1) {
						FiLambda(args, body, t1, start2): {
							addLocalLambda(acc, name, type, e1, start);
							e2;
						}
						default: ex;
					}
				}
				default: {
					FiLet(
						name, 
						type, 
						extractLocalLambdas(acc, e1),
						extractLocalLambdas(acc, e2),
						type2,
						start
					);
				}
			}
		}
		FiLambda(args, body, type, start): {
			// OK, we convert it
			lambdaName = addLocalLambda(acc, "implicit", type, ex, start);
			FiVar(lambdaName, type, start)
		}
		FiCall(f, args, type, start): {
			FiCall(
				extractLocalLambdas(acc, f),
				map(args, \a -> extractLocalLambdas(acc, a)),
				type,
				start
			);
		}
		FiVar(name, type, start): {
			FiVar(lookupTreeDef(^(acc.renamings), name, name), type, start);
		}
		FiIf(e1, e2, e3, type, start): {
			FiIf(
				extractLocalLambdas(acc, e1),
				extractLocalLambdas(acc, e2),
				extractLocalLambdas(acc, e3),
				type,
				start
			);
		}
		FiSwitch(x, switchType, cases, type, start): {
			FiSwitch(x, switchType, map(cases, \case -> {
				FiCase(
					case.struct,
					case.argNames,
					extractLocalLambdas(acc, case.body),
					case.start
				)
			}), type, start);
		}
		FiCast(e, tFrom, tTo, type, start): {
			FiCast(extractLocalLambdas(acc, e), tFrom, tTo, type, start);
		}
		FiSeq(es, type, start): {
			FiSeq(map(es, \e -> extractLocalLambdas(acc, e)), type, start);
		}
		FiCallPrim(op, es, type, start): {
			FiCallPrim(op, map(es, \e -> extractLocalLambdas(acc, e)), type, start);
		}
		FiRequire(flowfile, e, type, start): ex;
		FiUnsafe(name, fallback, type, start): ex;
	}
}

addLocalLambda(acc : LambdaReplacements, name : string, type : FiTypeFunction, lambda : FiLambda, start : int) -> string {
	newName = acc.prefix + "_" + name + "_lambda_" + i2s(sizeTree(^(acc.lambdas)));
	acc.lambdas := setTree(^(acc.lambdas), newName, 
		FiFunctionDec(
			newName,
			lambda,
			type,
			start,
			start,
		)
	);
	acc.renamings := setTree(^(acc.renamings), name, newName);
	newName;
}

fiExp2special(env : IncaEnv, onError : (string) -> void, fe : FiExp) -> SiExp {
	error = \er -> {
		onError(er + " not supported");
		FiVoid(fe.start);
	}
	switch (fe) {
		FiLambda(args, body, type, start): error("lambda");
		FiCall(f, args, type, start): {
			switch (f) {
				FiVar(v, __, __): {
					SiCall(v, map(args, \a -> fiExp2special(env, onError, a)));
				}
				default: error("first order function");
			}
		}
		FiVar(name, type, start): SiVarRef(name);
		FiLet(name, type, e1, e2, type2, start): {
			SiLet(name, fiExp2special(env, onError, e1), fiExp2special(env, onError, e2));
		}
		FiIf(e1, e2, e3, type, start): SiIf(fiExp2special(env, onError, e1), fiExp2special(env, onError, e2), fiExp2special(env, onError, e3));
		FiSwitch(x, switchType, cases, type, start): {
			SiSwitch(
				SiVarRef(x.name),
				map(cases, \case : FiCase -> {
					SiCase(
						case.struct, case.argNames, fiExp2special(env, onError, case.body)
					)
				})
			);
		}
		FiCast(e, tFrom, tTo, type, start): error("cast");
		FiSeq(es, type, start): SiSeq(map(es, \s -> fiExp2special(env, onError, s)));
		FiCallPrim(op, es, type, start): {
			ses = map(es, \ss -> fiExp2special(env, onError, ss));
			switch (op) {
				FcOrPrim(): SiPrim(op, ses);
				FcAndPrim(): SiPrim(op, ses);
				FcNotPrim(): SiPrim(op, ses);
				FcEqPrim(): SiPrim(op, ses);
				FcNePrim(): SiPrim(op, ses);
				FcLePrim(): SiPrim(op, ses);
				FcGePrim(): SiPrim(op, ses);
				FcLtPrim(): SiPrim(op, ses);
				FcGtPrim(): SiPrim(op, ses);
				FcPlusPrim(): SiPrim(op, ses);
				FcMinusPrim(): SiPrim(op, ses);
				FcMulPrim(): SiPrim(op, ses);
				FcDivPrim(): SiPrim(op, ses);
				FcModPrim(): SiPrim(op, ses);
				FcNegPrim(): SiPrim(op, ses);
				FcArrayPrim(): SiPrim(op, ses);
				FcIndexPrim(): SiPrim(op, ses);
				FcDerefPrim(): error("deref");
				FcAssignPrim(): error("assign");
				FcRefPrim(): error("ref");
				FcStructPrim(struct_name): SiConstructor(SiVarRef(struct_name), ses);
				FcFieldPrim(name): {
					structType = fiExpType(es[0]);
					field = siFieldNumber(env, structType, name);
					if (field == -1) {
						error("field " + name);
					} else {
						SiField(ses[0], field);
					}
				}
				FcSetMutablePrim(name): {
					structType = fiExpType(es[0]);
					field = siFieldNumber(env, structType, name);
					if (field == -1) {
						error("set field " + name);
					} else {
						SiSetField(ses[0], field, ses[1]);
					}
				}
				FcCreateClosurePrim(structName, functionName): {
					error("closure");
				}
				FcQuote(): error("quote");
				FcUnquote(): error("unquote");
			}
		}
		FiConst(): fe;
		FiRequire(flowfile, e, type, start): error("require");
		FiUnsafe(name, fallback, type, start): error("unsafe");
	}
}

siFieldNumber(env : IncaEnv, structType : FiType, field : string) -> int {
	switch (structType) {
		FiTypeName(name, typeparameters): {
			mstr = lookupTree(env.structs, name);
			switch (mstr) {
				None(): -1;
				Some(str): {
					foldi(str.args, -1, \ix, acc, arg -> {
						if (arg.name == field) ix else acc;
					});
				}
			}
		}
		default: -1;
	}
}
