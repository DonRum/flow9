import tools/flowc/backends/inca/special_flow;
import tools/flowc/incremental/fi_helpers;
import math/math;

export {
	// Generate all change functions for this function and populate the environment with them.
	// These are the functions that allow one argument to change.
	makeChangeFunction(names : FiGlobalNames, env : SiEnv, f : SiFunction) -> SiEnv;
}

makeChangeFunction(names : FiGlobalNames, env : SiEnv, f : SiFunction) -> SiEnv {
	verbose = false;
	/*if (verbose) {
		println(prettyF(f));
	}*/
	SiEnv(env with functions = 
		foldi(f.inputs, env.functions, \argno, acc, argument : SiArgument -> {
			replaceEnv = makeTree1(SiVarRef(argument.name), SiDyn(SiVarRef(argument.name)));
			dynamicCode = bubbleDynUp(replaceEnv, f.code, "  ");

		/*	if (verbose) {
				println("Dynamic for " + argument.name);
				println(prettyP(dynamicCode));
			}*/

			res = reuseOldOutput(names, dynamicCode, f.output, SiVarRef("__old_output"));

			fn = SiFunction(f.name + "_change_" + i2s(argno), 
				arrayPush(
					f.inputs,
					SiArgument("__old_output", f.output),
				),
				f.output, 
				res
			);

/*			if (verbose && res != SiSeq([])) {
				println("Specialized for " + argument.name + ":\n" + prettyF(fn));
			}
*/
			setTree(acc, fn.name, fn);
		})
	);
}


// This will lift up SiDyn annotations up the AST across operations where there
// is no chance for us to reuse old values. So we bubble up SiDyn if a child
// is SiDyn. In some places, we keep dyn beneath, since even if the overall
// expression is SiDyn, there is potential to reuse some parts in some cases.
// We give in a set of replacements, where we already know how to lift the
// expression. This can be used to mark the original arguments as SiDyn.
bubbleDynUp(replacements : Tree<SiExp, SiExp>, code : SiExp, indent : string) -> SiExp {
	// println(indent + "Replacing " + toString(code));
	mrep = lookupTree(replacements, code);
	res = switch (mrep) {
		None(): {
			newIndent = indent + "  ";
			switch (code) {
				FiConst(): code;
				SiStructName(__): code;
				SiVarRef(__): code;
				SiConstructor(name, fields): {
					sup = bubbleDynUp(replacements, name, newIndent);
					sfields = map(fields, \f -> bubbleDynUp(replacements, f, newIndent));
					c = SiConstructor(sup, sfields);
					if (isSiDyn(sup) || exists(sfields, isSiDyn)) {
						SiDyn(c)
					} else c;
				}
				SiField(value, name): {
					bub = bubbleDynUp(replacements, value, newIndent);
					if (isSiDyn(bub)) {
						SiDyn(SiField(bub, name))
					} else SiField(bub, name);
				}
				SiSetField(value, field, newvalue): {
					// This has effects, so it is dyn
					SiDyn(code);
				}
				SiLet(name, value, body): {
					bubv = bubbleDynUp(replacements, value, newIndent);
					bubb = bubbleDynUp(replacements, body, newIndent);
					blet = SiLet(name, bubv, bubb);
					if (isSiDyn(bubv) || isSiDyn(bubb)) {
						SiDyn(blet)
					} else blet;
				}
				SiSeq(seq): {
					bubseq = map(seq, \s -> bubbleDynUp(replacements, s, newIndent));
					// We lift dyn up so the entire seq is dyn if anything is
					if (exists(bubseq, isSiDyn)) {
						SiDyn(SiSeq(bubseq))
					} else SiSeq(bubseq);
				}
				SiIf(cond, then, else_): {
					bub = bubbleDynUp(replacements, cond, newIndent);
					thenDyn = bubbleDynUp(replacements, then, newIndent);
					elseDyn = bubbleDynUp(replacements, else_, newIndent);
					ifc = SiIf(bub, thenDyn, elseDyn);
					if (isSiDyn(bub) || isSiDyn(thenDyn) || isSiDyn(elseDyn)) {
						SiDyn(ifc)
					} else ifc
				}
				SiPrim(op, args): {
					argsDyn = map(args, \arg -> bubbleDynUp(replacements, arg, newIndent));
					if (exists(argsDyn, isSiDyn)) {
						SiDyn(SiPrim(op, argsDyn))
					} else SiPrim(op, argsDyn)
				}
				SiCall(name, args): {
					argsDyn = map(args, \arg -> bubbleDynUp(replacements, arg, newIndent));
					if (exists(argsDyn, isSiDyn)) {
						SiDyn(SiCall(name, argsDyn))
					} else SiCall(name, argsDyn)
				}
				SiSwitch(var, cases): {
					dvar = bubbleDynUp(replacements, var, newIndent);
					caseDyn = map(cases, \c -> {
						dynB = bubbleDynUp(replacements, c.body, newIndent);
						SiCase(c.struct, c.args, dynB);
					});
					dswitch = SiSwitch(dvar, caseDyn);
					if (isSiDyn(dvar) || exists(caseDyn, \c -> isSiDyn(c.body))) {
						SiDyn(dswitch)
					} else dswitch;
				}
				SiDyn(c): code;
			}
		}
		Some(rep): rep;
	}
//	println(indent + "Is " + toString(res));
	res
}

isSiDyn(code : SiExp) -> bool {
	switch (code) {
		SiDyn(__): true;
		default: false;
	}
}

// Given a code with SiDyn tags, and a known type for the output,
// as well as the last known output value, reuse as much of the 
// output as possible
reuseOldOutput(names : FiGlobalNames, code : SiExp, type : FiType, output : SiExp) -> SiExp {
	switch (code) {
		FiVoid(__): code;
		FiBool(v, __): code; // either works, code is probably shortest
		FiInt(v, __): code; // either works, code is probably shortest
		FiDouble(v, __): output;
		FiString(v, __): output;

		SiStructName(name): code;
		SiConstructor(name, args): {
			reuseConstructor(names, code, type, output)
		}
		SiIf(c, then, else_): {
			SiIf(c, reuseOldOutput(names, then, type, output), reuseOldOutput(names, else_, type, output));
		}
		SiSwitch(var, cases): {
			SiSwitch(var,
				map(cases, \c -> {
					SiCase(c.struct, c.args, 
						reuseOldOutput(names, c.body, type, output)
					)
				})
			)
		}
		SiField(value, name): {
			// We are static, so we should be good here
			output;
		}
		SiSetField(value, field, newValue): {
			// This is dyn, so we keep it
			code;
		}
		SiSeq(seq): {
			reuseSeq(code, output);
		};
		SiLet(n,v,b): output;
		SiPrim(op, args): output;
		SiVarRef(__): output;
		SiDyn(c): {
			switch (c) {
				SiCall(n, args): {
					ndyns = countA(args, isSiDyn);
					if (ndyns == 1) {
						// OK, only one is dyn, so we can use a change function
						dynindex = findiDef(args, isSiDyn, 0);
						changeName = n + "_change_" + i2s(dynindex);
						SiCall(changeName, arrayPush(args, output));
					} else {
						c;
					}
				}
				SiConstructor(name, args): {
					reuseConstructor(names, c, type, output)
				}
				SiSeq(s): reuseSeq(c, output);
				SiIf(cn, then, else_): {
					if (isSiDyn(cn)) {
						code
					} else {
						SiIf(cn, reuseOldOutput(names, then, type, output), reuseOldOutput(names, else_, type, output));
					}
				}
				SiSwitch(var, cases): {
					if (isSiDyn(var)) {
						code;
					} else {
						SiSwitch(var,
							map(cases, \cs -> {
								SiCase(cs.struct, cs.args, 
									reuseOldOutput(names, cs.body, type, output)
								)
							})
						)
					}
				}
				default: c;
			}
		}
		SiCall(name, args): output;
	}
}

reuseConstructor(names : FiGlobalNames, code : SiConstructor, type : FiType, output : SiExp) -> SiExp {
	switch (type : FiType) {
		FiTypeVoid(): code;
		FiTypeBool(): code;
		FiTypeInt(): code;
		FiTypeDouble(): code;
		FiTypeString(): code;
		FiTypeArray(at): code;
		FiTypeFunction(args, returnType): code;
		FiTypeRef(t): code;
		FiTypeFlow(): code;
		FiTypeNative(): code;
		FiTypeName(name, typeparameters): {
			stype = resolveFiTypeName(names, type);
			switch (stype) {
				FiTypeStruct(sname, typars, sfields, start): {
					if (SiStructName(sname) == code.name) {
						SiConstructor(code.name,
							mapi(sfields, \i, field -> {
								reuseOldOutput(names, code.fields[i], field.type, SiField(output, i))
							})
						);
					} else {
						// OK, too bad, we have to just redo it
						code;
					}
				}
				FiTypeUnion(n, typars, ss, start): {
					// We expect a result of a given union.
					// Our code produces a value of a given struct type.
					// That struct type should be a part of the union, so find it
					// and we can reuse as if the result was just that struct.
					mstruct = find(ss, \s -> SiStructName(s.name) == code.name);
					switch (mstruct) {
						None(): code;
						Some(str): reuseConstructor(names, code, str, output)
					}
				}
			}
		}

		FiTypeParameter(__): code;
	}
}

reuseSeq(code : SiSeq, output : SiExp) -> SiExp {
	seq = code.seq;
	// We can drop all the non-dyn parts
	dynparts = filter(seq, isSiDyn);
	if (dynparts == []) output
	else {
		// Here we keep just the dyn parts, plus the final result if that is not dynamic
		if (seq != []) {
			last = lastElement(seq, seq[0]);
			if (isSiDyn(last)) {
				// TODO: If the last is an if, call, constructor, seq, which is not 
				// fully dynamic, there is still an opportunity to reuse stuff
				// so we should recursively call reuse on the last element
				SiSeq(dynparts);
			} else {
				SiSeq(arrayPush(dynparts, output));
			}
		} else {
			code;
		}
	}
}

