import tools/flowc/backends/common;
import tools/flowc/backends/bytecode/fi2bytecode_defines;

export {
	// Start producing debug info for this file
	diBcDebugStartFile(cfg : FcBytecodeConfig, file : string) -> void;
	diBcDebugEndFile(cfg : FcBytecodeConfig, resolvers : Tree<string, LineResolver>, file : string) -> void;

	// Add explanation for this point in the bytecode for this file to the debug info
	// pc is bytecode position. pos is source file position. isStart is set for
	// functions. comment is meta-info about what kind of debug point this is
	fiBcDebugAddPosition(cfg : FcBytecodeConfig, 
		pc : int, pos : int, isStart : bool, comment : BcDebugKind
	) -> void;

	// Add a function to the debug info
	fiBcDebugAddFunction(cfg : FcBytecodeConfig, pc : int, name : string) -> void;

	// Add a local variable to the debug info
	fiBcDebugAddLocal(cfg : FcBytecodeConfig, pc : int, type : int, id : int, name : string) -> void;

	// Mark the end of the bytecode
	fiBcDebugEndOfBytecode(cfg : FcBytecodeConfig, pc : int) -> void;

	// Build the debug info for this program
	fcBcMakeDebugInfo(cfg : FcBytecodeConfig) -> string;
}

diBcDebugStartFile(cfg : FcBytecodeConfig, file : string) -> void {
	if (cfg.debug) {
		cfg.debugInfo.currentPositions := makeList();
	}
}

diBcDebugEndFile(cfg : FcBytecodeConfig, resolvers : Tree<string, LineResolver>, file : string) -> void {
	if (cfg.debug) {
		filename = resolveRelativePath(file);

		poss : List<BCDPosition> = ^(cfg.debugInfo.currentPositions);

		lineResolverM : Maybe<LineResolver> = lookupTree(resolvers, file);
		lineResolverM ?? {
			// TODO: Grab all the positions and turn into lines like this:

			// Extract all positions in the file we have to resolve to line:col pars
			positions : Set<int> = foldList(poss, makeSet(), \acc, pos : BCDPosition -> {
				insertSet(acc, pos.pos)
			});

			lineCols = buildLineCols(lineResolverM, positions);

			// <pc> <file> <line> <col>
			// 492 C:\flow9\lib\dynamic.flow 65 0

			// We have collisions: The same bytecode can correspond to multiple nodes

			/*
			address = (if (isDebugVerbose) i2s(v.pc) + " :[" + "0x" + lpad(toLowerCase(formatHex(v.pc)), "0", 8) + "]" else i2s(v.pc));
			line = (address + " ") 
				+ filename) 
				+ " " + i2s(lineCol.first) + " " 
				+ i2s(lineCol.second)) 
				+ (if (isDebugVerbose) " " + toString(v.comment) else "") 
				+ "\n";
			*/
			fileDebugInfo = "<pc> " + filename + " <line> <col>\n";
			cfg.debugInfo.positions := Cons(fileDebugInfo, ^(cfg.debugInfo.positions));
		} : {
			println("Invariant broken: Could not find resolver for " + file);
		}
	}
}

fiBcDebugAddPosition(cfg : FcBytecodeConfig, pc : int, pos : int, isStart : bool, comment : BcDebugKind) -> void {
	if (cfg.debug) {
		debugInfo = cfg.debugInfo;
		p = BCDPosition(pc, pos, comment);
		debugInfo.currentPositions := Cons(p, ^(debugInfo.currentPositions));
	}
}

fiBcDebugEndOfBytecode(cfg : FcBytecodeConfig, pc : int) -> void {
	cfg.debugInfo.endByte := pc;
}

fiBcDebugAddFunction(cfg, pc, name) {
	if (cfg.debug) {
		cfg.debugInfo.functions := Cons(BCDFunction(pc, name), ^(cfg.debugInfo.functions));
	}
}

fiBcDebugAddLocal(cfg, pc, type, id, name) {
	if (cfg.debug) {
		cfg.debugInfo.locals := Cons(BCDLocal(pc, type, id, name), ^(cfg.debugInfo.locals));
		{}
	}
}



fcBcMakeDebugInfo(cfg : FcBytecodeConfig) -> string {
	// TODO: this parameter is only required for debugging debuginfo generation itself.
	// Subject to remove as well as comment field in BCDPosition
	isDebugVerbose = cfg.debugVerbose;

	debugInfo = cfg.debugInfo;

	// First section of the debug info is
	//     position function-name
	fcVerbose(cfg, 1, "Preparing functions...");
	functions0 = fold(
		list2sortedArray(^(debugInfo.functions), \p -> p.pc),
		makeList(),
		\acc, v -> {
			Cons((if (isDebugVerbose) i2s(v.pc) + " :[" + "0x" + lpad(toLowerCase(formatHex(v.pc)), "0", 8) + "]" else i2s(v.pc)) + " " + v.name + "\n", acc);
		});
	functions : string = list2string(functions0);

	fcVerbose(cfg, 1, "Preparing positions...");
	// Second section of the debug info is line positions
	//    position file line token-index/column
	positions : string = 
		concatStrings(list2array(^(debugInfo.positions)))
		+ i2s(^(debugInfo.endByte)) + " --end-- 0 -1";

	// Third part of the debug info are local variables
	//    L position type id name
	// Types: 0 for local variables, 1 for function arguments, 2 for bound variables (free variables in closures)

	fcVerbose(cfg, 1, "Preparing locals...");
	sorted = list2sortedArray(^(debugInfo.locals), \p -> p.pc);
	locals : string = list2string(fold(
		sorted,
		makeList(),
		\acc, e -> {
			Cons("L " + (if (isDebugVerbose) i2s(e.pc) + " :[" + "0x" + lpad(toLowerCase(formatHex(e.pc)), "0", 8) + "]" else i2s(e.pc))
				+ " " + i2s(e.type) + " " + i2s(e.id) + " " + e.name + "\n", acc
			)
		}
	));

	list2string(Cons(locals, Cons("\n", Cons(positions, Cons("\n", Cons(functions, makeList()))))));
}

/*

fold(
			mergeSort(getTreeValues(cfg.debugInfoPositions), \a : BCDPosition, b : BCDPosition -> {
				if (a.pc == b.pc) 0	else if (a.pc < b.pc) -1 else 1;
			}),
			makeList(),
			\acc, v : BCDPosition -> {
				filename = switch (lookupTree(ctx.program.modules, v.file)) {
					Some(m) : {
						m.fileinfo.fullpath;
					}
					None() : v.file
				}

				lineCol = switch(lookupTree(ctx.resolvers, v.file)) {
					Some(r) : {
						// Here we use iabs() function as a workaround for
						// desugaring of switch cases with variables.
						// Refer to desugar.flow:989
						lc = findLineRaw(r, iabs(v.pos));
						Pair(lc.lineno, lc.column);
					}
					None() : Pair(v.pos, 0);
				}

				address = (if (isDebugVerbose) i2s(v.pc) + " :[" + "0x" + lpad(toLowerCase(formatHex(v.pc)), "0", 8) + "]" else i2s(v.pc));
				line = (address + " ") 
					+ (resolveRelativePath(filename)) 
					+ " " + i2s(lineCol.first) + " " 
					+ (if (filename == "--end--") "-1" else i2s(lineCol.second)) 
					+ (if (isDebugVerbose) " " + toString(v.comment) else "") 
					+ "\n";
				Cons(line, acc)
			}
		);

		positions = list2string(lines);

	*/
	
list2sortedArray(list : List<?>, key : (?) -> ??) -> [?] {
	t : Tree<??, [?]> = foldList(list, makeTree(), \acc, e -> {
		treePushToArrayValue(acc, key(e), e)
	});
	concatA(getTreeValues(t));
}	

// For a set of positions, construct the line-columns for them all
buildLineCols(lineResolve : LineResolver, positions : Set<int>) -> Tree<int, LineColumn> {
	makeTree();
}

