import tools/flowc/incremental/fi2flowsrc;
import tools/flowc/tests/incremental/stochastic_gen;

export {
	writeModule(module : FiModule) -> void;
	mutateModulesCorrectly(generated : GenModules) -> void;
}

mutateModulesCorrectly(generated : GenModules) -> void {
	ind = randomInt(length(generated.modules));
	module = ^(generated.modules[ind]);
	if (length(module.structs) > 0) {
		// A struct module
		struct = module.structs[0];
		
		addAStructField(ind, struct, generated);
		
		/*choice = randomInt(4);
		if (choice == 0) {
			// add a field
			addAStructField(ind, struct, generated);
		} else if (choice == 1) {
			// delete a field 
		} else if (choice == 2) {
			// rename a field
		} else if (choice == 3) {
			// change field type
		}*/
	} else if (length(module.unions) > 0) {
		// A union module
		choice = randomInt(2);
		if (choice == 0) {
			// Add a random struct to the union
			
		} else if (choice == 1) {
			// Remove a random struct from the union
			
			
		}
	} else if (length(module.functions) > 0) {
	
	} else if (length(module.globalVars) > 0) {
	
	}
	writeModule(^(generated.modules[ind]));
}

addAStructField(i : int, struct : FiTypeStruct, generated : GenModules) -> void {
	new_field = FiStructArg("f_" + i2s(length(struct.args)), generateType(^(generated.env), i), false);
	new_struct = FiTypeStruct(
		struct.name, [], 
		concat(struct.args, [new_field]), -1
	);
	println("\tfield " + new_field.name + " of type " + prettyFiType(dummyPretty, new_field.type, makeSet()) + " is added to struct " + struct.name);
	orig_module = ^(generated.modules[i]);
	generated.modules[i] := FiModule(orig_module with 
		structs = [new_struct],
		imports = generateImports(^(generated.env), new_struct)
	);
	generated.env := GenEnv(^(generated.env) with structs = setTree(^(generated.env).structs, struct.name, new_struct));
	modified_inds = foldi(generated.modules, [i],
		\j, acc, m -> {
			if (addAStructFieldInModule(^(generated.env), struct.name, new_field, m)) {
				concat(acc, [j])
			} else {
				acc
			}
		}
	)
	iter(modified_inds, \j -> writeModule(^(generated.modules[j])))
}

addAStructFieldInModule(env : GenEnv, struct : string, new_field : FiStructArg, modref : ref FiModule) -> bool {
	m = ^modref;
	if (length(m.structs) > 0) {
		false
	} else if (length(m.unions) > 0) {
		false
	} else if (length(m.functions) > 0) {
		func = m.functions[0];
		new_lambda = addAStructFieldInExp(env, struct, new_field, func.lambda);
		if (func.lambda == new_lambda) false else {
			println("\tmodule: " + m.fileinfo.flowfile + " changed");
			modref := FiModule(m with functions = [FiFunctionDec(func with lambda = cast(new_lambda : FiExp -> FiLambda))]);
			true
		}
	} else if (length(m.globalVars) > 0) {
		var = m.globalVars[0];
		new_value = addAStructFieldInExp(env, struct, new_field, var.value);
		if (var.value == new_value) false else {
			println("\tmodule: " + m.fileinfo.flowfile + " changed");
			modref := FiModule(m with globalVars = [FiGlobalVar(var with value = new_value)]);
			true
		}
	} else {
		false
	}
}

addAStructFieldInExp(env : GenEnv, struct : string, new_field : FiStructArg, ex : FiExp) -> FiExp {
	switch(ex) {
		FiLambda(__, body, __, __):
			FiLambda(ex with body = addAStructFieldInExp(env, struct, new_field, body));
		FiCall(f, args, __,__): 
			FiCall(ex with
				f = addAStructFieldInExp(env, struct, new_field, f),
				args = map(args, \arg -> addAStructFieldInExp(env, struct, new_field, arg))
			);
		FiVar(__, __,__): ex;
		FiCallPrim(op, es, __,__): {
			es1 = map(es, \e -> addAStructFieldInExp(env, struct, new_field, e));
			new_es = switch (op) {
				FcStructPrim(name): {
					if (name == struct) {
						concat(es1, [generateConstExpr(env, new_field.type)])
					} else {
						es1;
					}
				}
				default: 
					es1;
			}
			FiCallPrim(ex with es = new_es);
		}
		FiLet(__, t, e1, e2, __,__): 
			FiLet(ex with 
				e1 = addAStructFieldInExp(env, struct, new_field, e1),
				e2 = addAStructFieldInExp(env, struct, new_field, e2),
			);
		default: {
			ex;
		}
	}
}

writeModule(module : FiModule) -> void {
	src = fimodule2flowsrc(module);
	ensureDirectoryExists(dirName(module.fileinfo.fullpath));
	setFileContent(module.fileinfo.fullpath, src);
	{}
}
