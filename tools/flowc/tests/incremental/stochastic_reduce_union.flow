import tools/flowc/incremental/fi2flowsrc;
import tools/flowc/tests/incremental/stochastic_gen;

export {
	// Returns an array of indexes of changed modules
	reduceAUnion(i : int, union : FiTypeUnion, generated : GenModules) -> [int];
}

reduceAUnion(i : int, union : FiTypeUnion, generated : GenModules) -> [int] {
	if (length(union.typenames) == 1) [] else {
		type_ind = randomInt(length(union.typenames));
		removed_type = union.typenames[type_ind];
		println("\ttype " + removed_type.name + " is removed from the union " + union.name);
		orig_module = ^(generated.modules[i]);
		new_union = FiTypeUnion(union with 
			typenames = fold(union.typenames, [], \acc, tp -> if (tp == removed_type) acc else concat(acc, [tp]))
		);
		generated.modules[i] := FiModule(orig_module with 
			unions = [new_union],
			imports = generateImports(^(generated.env), new_union)
		);
		generated.env := GenEnv(^(generated.env) with unions = setTree(^(generated.env).unions, union.name, new_union));
		foldi(generated.modules, [i],
			\j, acc, m -> {
				if (reduceAUnionInModule(^(generated.env), union, removed_type.name, m)) {
					concat(acc, [j])
				} else {
					acc
				}
			}
		)
	}
}

reduceAUnionInModule(env : GenEnv, union : FiTypeUnion, removed_type : string, modref : ref FiModule) -> bool {
	m = ^modref;
	if (length(m.structs) > 0) {
		false
	} else if (length(m.unions) > 0) {
		false
	} else if (length(m.functions) > 0) {
		func = m.functions[0];
		new_lambda = reduceAUnionInExp(env, union, removed_type, func.lambda);
		if (func.lambda == new_lambda) false else {
			println("\tmodule: " + m.fileinfo.flowfile + " changed");
			modref := FiModule(m with functions = [FiFunctionDec(func with lambda = cast(new_lambda : FiExp -> FiLambda))]);
			true
		}
	} else if (length(m.globalVars) > 0) {
		var = m.globalVars[0];
		new_value = reduceAUnionInExp(env, union, removed_type, var.value);
		if (var.value == new_value) false else {
			println("\tmodule: " + m.fileinfo.flowfile + " changed");
			modref := FiModule(m with globalVars = [FiGlobalVar(var with value = new_value)]);
			true
		}
	} else {
		false
	}
}

reduceAUnionInExp(env : GenEnv, union : FiTypeUnion, removed_type : string, ex : FiExp) -> FiExp {
	switch(ex) {
		FiLambda(__, body, __, __):
			FiLambda(ex with body = reduceAUnionInExp(env, union, removed_type, body));
		FiCall(f, args, __,__): 
			FiCall(ex with
				f = reduceAUnionInExp(env, union, removed_type, f),
				args = map(args, \arg -> reduceAUnionInExp(env, union, removed_type, arg))
			);
		FiVar(__, __,__): ex;
		FiCallPrim(op, es, __,__): {
			ret = FiCallPrim(ex with es = map(es, \e -> reduceAUnionInExp(env, union, removed_type, e)));
			switch (op) {
				FcStructPrim(name): {
					if (name == removed_type) {
						generateConstExpr(env, FiTypeName(union.name, []));
					} else {
						ret;
					}
				}
				default: 
					ret;
			}
		}
		FiLet(__, t, e1, e2, __,__): 
			FiLet(ex with 
				e1 = reduceAUnionInExp(env, union, removed_type, e1),
				e2 = reduceAUnionInExp(env, union, removed_type, e2),
			);
		default: {
			ex;
		}
	}
}
