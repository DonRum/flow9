import material/material_ui;
import material/extra/filebrowser/material_filebrowser;

F3DEditorState(
	manager : MaterialManager,
	wh : DynamicBehaviour<WidthHeight>,
	mutable stage : native,
	scene : DynamicBehaviour<[F3DObject]>,
	tree : DynamicBehaviour<Transform<[MTreeNode<string>]>>,
	treeOrder : DynamicBehaviour<[MTreeOrderNode<string>]>,
	selected : DynamicBehaviour<Maybe<native>>,
	axes : DynamicBehaviour<bool>,
	grid : DynamicBehaviour<bool>,
	boxes : DynamicBehaviour<bool>
);

makeF3DEditorState(manager : MaterialManager) -> F3DEditorState {
	stageWH = makeWH();
	currentScene = make([F3DSceneLoader("images/3d/soccer/scene.json")]);
	currentTree = make(const([]));
	currentObject : DynamicBehaviour<Maybe<native>> = make(None());

	axesVisible = make(false);
	gridVisible = make(false);
	boxesVisible = make(false);

	F3DEditorState(
		manager,
		stageWH,
		makeClip(),
		currentScene,
		currentTree,
		make([]),
		currentObject,
		axesVisible,
		gridVisible,
		boxesVisible
	)
}

printF3DChildren(id : string, object : F3DNative) -> F3DNative {
	switch (object : F3DNative) {
		F3DNativeScene(clip, items): {
			println(id + (if (strlen(id) > 0) " " else "") + get3DObjectType(clip) + " " + get3DObjectName(clip));

			F3DNativeScene(clip, fmapi(items, \i, it -> printF3DChildren(id + (if (strlen(id) > 0) " " else "") + i2s(i), it)));
		}
		F3DNativeObject(clip): {
			println(id + (if (strlen(id) > 0) " " else "") + get3DObjectType(clip) + " " + get3DObjectName(clip));

			object;
		}
		F3DNativeMutable(innerObject): {
			F3DNativeMutable(fselect(innerObject, FLift(\it -> printF3DChildren(id, it))));
		}
	}
}

makeF3DTreeNode(
	state : F3DEditorState,
	id : string,
	clip : native,
	children : Transform<[MTreeNode]>
) -> MTreeNode {
	sel = make(false);

	MTreeNode(
		get3DObjectId(clip),
		\__ ->
			MBaselineCols([
				MText(id, [MCaptionSolid()]),
				MConstruct(
					[
						\ -> add3DEventListener(clip, "attached", \ -> nextDistinct(sel, true)),
						\ -> add3DEventListener(clip, "detached", \ -> nextDistinct(sel, false)),
						make2Subscribe(sel, state.boxes, \sl, boxes -> {
							iter(get3DObjectStage(clip), \s -> {
								if (sl) {
									attach3DTransformControls(s, clip);
									next(state.selected, Some(clip));
								} else {
									detach3DTransformControls(s, clip);

									if (getValue(state.selected) == Some(clip)) {
										next(state.selected, None());
									}
								}

								if (sl && boxes) {
									attach3DBoxHelper(s, clip);
								} else {
									detach3DBoxHelper(s, clip);
								}
							});
						}),
						\ -> \ -> {
							iter(get3DObjectStage(clip), \s -> {
								if (getValue(state.selected) == Some(clip)) {
									next(state.selected, None());
								}

								detach3DTransformControls(s, clip);
								detach3DBoxHelper(s, clip);
							});
						}
					],
					MCheckBox(
						TEmpty(),
						make(get3DObjectVisible(clip)),
						[
							MIconButtonBorder(6.0),
							MIconSize(16.0),
							MOnNewValue(\v -> set3DObjectVisible(clip, v))
						]
					)
				),
				MText(get3DObjectType(clip) + "  ", [MCaptionSolid()]),
				MIf(
					sel,
					MCreate(\ ->
						MTextInput(
							make(get3DObjectName(clip)),
							[
								MCondensed(true),
								MCustomTextStyle([MCaption1()]),
								MInputBorders(0., 0., 0., 4.)
							],
							[
								MInputFilter(\c, f -> {
									if (!f) {
										set3DObjectName(clip, c);
										get3DObjectName(clip);
									} else {
										c;
									}
								})
							]
						)
					),
					// MCreate(\ -> MText(get3DObjectName(clip), [MCaptionSolid(), getPrimaryColor(state.manager)])),
					MCreate(\ -> MText(get3DObjectName(clip), [MCaption1()]))
				),
				MShow(
					sel,
					MIconButton(
						"delete",
						\ -> {
							removeF3DSceneId(state.treeOrder, get3DObjectId(clip));
						},
						[
							MIconButtonBorder(6.0),
							MIconSize(16.0)
						],
						[]
					)
				)
			]),
		children,
		[MExpanded(make(true)), MTreeNodeCustomHighlighter(\wh -> TFrame(0., 4., [MFill(MGrey(300))], TSized(wh))), MSelected(sel)]
	)
}

makeF3DTree(
	state : F3DEditorState,
	id : string,
	object : F3DNative
) -> Transform<MTreeNode> {
	switch (object : F3DNative) {
		F3DNativeScene(clip, items): {
			map(get3DObjectStage(clip), \s -> state.stage ::= s);

			const(makeF3DTreeNode(state, id, clip, fsubmapi(items, \i, it -> makeF3DTree(state, i2s(i), it))));
		}
		F3DNativeObject(clip): {
			map(get3DObjectStage(clip), \s -> state.stage ::= s);

			const(makeF3DTreeNode(state, id, clip, const([])));
		}
		F3DNativeMutable(innerObject): {
			fsubselect(innerObject, FLift(\it -> makeF3DTree(state, id, it)));
		}
	}
}

makeF3DScene(state : F3DEditorState, node : MTreeOrderNode<string>) -> F3DNative {
	children = fgetValue(node.children);
	clip = get3DObjectById(state.stage, node.content)[0];

	if (length(children) > 0) {
		F3DNativeScene(clip, const(map(children, \c -> makeF3DScene(state, c))));
	} else {
		F3DNativeObject(clip);
	}
}

removeF3DSceneId(nodes : DynamicBehaviour<[MTreeOrderNode<string>]>, id : string) -> void {
	nextDistinct(
		nodes,
		filter(getValue(nodes), \n -> {
			removeF3DSceneId(n.children, id);
			n.content != id;
		})
	);
}

F3DObjectProperties(object : native) -> Material {
	map(
		[
			Pair(
				"Type",
				MTextInput(make(get3DObjectType(object)), [MCondensed(true), ReadOnly(true)], [])
			),
			Pair(
				"UUID",
				MTextInput(make(get3DObjectId(object)), [MCondensed(true), ReadOnly(true)], [])
			),
			// Pair(
			// 	"Name",
			// 	MTextInput(
			// 		make(get3DObjectName(object)),
			// 		[MCondensed(true)],
			// 		[
			// 			MInputFilter(\c, f -> {
			// 				if (!f) {
			// 					set3DObjectName(object, c);
			// 					get3DObjectName(object);
			// 				} else {
			// 					c;
			// 				}
			// 			})
			// 		]
			// 	),
			// ),
			Pair(
				"Position",
				{
					x = make(d2s(get3DObjectX(object)));
					y = make(d2s(get3DObjectY(object)));
					z = make(d2s(get3DObjectZ(object)));

					MConstruct(
						[
							\ -> add3DObjectPositionListener(object, \nx, ny, nz -> {
								nextDistinct(x, nx |> d2s);
								nextDistinct(y, ny |> d2s);
								nextDistinct(z, nz |> d2s);
							})
						],
						MBaselineCols([
							MTextInput(
								x,
								[MCondensed(true)],
								[
									MInputFilter(\c, f -> {
										if (!f) {
											set3DObjectX(object, s2d(c));
											get3DObjectX(object) |> d2s;
										} else {
											c;
										}
									})
								]
							),
							MFixedX(16.0),
							MTextInput(
								y,
								[MCondensed(true)],
								[
									MInputFilter(\c, f -> {
										if (!f) {
											set3DObjectY(object, s2d(c));
											get3DObjectY(object) |> d2s;
										} else {
											c;
										}
									})
								]
							),
							MFixedX(16.0),
							MTextInput(
								z,
								[MCondensed(true)],
								[
									MInputFilter(\c, f -> {
										if (!f) {
											set3DObjectZ(object, s2d(c));
											get3DObjectZ(object) |> d2s;
										} else {
											c;
										}
									})
								]
							),
						])
					);
				}
			),
			Pair(
				"Rotation",
				{
					x = make(d2s(get3DObjectRotationX(object)));
					y = make(d2s(get3DObjectRotationY(object)));
					z = make(d2s(get3DObjectRotationZ(object)));

					MConstruct(
						[
							\ -> add3DObjectRotationListener(object, \nx, ny, nz -> {
								nextDistinct(x, nx |> d2s);
								nextDistinct(y, ny |> d2s);
								nextDistinct(z, nz |> d2s);
							})
						],
						MBaselineCols([
							MTextInput(
								x,
								[MCondensed(true)],
								[
									MInputFilter(\c, f -> {
										if (!f) {
											set3DObjectRotationX(object, s2d(c));
											get3DObjectRotationX(object) |> d2s;
										} else {
											c;
										}
									})
								]
							),
							MFixedX(16.0),
							MTextInput(
								y,
								[MCondensed(true)],
								[
									MInputFilter(\c, f -> {
										if (!f) {
											set3DObjectRotationY(object, s2d(c));
											get3DObjectRotationY(object) |> d2s;
										} else {
											c;
										}
									})
								]
							),
							MFixedX(16.0),
							MTextInput(
								z,
								[MCondensed(true)],
								[
									MInputFilter(\c, f -> {
										if (!f) {
											set3DObjectRotationZ(object, s2d(c));
											get3DObjectRotationZ(object) |> d2s;
										} else {
											c;
										}
									})
								]
							),
						])
					);
				}
			),
			Pair(
				"Scale",
				{
					x = make(d2s(get3DObjectScaleX(object)));
					y = make(d2s(get3DObjectScaleY(object)));
					z = make(d2s(get3DObjectScaleZ(object)));

					MConstruct(
						[
							\ -> add3DObjectScaleListener(object, \nx, ny, nz -> {
								nextDistinct(x, nx |> d2s);
								nextDistinct(y, ny |> d2s);
								nextDistinct(z, nz |> d2s);
							})
						],
						MBaselineCols([
							MTextInput(
								x,
								[MCondensed(true)],
								[
									MInputFilter(\c, f -> {
										if (!f) {
											set3DObjectScaleX(object, s2d(c));
											get3DObjectScaleX(object) |> d2s;
										} else {
											c;
										}
									})
								]
							),
							MFixedX(16.0),
							MTextInput(
								y,
								[MCondensed(true)],
								[
									MInputFilter(\c, f -> {
										if (!f) {
											set3DObjectScaleY(object, s2d(c));
											get3DObjectScaleY(object) |> d2s;
										} else {
											c;
										}
									})
								]
							),
							MFixedX(16.0),
							MTextInput(
								z,
								[MCondensed(true)],
								[
									MInputFilter(\c, f -> {
										if (!f) {
											set3DObjectScaleZ(object, s2d(c));
											get3DObjectScaleZ(object) |> d2s;
										} else {
											c;
										}
									})
								]
							),
						])
					);
				}
			),
			Pair(
				"Shadow",
				MBaselineCols([
					MCheckBox(
						MText("Cast", []),
						make(get3DObjectCastShadow(object)),
						[
							MOnNewValue(\v -> set3DObjectCastShadow(object, v))
						]
					),
					MCheckBox(
						MText("Recieve", []),
						make(get3DObjectReceiveShadow(object)),
						[
							MOnNewValue(\v -> set3DObjectReceiveShadow(object, v))
						]
					),
					TFillX()
				])
			),
			// Pair(
			// 	"Visible",
			// 	MBaselineCols([
			// 		MCheckBox(
			// 			TEmpty(),
			// 			make(get3DObjectVisible(object)),
			// 			[
			// 				MOnNewValue(\v -> set3DObjectVisible(object, v))
			// 			]
			// 		),
			// 		TFillX()
			// 	])
			// ),
			Pair(
				"Frustum Cull",
				MBaselineCols([
					MCheckBox(
						TEmpty(),
						make(get3DObjectFrustumCulled(object)),
						[
							MOnNewValue(\v -> set3DObjectFrustumCulled(object, v))
						]
					),
					TFillX()
				])
			)
		],
		\p ->
			MProportionBaselineCols([
				Pair(const(0.25), MGroup2(TFillX(), MText(p.first + ": ", []))),
				Pair(const(0.75), p.second)
			])
	)
	|> MLinesYCenter
}

main() {
	manager = makeMaterialManager([makeMaterialTheme(true, MPurpleA(700), MLightGreenA(700))]);
	state = makeF3DEditorState(manager);

	exportFn = ref \ -> "";

	scene =
		F3DChildren(
			F3DScene(fmap(state.scene, \c -> F3DObject2Json(c, exportFn))),
			\c -> {
				next(state.tree, farray(makeF3DTree(state, "0", c)));

				printF3DChildren("0", c);
			}
		);
	camera =
		F3DPosition(
			F3DPerspectiveCamera(const(50.0), fdivide(fwidth(state.wh), fheight(state.wh)), const(0.01), const(6000.0)),
			make(0.0), make(0.0), make(1000.0)
		);

	MLines2ReverseZorder(
		MMenuPanel(
			[
				MMenu(
					MTextButton("File", nop, [], []),
					[
						MMenuSingleLine(
							"Open Scene",
							[
								MPrimaryAction(MIcon("folder_open", [])),
								MOnClick(\ ->
									openFileDialog(1, ["*.txt", "*.json"], \ff ->
										iter(ff, \f ->
											readFileClient(
												f,
												"text",
												\s -> {
													next(state.scene, []);
													next(state.scene, [F3DJsonObject(s)]);
												},
												println
											)
										)
									)
								)
							]
						),
						MMenuSingleLine(
							"Save Scene",
							[
								MPrimaryAction(MIcon("save", [])),
								MOnClick(\ -> {saveFileClient("scene.json", ^exportFn(), "text")})
							]
						)
					],
					[
						MMenuIndent()
					]
				),
				MMenu(
					MTextButton("View", nop, [], []),
					[
						MMenuSingleLine(
							"Axes",
							[
								MPrimaryAction(MIf(state.axes, MIcon("check_box", []), MIcon("check_box_outline_blank", []))),
								MOnClick(\ -> reverseBehaviour(state.axes))
							]
						),
						MMenuSingleLine(
							"Grid",
							[
								MPrimaryAction(MIf(state.grid, MIcon("grid_on", []), MIcon("grid_off", []))),
								MOnClick(\ -> reverseBehaviour(state.grid))
							]
						),
						MMenuSingleLine(
							"Boxes",
							[
								MPrimaryAction(MIf(state.boxes, MIcon("check_box", []), MIcon("check_box_outline_blank", []))),
								MOnClick(\ -> reverseBehaviour(state.boxes))
							]
						)
					],
					[
						MMenuIndent()
					]
				)
			],
			[]
		),
		MSplitter(
			M3DStage(
				F3DScene(const([
					F3DVisible(F3DAxesHelper(2500.0), state.axes),
					F3DVisible(F3DGridHelper(5000.0, 50, 0xaaaaaa, 0xffffff), state.grid),
					scene
				])),
				camera,
				TFillXY(),
				[
					F3DTransformControlsEnabled(const(true))
				]
			)
			|> (\f -> MInspect([ISize(state.wh)], f))
			|> (\f -> MFrame(0.0, 0.0, [MFill(MGrey(200))], f)),
			MSplitter(
				MTree(
					fsubselect(state.tree, idfn |> FLift),
					[
						MTreeHideSeparators(),
						MTreeOrder(state.treeOrder),
						MTreeOnOrderChange(\t -> {
							if (length(t) > 0 && length(getValue(t[0].children)) > 0) {
								next(state.scene, map(getValue(t[0].children), \c -> makeF3DScene(state, c)));
							}
						})
					]
				)
				|> (\f -> MBorder(8.0, 8.0, 16.0, 8.0, f)),
				MSelect(state.selected, \o -> eitherMap(o, \c -> F3DObjectProperties(c), TEmpty()))
				|> (\f -> MBorder(24.0, 8.0, 24.0, 8.0, f)),
				TFillXY(),
				[
					MSplitterValue(make(0.6)),
					MSplitterHorizontal()
				]
			),
			TFillXY(),
			[MSplitterValue(make(0.8))]
		)
	)
	|> MCenterX
	|> (\f -> mrender(manager, true, f))
}

MLines2ReverseZorder(c1 : Material, c2 : Material) -> Material {
	MCopySize2(
		c1,
		\sz, c -> MGroup2(MLines2(sz, c2), c)
	)
}