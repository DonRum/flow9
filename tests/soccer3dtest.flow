import material/material_ui;
import material/extra/filebrowser/material_filebrowser;

F3DEditorState(
	manager : MaterialManager,
	wh : DynamicBehaviour<WidthHeight>,
	mutable stage : native,
	scene : DynamicBehaviour<[F3DObject]>,
	tree : DynamicBehaviour<Transform<[MTreeNode<string>]>>,
	treeOrder : DynamicBehaviour<[MTreeOrderNode<string>]>,
	selected : DynamicBehaviour<Maybe<native>>,
	undoStack : DynamicBehaviour<[string]>,
	axes : DynamicBehaviour<bool>,
	grid : DynamicBehaviour<bool>,
	boxes : DynamicBehaviour<bool>
);

makeF3DEditorState(manager : MaterialManager) -> F3DEditorState {
	stageWH = makeWH();
	currentScene = make([F3DSceneLoader("images/3d/soccer/scene.json")]);
	currentTree = make(const([]));
	currentObject : DynamicBehaviour<Maybe<native>> = make(None());

	axesVisible = make(false);
	gridVisible = make(false);
	boxesVisible = make(false);

	F3DEditorState(
		manager,
		stageWH,
		makeClip(),
		currentScene,
		currentTree,
		make([]),
		currentObject,
		make([]),
		axesVisible,
		gridVisible,
		boxesVisible
	)
}

printF3DChildren(id : string, object : F3DNative) -> F3DNative {
	switch (object : F3DNative) {
		F3DNativeScene(clip, items): {
			println(id + (if (strlen(id) > 0) " " else "") + get3DObjectType(clip) + " " + get3DObjectName(clip));

			F3DNativeScene(clip, fmapi(items, \i, it -> printF3DChildren(id + (if (strlen(id) > 0) " " else "") + i2s(i), it)));
		}
		F3DNativeObject(clip): {
			println(id + (if (strlen(id) > 0) " " else "") + get3DObjectType(clip) + " " + get3DObjectName(clip));

			object;
		}
		F3DNativeMutable(innerObject): {
			F3DNativeMutable(fselect(innerObject, FLift(\it -> printF3DChildren(id, it))));
		}
		default: {
			object;
		}
	}
}

makeF3DTreeNode(
	state : F3DEditorState,
	id : string,
	clip : native,
	children : Transform<[MTreeNode]>
) -> MTreeNode {
	sel = make(false);
	name = make(get3DObjectName(clip));
	iter(get3DObjectStage(clip), \s -> nextDistinct(sel, is3DTransformControlsAttached(s, clip)));

	MTreeNode(
		get3DObjectId(clip),
		\__ ->
			MBaselineCols([
				MText(id, [MCaptionSolid()]),
				MConstruct(
					[
						\ -> add3DEventListener(clip, "attached", \ -> nextDistinct(sel, true)),
						\ -> add3DEventListener(clip, "detached", \ -> nextDistinct(sel, false)),
						\ -> add3DEventListener(clip, "namechanged", \ -> nextDistinct(name, get3DObjectName(clip))),
						make2Subscribe(sel, state.boxes, \sl, boxes -> {
							iter(get3DObjectStage(clip), \s -> {
								if (sl) {
									clear3DTransformControls(s);
									appendF3DUndo(state);
									attach3DTransformControls(s, clip);

									next(state.selected, Some(clip));
								} else {
									detach3DTransformControls(s, clip);

									if (getValue(state.selected) == Some(clip)) {
										next(state.selected, None());
									}
								}

								if (sl && boxes) {
									attach3DBoxHelper(s, clip);
								} else {
									detach3DBoxHelper(s, clip);
								}
							});
						}),
						\ -> \ -> {
							iter(get3DObjectStage(clip), \s -> {
								if (getValue(state.selected) == Some(clip)) {
									next(state.selected, None());
								}

								detach3DTransformControls(s, clip);
								detach3DBoxHelper(s, clip);
							});
						}
					],
					MCheckBox(
						TEmpty(),
						make(get3DObjectVisible(clip)),
						[
							MIconButtonBorder(6.0),
							MIconSize(16.0),
							MOnNewValue(\v -> {
								appendF3DUndo(state);
								set3DObjectVisible(clip, v);
							})
						]
					)
				),
				MText(get3DObjectType(clip) + "  ", [MCaptionSolid()]),
				MIf(
					sel,
					MCreate(\ ->
						MTextInput(
							name,
							[
								MCondensed(true),
								MCustomTextStyle([MCaption1()]),
								MInputBorders(0., 0., 0., 4.)
							],
							[
								MInputFilter(\c, f -> {
									if (!f) {
										set3DObjectName(clip, c);
										get3DObjectName(clip);
									} else {
										c;
									}
								}),
								MOnFocus(\__ -> appendF3DUndo(state))
							]
						)
					),
					// MCreate(\ -> MText(get3DObjectName(clip), [MCaptionSolid(), getPrimaryColor(state.manager)])),
					MCreate(\ -> MText(get3DObjectName(clip), [MCaption1()]))
				),
				MShow(
					sel,
					MIconButton(
						"delete",
						\ -> {
							appendF3DUndo(state);
							removeF3DSceneId(state.treeOrder, get3DObjectId(clip));
						},
						[
							MIconButtonBorder(6.0),
							MIconSize(16.0)
						],
						[]
					)
				)
			]),
		children,
		[MExpanded(make(true)), MTreeNodeCustomHighlighter(\wh -> TFrame(0., 4., [MFill(MGrey(300))], TSized(wh))), MSelected(sel)]
	)
}

makeF3DTree(
	state : F3DEditorState,
	id : string,
	object : F3DNative
) -> Transform<MTreeNode> {
	switch (object : F3DNative) {
		F3DNativeScene(clip, items): {
			map(get3DObjectStage(clip), \s -> state.stage ::= s);

			const(makeF3DTreeNode(state, id, clip, fsubmapi(items, \i, it -> makeF3DTree(state, i2s(i), it))));
		}
		F3DNativeObject(clip): {
			map(get3DObjectStage(clip), \s -> state.stage ::= s);

			const(makeF3DTreeNode(state, id, clip, const([])));
		}
		F3DNativeMutable(innerObject): {
			fsubselect(innerObject, FLift(\it -> makeF3DTree(state, id, it)));
		}
		F3DNativeOnLoad(innerObject, onLoad): {
			makeF3DTree(state, id, innerObject)
		}
	}
}

Point3D(x : double, y : double, z : double);

makeF3DScene(state : F3DEditorState, node : MTreeOrderNode<string>) -> F3DNative {
	children = fgetValue(node.children);
	clip = get3DObjectById(state.stage, node.content)[0];

	position = Point3D(get3DObjectWorldX(clip), get3DObjectWorldY(clip), get3DObjectWorldZ(clip));
	rotation = Point3D(get3DObjectWorldRotationX(clip), get3DObjectWorldRotationY(clip), get3DObjectWorldRotationZ(clip));
	scale = Point3D(get3DObjectWorldScaleX(clip), get3DObjectWorldScaleY(clip), get3DObjectWorldScaleZ(clip));

	// println("---");
	// println(position);
	// println(rotation);
	// println(scale);

	F3DNativeOnLoad(
		if (length(children) > 0) {
			F3DNativeScene(clip, const(map(children, \c -> makeF3DScene(state, c))));
		} else {
			F3DNativeObject(clip);
		},
		\object -> {
			set3DObjectWorldX(object, position.x);
			set3DObjectWorldY(object, position.y);
			set3DObjectWorldZ(object, position.z);

			set3DObjectWorldRotationX(object, rotation.x);
			set3DObjectWorldRotationY(object, rotation.y);
			set3DObjectWorldRotationZ(object, rotation.z);

			set3DObjectWorldScaleX(object, scale.x);
			set3DObjectWorldScaleY(object, scale.y);
			set3DObjectWorldScaleZ(object, scale.z);
		}
	)
}

addF3DNativeObject(state : F3DEditorState, clip : native, name : string) -> void {
	t = getValue(state.treeOrder);

	if (length(t) > 0 && length(getValue(t[0].children)) > 0) {
		set3DObjectName(clip, name);

		node = getValue(t[0].children)[0];

		children = fgetValue(node.children);
		sceneClip = get3DObjectById(state.stage, node.content)[0];

		next(
			state.scene,
			[
				F3DNativeScene(
					sceneClip,
					const(
						arrayPush(
							map(children, \c -> makeF3DScene(state, c)),
							F3DNativeOnLoad(
								F3DNativeObject(clip),
								\object -> {
									iter(get3DObjectStage(object), \s -> {
										attach3DTransformControls(s, object);

										if (fgetValue(state.boxes)) {
											attach3DBoxHelper(s, object);
										}
									});
								}
							)
						)
					)
				)
			]
		);
	}
}

removeF3DSceneId(nodes : DynamicBehaviour<[MTreeOrderNode<string>]>, id : string) -> void {
	nextDistinct(
		nodes,
		filter(getValue(nodes), \n -> {
			removeF3DSceneId(n.children, id);
			n.content != id;
		})
	);
}

F3DObjectProperties(state : F3DEditorState, object : native) -> Material {
	map(
		[
			Pair(
				"Type",
				MTextInput(make(get3DObjectType(object)), [MCondensed(true), ReadOnly(true)], [])
			),
			Pair(
				"UUID",
				MTextInput(make(get3DObjectId(object)), [MCondensed(true), ReadOnly(true)], [])
			),
			// Pair(
			// 	"Name",
			// 	MTextInput(
			// 		make(get3DObjectName(object)),
			// 		[MCondensed(true)],
			// 		[
			// 			MInputFilter(\c, f -> {
			// 				if (!f) {
			// 					set3DObjectName(object, c);
			// 					get3DObjectName(object);
			// 				} else {
			// 					c;
			// 				}
			// 			})
			// 		]
			// 	),
			// ),
			Pair(
				"Position",
				{
					x = make(d2s(get3DObjectX(object)));
					y = make(d2s(get3DObjectY(object)));
					z = make(d2s(get3DObjectZ(object)));

					MConstruct(
						[
							\ -> add3DObjectPositionListener(object, \nx, ny, nz -> {
								nextDistinct(x, nx |> d2s);
								nextDistinct(y, ny |> d2s);
								nextDistinct(z, nz |> d2s);
							})
						],
						MBaselineCols([
							MTextInput(
								x,
								[MCondensed(true)],
								[
									MInputFilter(\c, f -> {
										if (!f) {
											set3DObjectX(object, s2d(c));
											get3DObjectX(object) |> d2s;
										} else {
											c;
										}
									}),
									MOnFocus(\__ -> appendF3DUndo(state))
								]
							),
							MFixedX(16.0),
							MTextInput(
								y,
								[MCondensed(true)],
								[
									MInputFilter(\c, f -> {
										if (!f) {
											set3DObjectY(object, s2d(c));
											get3DObjectY(object) |> d2s;
										} else {
											c;
										}
									}),
									MOnFocus(\__ -> appendF3DUndo(state))
								]
							),
							MFixedX(16.0),
							MTextInput(
								z,
								[MCondensed(true)],
								[
									MInputFilter(\c, f -> {
										if (!f) {
											set3DObjectZ(object, s2d(c));
											get3DObjectZ(object) |> d2s;
										} else {
											c;
										}
									}),
									MOnFocus(\__ -> appendF3DUndo(state))
								]
							),
						])
					);
				}
			),
			Pair(
				"Rotation",
				{
					x = make(d2s(get3DObjectRotationX(object)));
					y = make(d2s(get3DObjectRotationY(object)));
					z = make(d2s(get3DObjectRotationZ(object)));

					MConstruct(
						[
							\ -> add3DObjectRotationListener(object, \nx, ny, nz -> {
								nextDistinct(x, nx |> d2s);
								nextDistinct(y, ny |> d2s);
								nextDistinct(z, nz |> d2s);
							})
						],
						MBaselineCols([
							MTextInput(
								x,
								[MCondensed(true)],
								[
									MInputFilter(\c, f -> {
										if (!f) {
											set3DObjectRotationX(object, s2d(c));
											get3DObjectRotationX(object) |> d2s;
										} else {
											c;
										}
									}),
									MOnFocus(\__ -> appendF3DUndo(state))
								]
							),
							MFixedX(16.0),
							MTextInput(
								y,
								[MCondensed(true)],
								[
									MInputFilter(\c, f -> {
										if (!f) {
											set3DObjectRotationY(object, s2d(c));
											get3DObjectRotationY(object) |> d2s;
										} else {
											c;
										}
									}),
									MOnFocus(\__ -> appendF3DUndo(state))
								]
							),
							MFixedX(16.0),
							MTextInput(
								z,
								[MCondensed(true)],
								[
									MInputFilter(\c, f -> {
										if (!f) {
											set3DObjectRotationZ(object, s2d(c));
											get3DObjectRotationZ(object) |> d2s;
										} else {
											c;
										}
									}),
									MOnFocus(\__ -> appendF3DUndo(state))
								]
							),
						])
					);
				}
			),
			Pair(
				"Scale",
				{
					x = make(d2s(get3DObjectScaleX(object)));
					y = make(d2s(get3DObjectScaleY(object)));
					z = make(d2s(get3DObjectScaleZ(object)));

					MConstruct(
						[
							\ -> add3DObjectScaleListener(object, \nx, ny, nz -> {
								nextDistinct(x, nx |> d2s);
								nextDistinct(y, ny |> d2s);
								nextDistinct(z, nz |> d2s);
							})
						],
						MBaselineCols([
							MTextInput(
								x,
								[MCondensed(true)],
								[
									MInputFilter(\c, f -> {
										if (!f) {
											set3DObjectScaleX(object, s2d(c));
											get3DObjectScaleX(object) |> d2s;
										} else {
											c;
										}
									}),
									MOnFocus(\__ -> appendF3DUndo(state))
								]
							),
							MFixedX(16.0),
							MTextInput(
								y,
								[MCondensed(true)],
								[
									MInputFilter(\c, f -> {
										if (!f) {
											set3DObjectScaleY(object, s2d(c));
											get3DObjectScaleY(object) |> d2s;
										} else {
											c;
										}
									}),
									MOnFocus(\__ -> appendF3DUndo(state))
								]
							),
							MFixedX(16.0),
							MTextInput(
								z,
								[MCondensed(true)],
								[
									MInputFilter(\c, f -> {
										if (!f) {
											set3DObjectScaleZ(object, s2d(c));
											get3DObjectScaleZ(object) |> d2s;
										} else {
											c;
										}
									}),
									MOnFocus(\__ -> appendF3DUndo(state))
								]
							),
						])
					);
				}
			),
			Pair(
				"Shadow",
				MBaselineCols([
					MCheckBox(
						MText("Cast", []),
						make(get3DObjectCastShadow(object)),
						[
							MOnNewValue(\v -> {
								appendF3DUndo(state);
								set3DObjectCastShadow(object, v);
							})
						]
					),
					MCheckBox(
						MText("Recieve", []),
						make(get3DObjectReceiveShadow(object)),
						[
							MOnNewValue(\v -> {
								appendF3DUndo(state);
								set3DObjectReceiveShadow(object, v);
							})
						]
					),
					TFillX()
				])
			),
			// Pair(
			// 	"Visible",
			// 	MBaselineCols([
			// 		MCheckBox(
			// 			TEmpty(),
			// 			make(get3DObjectVisible(object)),
			// 			[
			// 				MOnNewValue(\v -> set3DObjectVisible(object, v))
			// 			]
			// 		),
			// 		TFillX()
			// 	])
			// ),
			Pair(
				"Frustum Cull",
				MBaselineCols([
					MCheckBox(
						TEmpty(),
						make(get3DObjectFrustumCulled(object)),
						[
							MOnNewValue(\v -> {
								appendF3DUndo(state);
								set3DObjectFrustumCulled(object, v);
							})
						]
					),
					TFillX()
				])
			)
		],
		\p ->
			MProportionBaselineCols([
				Pair(const(0.25), MGroup2(TFillX(), MText(p.first + ": ", []))),
				Pair(const(0.75), p.second)
			])
	)
	|> MLinesYCenter
}

appendF3DUndo(state : F3DEditorState) -> void {
	iter(get3DStageScene(state.stage), \scene -> {
		undo = get3DObjectState(scene);
		stack = getValue(state.undoStack);

		if (length(stack) == 0 || undo != stack[length(stack) - 1]) {
			next(state.undoStack, arrayPush(stack, undo));
		}
	});
}

applyF3DUndo(state : F3DEditorState) -> void {
	stack = getValue(state.undoStack);

	if (length(stack) > 0) {
		undo = stack[length(stack) - 1];
		iter(get3DStageScene(state.stage), \scene -> {
			apply3DObjectState(scene, undo);
		});

		next(state.undoStack, subrange(stack, 0, length(stack) - 1));
	}
}

main() {
	manager = makeMaterialManager([makeMaterialTheme(true, MPurpleA(700), MLightGreenA(700))]);
	state = makeF3DEditorState(manager);

	exportFn = ref \ -> "";

	scene =
		F3DChildren(
			F3DScene(fmap(state.scene, \c -> F3DObject2Json(c, exportFn))),
			\c -> {
				next(state.tree, farray(makeF3DTree(state, "0", c)));

				// printF3DChildren("0", c);
				c;
			}
		);
	camera =
		F3DPosition(
			F3DPerspectiveCamera(const(50.0), fdivide(fwidth(state.wh), fheight(state.wh)), const(0.01), const(6000.0)),
			make(0.0), make(0.0), make(1000.0)
		);

	MLines2ReverseZorder(
		MMenuPanel(
			[
				MMenu(
					MTextButton("File", nop, [], []),
					[
						MMenuSingleLine(
							"Open Scene",
							[
								MPrimaryAction(MIcon("folder_open", [])),
								MOnClick(\ ->
									openFileDialog(1, ["*.txt", "*.json"], \ff ->
										iter(ff, \f ->
											readFileClient(
												f,
												"text",
												\s -> {
													next(state.scene, []);
													next(state.scene, [F3DJsonObject(s)]);
												},
												println
											)
										)
									)
								)
							]
						),
						MMenuSingleLine(
							"Save Scene",
							[
								MPrimaryAction(MIcon("save", [])),
								MOnClick(\ -> {saveFileClient("scene.json", ^exportFn(), "text")})
							]
						)
					],
					[
						MMenuIndent()
					]
				),
				MMenu(
					MTextButton("Edit", nop, [], []),
					[
						MMenuSingleLine(
							"Undo",
							[
								// MPrimaryAction(MIf(state.axes, MIcon("check_box", []), MIcon("check_box_outline_blank", []))),
								MOnClick(\ -> applyF3DUndo(state)),
								MAdditionalText("Ctrl+Z"),
								MEnabled(fneq(flength(state.undoStack), 0))
							]
						),
						MMenuSingleLine(
							"Redo",
							[
								// MPrimaryAction(MIf(state.grid, MIcon("grid_on", []), MIcon("grid_off", []))),
								// MOnClick(\ -> reverseBehaviour(state.grid)),
								MAdditionalText("Ctrl+Shift+Z"),
								MEnabled(const(false))
							]
						),
						// MMenuSingleLine(
						// 	"Boxes",
						// 	[
						// 		MPrimaryAction(MIf(state.boxes, MIcon("check_box", []), MIcon("check_box_outline_blank", []))),
						// 		MOnClick(\ -> reverseBehaviour(state.boxes))
						// 	]
						// )
					],
					[
						// MMenuIndent()
					]
				),
				MMenu(
					MTextButton("View", nop, [], []),
					[
						MMenuSingleLine(
							"Axes",
							[
								MPrimaryAction(MIf(state.axes, MIcon("check_box", []), MIcon("check_box_outline_blank", []))),
								MOnClick(\ -> reverseBehaviour(state.axes)),
								MAdditionalText("A")
							]
						),
						MMenuSingleLine(
							"Grid",
							[
								MPrimaryAction(MIf(state.grid, MIcon("grid_on", []), MIcon("grid_off", []))),
								MOnClick(\ -> reverseBehaviour(state.grid)),
								MAdditionalText("G")
							]
						),
						MMenuSingleLine(
							"Boxes",
							[
								MPrimaryAction(MIf(state.boxes, MIcon("check_box", []), MIcon("check_box_outline_blank", []))),
								MOnClick(\ -> reverseBehaviour(state.boxes)),
								MAdditionalText("B")
							]
						)
					],
					[
						MMenuIndent()
					]
				),
				MMenu(
					MTextButton("Add", nop, [], []),
					[
						MMenuSingleLine(
							"Group",
							[
								MOnClick(\ -> addF3DNativeObject(state, make3DScene(), "Group"))
							]
						),
						MSeparatorLine(),
						MMenuSingleLine(
							"Plane",
							[
								MOnClick(\ ->
									addF3DNativeObject(
										state,
										make3DMesh(
											make3DPlaneGeometry(1.0, 1.0, 1, 1),
											make3DMeshStandardMaterial(white, [])
										),
										"Plane"
									)
								)
							]
						),
						MMenuSingleLine(
							"Box",
							[
								MOnClick(\ ->
									addF3DNativeObject(
										state,
										make3DMesh(
											make3DBoxGeometry(1.0, 1.0, 1.0, 1, 1, 1),
											make3DMeshStandardMaterial(white, [])
										),
										"Box"
									)
								)
							]
						),
						MMenuSingleLine(
							"Circle",
							[
								MOnClick(\ ->
									addF3DNativeObject(
										state,
										make3DMesh(
											make3DCircleGeometry(1.0, 8, 0.0, 2.0 * PI),
											make3DMeshStandardMaterial(white, [])
										),
										"Circle"
									)
								)
							]
						),
						MMenuSingleLine(
							"Ring",
							[
								MOnClick(\ ->
									addF3DNativeObject(
										state,
										make3DMesh(
											make3DRingGeometry(0.5, 1.0, 8, 0.0, 2.0 * PI),
											make3DMeshStandardMaterial(white, [])
										),
										"Ring"
									)
								)
							]
						),
						MMenuSingleLine(
							"Cylinder",
							[
								MOnClick(\ ->
									addF3DNativeObject(
										state,
										make3DMesh(
											make3DCylinderGeometry(1.0, 1.0, 1.0, 8, 1, false, 0.0, 2.0 * PI),
											make3DMeshStandardMaterial(white, [])
										),
										"Cylinder"
									)
								)
							]
						),
						MMenuSingleLine(
							"Sphere",
							[
								MOnClick(\ ->
									addF3DNativeObject(
										state,
										make3DMesh(
											make3DSphereGeometry(1.0, 8, 6, 0.0, 2.0 * PI, 0.0, PI),
											make3DMeshStandardMaterial(white, [])
										),
										"Sphere"
									)
								)
							]
						),
						MSeparatorLine(),
						MMenuSingleLine(
							"Point Light",
							[
								MOnClick(\ ->
									addF3DNativeObject(
										state,
										make3DPointLight(white, 1.0, 0.0, 1.0),
										"Point Light"
									)
								)
							]
						),
						MMenuSingleLine(
							"Spot Light",
							[
								MOnClick(\ ->
									addF3DNativeObject(
										state,
										make3DSpotLight(white, 1.0, 0.0, 0.314, 0.0, 1.0),
										"Spot Light"
									)
								)
							]
						),
						MSeparatorLine(),
						MMenuSingleLine(
							"External Object",
							[
								MOnClick(\ ->
									openFileDialog(1, ["*.obj"], \ff ->
										iter(ff, \f ->
											readFileClient(
												f,
												"text",
												\s -> {
													openFileDialog(1, ["*.mtl"], \ff2 ->
														iter(ff2, \f2 ->
															readFileClient(
																f2,
																"text",
																\s2 -> {
																	addF3DNativeObject(
																		state,
																		make3DObjectFromObj(s, s2),
																		"Object"
																	);
																},
																println
															)
														)
													);
												},
												println
											)
										)
									)
								)
							]
						),
						// MMenuSingleLine(
						// 	"Ring",
						// 	[
						// 		MOnClick(\ -> addF3DNativeObject(state, make3DScene()))
						// 	]
						// ),
						// MMenuSingleLine(
						// 	"Grid",
						// 	[
						// 		MPrimaryAction(MIf(state.grid, MIcon("grid_on", []), MIcon("grid_off", []))),
						// 		MOnClick(\ -> reverseBehaviour(state.grid))
						// 	]
						// ),
						// MMenuSingleLine(
						// 	"Boxes",
						// 	[
						// 		MPrimaryAction(MIf(state.boxes, MIcon("check_box", []), MIcon("check_box_outline_blank", []))),
						// 		MOnClick(\ -> reverseBehaviour(state.boxes))
						// 	]
						// )
					],
					[
						// MMenuIndent()
					]
				)
			],
			[]
		),
		MSplitter(
			M3DStage(
				F3DScene(const([
					F3DVisible(F3DAxesHelper(2500.0), state.axes),
					F3DVisible(F3DGridHelper(5000.0, 50, 0xaaaaaa, 0xffffff), state.grid),
					scene
				])),
				camera,
				TFillXY(),
				[
					F3DTransformControlsEnabled(const(true))
				]
			)
			|> (\f -> MInspect([ISize(state.wh)], f))
			|> (\f -> MFrame(0.0, 0.0, [MFill(MGrey(200))], f))
			|> (\f ->
				MInteractive(
					[
						KeyDown(\ke -> {
							if (ke.keycode == 81) { // Q
								set3DTransformControlsSpace(state.stage, !is3DTransformControlsSpaceLocal(state.stage));
							} else if (ke.keycode == 17) { // Ctrl
								set3DTransformControlsTranslationSnap(state.stage, 100.0);
								set3DTransformControlsRotationSnap(state.stage, 15.0);
							} else if (ke.keycode == 87) { // W
								set3DTransformControlsMode(state.stage, "translate");
							} else if (ke.keycode == 69) { // E
								set3DTransformControlsMode(state.stage, "rotate");
							} else if (ke.keycode == 82) { // R
								set3DTransformControlsMode(state.stage, "scale");
							} else if (ke.keycode == 107) { // +, =, num+
								set3DTransformControlsSize(state.stage, get3DTransformControlsSize(state.stage) + 0.1);
							} else if (ke.keycode == 109) { // -, _, num-
								set3DTransformControlsSize(state.stage, max(get3DTransformControlsSize(state.stage) - 0.1, 0.1));
							} else if (ke.keycode == 88) { // X
								set3DTransformControlsShowX(state.stage, !get3DTransformControlsShowX(state.stage));
							} else if (ke.keycode == 89) { // Y
								set3DTransformControlsShowY(state.stage, !get3DTransformControlsShowY(state.stage));
							} else if (ke.keycode == 90) { // Z
								if (ke.ctrl) {
									if (ke.shift) {
										//
									} else {
										applyF3DUndo(state);
									}
								} else {
									set3DTransformControlsShowZ(state.stage, !get3DTransformControlsShowZ(state.stage));
								}
							} else if (ke.keycode == 32) { // Spacebar
								set3DTransformControlsEnabled(state.stage, !get3DTransformControlsEnabled(state.stage));
							} else if (ke.keycode == 65) { // A
								reverseBehaviour(state.axes);
							} else if (ke.keycode == 66) { // B
								reverseBehaviour(state.boxes);
							} else if (ke.keycode == 71) { // G
								reverseBehaviour(state.grid);
							}
						}),
						KeyUp(\ke -> {
							if (ke.keycode == 17) { // Ctrl
								set3DTransformControlsTranslationSnap(state.stage, 0.0);
								set3DTransformControlsRotationSnap(state.stage, 0.0);
							}
						}),
					],
					f
				)
			),
			MSplitter(
				MTree(
					fsubselect(state.tree, idfn |> FLift),
					[
						MTreeHideSeparators(),
						MTreeOrder(state.treeOrder),
						MTreeOnOrderChange(\t -> {
							if (length(t) > 0 && length(getValue(t[0].children)) > 0) {
								appendF3DUndo(state);

								next(state.scene, [makeF3DScene(state, getValue(t[0].children)[0])]);
							}
						})
					]
				)
				|> (\f -> MBorder(8.0, 8.0, 16.0, 8.0, f)),
				MSelect(state.selected, \o -> eitherMap(o, \c -> F3DObjectProperties(state, c), TEmpty()))
				|> (\f -> MBorder(24.0, 8.0, 24.0, 8.0, f)),
				TFillXY(),
				[
					MSplitterValue(make(0.6)),
					MSplitterHorizontal()
				]
			),
			TFillXY(),
			[MSplitterValue(make(0.8))]
		)
	)
	|> MCenterX
	|> (\f -> mrender(manager, true, f))
}

MLines2ReverseZorder(c1 : Material, c2 : Material) -> Material {
	MCopySize2(
		c1,
		\sz, c -> MGroup2(MLines2(sz, c2), c)
	)
}