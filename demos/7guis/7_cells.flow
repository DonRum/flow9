import material/material2tropic;

import lingo/pegcode/driver;

Spreadsheet(
	// Column index first, then row.
	cells : [[Cell]],
	dependencies : ref Tree<CellRef, Set<CellRef>>
);

Cell(
	text : DynamicBehaviour<string>,
	formula : DynamicBehaviour<Formula>,
	value : DynamicBehaviour<Value>
);

drawCell(cell : Cell) -> Material {
	MBorder(0.0, 0.0, 1.0, 1.0,
		MClickable(
			MFrame(2.0, 0.0,
				[Fill(white)],
				MGroup([
					MFixed(128.0, 24.0),
					MSelect(cell.text, \c -> {
						MText(c, [])
					}),
				])
			),
			\ -> {
				next(cell.text, "A")
			}
		)
	)
}

makeHeading(s : string) -> Material {
	MFixSize(
		MBorder(2.0, 2.0, 0.0, 0.0,
			MText(s, [])
		), MFixed(64.0, 29.0)
	)
}

// The formula language parser and evaluator

Formula ::= Expr, String;
Expr ::= Range, CellPos, Number, Call;

Number(d : double);
Range(start : CellPos, end : CellPos);
CellPos(col : string, row : int);
String(s : string);
Call(id : string, args : [Expr]);

Value ::= Number, String;

CellRef(col : int, row : int);

lingoGrammarOp : ref Maybe<[PegOp]> = ref None();

parseExpr(e : string) -> Formula {
	parsic(exprGrammar(), e, defaultPegActions);
}

exprGrammar() {
	onlyOnce(lingoGrammarOp, \ -> {
		compilePegGrammar(
			"
			formula = '=' expr:e { :e }
				| number:n { Number(:n) }
				| (char*)$s { String($s) }
				;

			expr = range | cell | number:n { Number(:n) } | call;

			call = id$i '(' args:a ')' { Call($i, :a) }
				| id$i '()' { Call($i, array()) };

				args = expr:e (',' expr:s {:s})*:t { consArray(:e, :t) }
					| expr:e { array(:e) };

			range = cell:c1 ':' cell:c2 { Range(:c1, :c2) };

			cell = letter$l int:i { CellPos($l, $i) };

			number = ('.' int)$d { s2d($d) }
				| (int '.' int?)$d { s2d($d) }
				| int$d { s2d($d) };

			int = (digit+)$i {s2i($i)};
			id! = (letter letterOrDigit*)$s {$s};

			letterOrDigit = 'a'-'z'
				| 'A'-'Z'
				| '_'
				| '0'-'9';
			letter = 'a'-'z'
				| 'A'-'Z'
				| '_';
			digit = '0'-'9';

			char = '\u0000' - '\uffff';
			"
		)
	});
}

evalFormula(spreadsheet : Spreadsheet, formula : Formula) -> Value {
	switch (formula) {
		Value(): formula;
		Range(start, end): String("Range has no value");
		CellPos(tcol, row): {
			cellref = cellPos2Ref(formula);
			if (cellref.col < length(spreadsheet.cells)) {
				column = spreadsheet.cells[cellref.col];
				if (cellref.row < length(column)) {
					getValue(column[cellref.row].value);
				} else {
					String("Cell does not exist");
				}
			} else {
				String("Cell does not exist");
			}
		}
		Call(id, args): {
			if (id == "add") {
				eargs = filtermap(args, \a -> getNumber(evalFormula(spreadsheet, a)));
				res = dsum(eargs);
				Number(res);
			} else if (id == "sub") {
				eargs = filtermap(args, \a -> getNumber(evalFormula(spreadsheet, a)));
				res = foldi(eargs, 0.0, \i, acc, n -> if (i == 0) n else acc - n);
				Number(res);
			} else if (id == "mul") {
				eargs = filtermap(args, \a -> getNumber(evalFormula(spreadsheet, a)));
				res = fold(eargs, 1.0, \acc, n -> acc * n);
				Number(res);
			} else if (id == "div") {
				eargs = filtermap(args, \a -> getNumber(evalFormula(spreadsheet, a)));
				res = foldi(eargs, 0.0, \i, acc, n -> if (i == 0) n else acc / n);
				Number(res);
			} else if (id == "mod") {
				eargs = filtermap(args, \a -> getNumber(evalFormula(spreadsheet, a)));
				res = foldi(eargs, 0.0, \i, acc, n -> if (i == 0) n else acc % n);
				Number(res);
			} else if (id == "sum") {
				if (length(args) == 1) {
					arg = args[0];
					switch (arg) {
						CellPos(__, __): evalFormula(spreadsheet, arg);
						Range(start, end): {
							cells = rangeToCells(arg);
							Number(fold(cells, 0.0, \acc, cell -> {
								acc + getCellNumber(spreadsheet, cell, acc)
							}));
						}
						default: String("sum expected range");
					}
				} else {
					String("Expected 1 arg to sum");
				}
			} else if (id == "prod") {
				if (length(args) == 1) {
					arg = args[0];
					switch (arg) {
						CellPos(__, __): evalFormula(spreadsheet, arg);
						Range(start, end): {
							cells = rangeToCells(arg);
							Number(fold(cells, 1.0, \acc, cell -> {
								acc * getCellNumber(spreadsheet, cell, acc)
							}));
						}
						default: String("prod expected range");
					}
				} else {
					String("Expected 1 arg to prod");
				}
			} else String("Id " + id + " not supported");
		}
	}
}

getCellNumber(spreadsheet : Spreadsheet, cell : CellRef, def : double) -> double {
	if (cell.col < length(spreadsheet.cells)) {
		column = spreadsheet.cells[cell.col];
		if (cell.row < length(column)) {
			val = getValue(column[cell.row].value);
			either(getNumber(val), def)
		} else def;
	} else def;
}

cellPos2Ref(c : CellPos) -> CellRef {
	col = getCharCodeAt(toUpperCase(c.col), 0) - 65;
	CellRef(col, c.row)
}

rangeToCells(r : Range) -> [CellRef] {
	s = cellPos2Ref(r.start);
	e = cellPos2Ref(r.end);
	concatA(generate(s.col, max(s.col, e.col) + 1, \col -> {
		generate(s.row, max(s.row, e.row) + 1, \row -> {
			CellRef(col, row)
		})
	}));
}

getNumber(value : Value) -> Maybe<double> {
	switch (value) {
		String(__): None();
		Number(n): Some(n);
	}
}

// Change propagation

setCellText(spreadsheet : Spreadsheet, c : CellRef, text : string) -> void {
	if (c.col < length(spreadsheet.cells)) {
		column = spreadsheet.cells[c.col];
		if (c.row < length(column)) {
			cell = column[c.row];

			next(cell.text, text);
			formula = parseExpr(text);
			next(cell.formula, formula);
			value = evalFormula(spreadsheet, formula);
			setCellValue(spreadsheet, c, value, makeSet());

			// Update dependencies
			deps = dependencies(makeSet(), formula);
			spreadsheet.dependencies := setTree(^(spreadsheet.dependencies), c, deps);

			{}
		}
	}
}

setCellValue(spreadsheet : Spreadsheet, c : CellRef, value : Value, visited : Set<CellRef>) -> Set<CellRef> {
	if (!containsSet(visited, c) && c.col < length(spreadsheet.cells)) {
		nvisited = insertSet(visited, c);
		column = spreadsheet.cells[c.col];
		if (c.row < length(column)) {
			cell = column[c.row];
			next(cell.value, value);
			next(cell.text, value2text(value));
			deps = lookupTreeDef(^(spreadsheet.dependencies), c, makeSet());
			foldSet(deps, nvisited, \acc, dep -> {
				val = getCellValue(spreadsheet, dep);
				setCellValue(spreadsheet, dep, val, acc)
			});
		} else nvisited;
	} else visited;
}

value2text(v : Value) -> string {
	switch (v) {
		Number(n): d2s(n);
		String(s): s;
	}
}

getCellValue(spreadsheet : Spreadsheet, c : CellRef) -> Value {
	if (c.col < length(spreadsheet.cells)) {
		column = spreadsheet.cells[c.col];
		if (c.row < length(column)) {
			cell = column[c.row];
			form = getValue(cell.formula);
			evalFormula(spreadsheet, form);
		} else String("Unknown cell");
	} else String("Unknown cell");
}

dependencies(acc : Set<CellRef>, f : Formula) -> Set<CellRef> {
	switch (f) {
		Value(): acc;
		Range(__, __): fold(rangeToCells(f), acc, insertSet);
		CellPos(__, __): insertSet(acc, cellPos2Ref(f));
		Call(id, args): fold(args, acc, dependencies);
	}
}

main() {
	cells : [[Cell]]= generate(0, 26, \col -> {
		generate(0, 100, \row -> {
			Cell(make("1"), make(Number(1.0)), make(Number(1.0)))
		})
	});
	spreadsheet = Spreadsheet(cells, ref makeTree());

	println(evalFormula(spreadsheet, parseExpr("=sum(a1:b5)")));

	mrender(makeMaterialManager([]), true, 
		MScroll(	
			MCols(
				concat([
						MLines(
							generate(-1, 100, \row -> {
								makeHeading(if (row == -1) "" else i2s(row))
							})
						)
					],
					mapi(cells, \x, col -> {
						MLines(concat(
							[
								makeHeading(fromCharCode(65 + x)),
							],
							map(col, \cell -> {
								drawCell(cell)
							})
						))
					})
				)
			), MFillXY(),
			[]
		)
	);
}
