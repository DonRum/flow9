import material/material2tropic;

import lingo/pegcode/driver;

Spreadsheet(
	// Column index first, then row.
	cells : [[Cell]],
	// From cell to what cells depends on this value
	dependencies : ref Tree<CellRef, Set<CellRef>>
);

Cell(
	text : DynamicBehaviour<string>,
	formula : DynamicBehaviour<Formula>,
	value : DynamicBehaviour<Value>
);

makeSpreadsheet(cols : int, rows : int) -> Material {
	cells : [[Cell]]= generate(0, cols, \col -> {
		generate(0, rows, \row -> {
			Cell(make(""), make(String("")), make(String("")))
		})
	});
	spreadsheet = Spreadsheet(cells, ref makeTree());
	MScroll(	
		MCols(
			concat([
					MLines(
						generate(-1, rows, \row -> {
							makeHeading(if (row == -1) "" else i2s(row))
						})
					)
				],
				mapi(cells, \x, col -> {
					MLines(concat(
						[
							makeHeading(fromCharCode(65 + x)),
						],
						mapi(col, \y, cell -> {
							drawCell(spreadsheet, cell, CellRef(x, y))
						})
					))
				})
			)
		), MFillXY(),
		[]
	);
}

drawCell(spreadsheet : Spreadsheet, cell : Cell, cellref : CellRef) -> Material {
	editing = make(false);
	MBorder(0.0, 0.0, 1.0, 1.0,
		MClickable(
			MFrame(2.0, 0.0,
				[Fill(white)],
				MGroup([
					MFixed(128.0, 24.0),
					MSelect(editing, \edit -> {
						if (edit) {
							focus = make(true);
							formula = make(formula2text(getValue(cell.formula), "="));
							MConstruct([
									makeSubscribe(focus, \f -> {
										if (!f) {
											val = getValue(formula);
											setCellText(spreadsheet, cellref, val);
											next(editing, false);
										}
									})
								],
								MTextInput(formula, [], [TTextInputFocus(focus)])
							)
						} else {
							MSelect(cell.text, \c -> {
								MText(c, [])
							})
						}
					}),
				])
			),
			\ -> {
				next(editing, true)
			}
		)
	)
}

makeHeading(s : string) -> Material {
	MFixSize(
		MBorder(2.0, 2.0, 0.0, 0.0,
			MText(s, [])
		), MFixed(64.0, 29.0)
	)
}

// The formula language parser and evaluator

Formula ::= Expr, String;
Expr ::= Range, CellPos, Number, Call;

Number(d : double);
Range(start : CellPos, end : CellPos);
CellPos(col : string, row : int);
String(s : string);
Call(id : string, args : [Expr]);

Value ::= Number, String;

CellRef(col : int, row : int);

lingoGrammarOp : ref Maybe<[PegOp]> = ref None();

parseExpr(e : string) -> Formula {
	parsic(exprGrammar(), e, defaultPegActions);
}

exprGrammar() {
	onlyOnce(lingoGrammarOp, \ -> {
		compilePegGrammar(
			"
			formula = '=' expr:e { :e }
				| number:n { Number(:n) }
				| (char*)$s { String($s) }
				;

			expr = range | cell | number:n { Number(:n) } | call;

			call = id$i '(' args:a ')' { Call($i, :a) }
				| id$i '()' { Call($i, array()) };

				args = expr:e (',' expr:s {:s})*:t { consArray(:e, :t) }
					| expr:e { array(:e) };

			range = cell:c1 ':' cell:c2 { Range(:c1, :c2) };

			cell = letter$l int:i { CellPos($l, $i) };

			number = ('.' int)$d { s2d($d) }
				| (int '.' int?)$d { s2d($d) }
				| int$d { s2d($d) };

			int = (digit+)$i {s2i($i)};
			id! = (letter letterOrDigit*)$s {$s};

			letterOrDigit = 'a'-'z'
				| 'A'-'Z'
				| '_'
				| '0'-'9';
			letter = 'a'-'z'
				| 'A'-'Z'
				| '_';
			digit = '0'-'9';

			char = '\u0000' - '\uffff';
			"
		)
	});
}

evalFormula(spreadsheet : Spreadsheet, formula : Formula) -> Value {
	switch (formula) {
		Value(): formula;
		Range(start, end): String("Range has no value");
		CellPos(tcol, row): {
			cellref = cellPos2Ref(formula);
			if (cellref.col < length(spreadsheet.cells)) {
				column = spreadsheet.cells[cellref.col];
				if (cellref.row < length(column)) {
					getValue(column[cellref.row].value);
				} else {
					String("Cell does not exist");
				}
			} else {
				String("Cell does not exist");
			}
		}
		Call(id, args): {
			if (id == "add") {
				eargs = filtermap(args, \a -> getNumber(evalFormula(spreadsheet, a)));
				res = dsum(eargs);
				Number(res);
			} else if (id == "sub") {
				eargs = filtermap(args, \a -> getNumber(evalFormula(spreadsheet, a)));
				res = foldi(eargs, 0.0, \i, acc, n -> if (i == 0) n else acc - n);
				Number(res);
			} else if (id == "mul") {
				eargs = filtermap(args, \a -> getNumber(evalFormula(spreadsheet, a)));
				res = fold(eargs, 1.0, \acc, n -> acc * n);
				Number(res);
			} else if (id == "div") {
				eargs = filtermap(args, \a -> getNumber(evalFormula(spreadsheet, a)));
				res = foldi(eargs, 0.0, \i, acc, n -> if (i == 0) n else acc / n);
				Number(res);
			} else if (id == "mod") {
				eargs = filtermap(args, \a -> getNumber(evalFormula(spreadsheet, a)));
				res = foldi(eargs, 0.0, \i, acc, n -> if (i == 0) n else acc % n);
				Number(res);
			} else if (id == "sum") {
				if (length(args) == 1) {
					arg = args[0];
					switch (arg) {
						CellPos(__, __): evalFormula(spreadsheet, arg);
						Range(start, end): {
							cells = rangeToCells(arg);
							Number(fold(cells, 0.0, \acc, cell -> {
								acc + getCellNumber(spreadsheet, cell, acc)
							}));
						}
						default: String("sum expected range");
					}
				} else {
					String("Expected 1 arg to sum");
				}
			} else if (id == "prod") {
				if (length(args) == 1) {
					arg = args[0];
					switch (arg) {
						CellPos(__, __): evalFormula(spreadsheet, arg);
						Range(start, end): {
							cells = rangeToCells(arg);
							Number(fold(cells, 1.0, \acc, cell -> {
								acc * getCellNumber(spreadsheet, cell, acc)
							}));
						}
						default: String("prod expected range");
					}
				} else {
					String("Expected 1 arg to prod");
				}
			} else String("Id " + id + " not supported");
		}
	}
}

getCellNumber(spreadsheet : Spreadsheet, cell : CellRef, def : double) -> double {
	if (cell.col < length(spreadsheet.cells)) {
		column = spreadsheet.cells[cell.col];
		if (cell.row < length(column)) {
			val = getValue(column[cell.row].value);
			either(getNumber(val), def)
		} else def;
	} else def;
}

cellPos2Ref(c : CellPos) -> CellRef {
	col = getCharCodeAt(toUpperCase(c.col), 0) - 65;
	CellRef(col, c.row)
}

rangeToCells(r : Range) -> [CellRef] {
	s = cellPos2Ref(r.start);
	e = cellPos2Ref(r.end);
	concatA(generate(s.col, max(s.col, e.col) + 1, \col -> {
		generate(s.row, max(s.row, e.row) + 1, \row -> {
			CellRef(col, row)
		})
	}));
}

getNumber(value : Value) -> Maybe<double> {
	switch (value) {
		String(__): None();
		Number(n): Some(n);
	}
}

// Change propagation

setCellText(spreadsheet : Spreadsheet, c : CellRef, text : string) -> void {
	if (c.col < length(spreadsheet.cells)) {
		column = spreadsheet.cells[c.col];
		if (c.row < length(column)) {
			cell = column[c.row];

			// OK, first find the old dependencies
			oldDeps = dependencies(makeSet(), getValue(cell.formula));
			// and remove them
			deps0 = foldSet(oldDeps, ^(spreadsheet.dependencies), \acc, dep -> {
				removeDependency(acc, c, dep);
			});

			// Next, update the cell with the new text, formula and value
			formula = parseExpr(text);
			next(cell.formula, formula);
			value = evalFormula(spreadsheet, formula);
			setCellValue(spreadsheet, c, value, makeSet());

			// Update dependencies
			deps = dependencies(makeSet(), formula);
			deps1 = foldSet(deps, deps0, \acc, dep -> {
				addDependency(acc, c, dep)
			})
			spreadsheet.dependencies := deps1;
		}
	}
}

addDependency(t : Tree<CellRef, Set<CellRef>>, from : CellRef, to : CellRef) -> Tree<CellRef, Set<CellRef>> {
	existing = lookupTreeDef(t, to, makeSet());
	setTree(t, to, insertSet(existing, from));
}

removeDependency(t : Tree<CellRef, Set<CellRef>>, from : CellRef, to : CellRef) -> Tree<CellRef, Set<CellRef>> {
	existing = lookupTreeDef(t, to, makeSet());
	setTree(t, to, removeSet(existing, from));
}

setCellValue(spreadsheet : Spreadsheet, c : CellRef, value : Value, visited : Set<CellRef>) -> Set<CellRef> {
	if (!containsSet(visited, c) && c.col < length(spreadsheet.cells)) {
		nvisited = insertSet(visited, c);
		column = spreadsheet.cells[c.col];
		if (c.row < length(column)) {
			cell = column[c.row];
			next(cell.value, value);
			next(cell.text, value2text(value));
			deps = lookupTreeDef(^(spreadsheet.dependencies), c, makeSet());
			foldSet(deps, nvisited, \acc, dep -> {
				val = getCellValue(spreadsheet, dep);
				setCellValue(spreadsheet, dep, val, acc)
			});
		} else nvisited;
	} else visited;
}

value2text(v : Value) -> string {
	switch (v) {
		Number(n): d2s(n);
		String(s): s;
	}
}

formula2text(f : Formula, prefix : string) -> string {
	switch (f) {
		Value(): value2text(f);
		CellPos(c, r): prefix + c + i2s(r);
		Range(start, end): prefix + formula2text(start, "") + ":" + formula2text(end, "");
		Call(id, args): prefix + id + "(" + superglue(args, \a -> formula2text(a, ""), ",") + ")";
	}
}



getCellValue(spreadsheet : Spreadsheet, c : CellRef) -> Value {
	if (c.col < length(spreadsheet.cells)) {
		column = spreadsheet.cells[c.col];
		if (c.row < length(column)) {
			cell = column[c.row];
			form = getValue(cell.formula);
			evalFormula(spreadsheet, form);
		} else String("Unknown cell");
	} else String("Unknown cell");
}

dependencies(acc : Set<CellRef>, f : Formula) -> Set<CellRef> {
	switch (f) {
		Value(): acc;
		Range(__, __): fold(rangeToCells(f), acc, insertSet);
		CellPos(__, __): insertSet(acc, cellPos2Ref(f));
		Call(id, args): fold(args, acc, dependencies);
	}
}

main() {
	spreadsheet = makeSpreadsheet(26, 100);

	mrender(makeMaterialManager([]), true, spreadsheet);
}
